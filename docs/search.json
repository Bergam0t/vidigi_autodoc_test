[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tutorial: vidigi",
    "section": "",
    "text": "vidigi helps you visualize the output of discrete event simulations, especially those built with the Simpy library. It takes a detailed Event Log (tracking entities like patients through stages) and transforms it into an animated scatter plot using Plotly. This allows users to visually validate model logic and understand system dynamics like queues and resource usage over time. Key components handle preparing data into snapshots, generating the animation, configuring the visual layout, and enhancing Simpy resources for better tracking.\nSource Repository: https://github.com/Bergam0t/vidigi\n\n\n\n\n\nflowchart TD\n    A0[\"Event Log\"]\n    A1[\"Snapshot Preparation - reshape_for_animations & generate_animation_df\"]\n    A2[\"Animation Generation - generate_animation\"]\n    A3[\"Layout Configuration - event_position_df\"]\n    A4[\"Simpy Resource Enhancement - CustomResource, Store, populate_store\"]\n    A5[\"Animation Facade - animate_activity_log\"]\n    A0 -- \"Provides data for\" --&gt; A1\n    A0 -- \"Is input to\" --&gt; A5\n    A1 -- \"Provides data for\" --&gt; A2\n    A3 -- \"Defines positions for\" --&gt; A1\n    A3 -- \"Defines layout for\" --&gt; A2\n    A3 -- \"Is input to\" --&gt; A5\n    A4 -- \"Enables resource ID logging in\" --&gt; A0\n    A4 -- \"Provides resource info to\" --&gt; A2\n    A5 -- \"Calls\" --&gt; A1\n    A5 -- \"Calls\" --&gt; A2\n\n\n\n\n\n\n\n\n\nAnimation Facade (animate_activity_log).qmd\nEvent Log\nLayout Configuration (event_position_df)\nSimpy Resource Enhancement (CustomResource, Store, populate_store)\nSnapshot Preparation (reshape_for_animations & generate_animation_df)\nAnimation Generation (generate_animation)\n\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Tutorial: vidigi"
    ]
  },
  {
    "objectID": "index.html#chapters",
    "href": "index.html#chapters",
    "title": "Tutorial: vidigi",
    "section": "",
    "text": "Animation Facade (animate_activity_log).qmd\nEvent Log\nLayout Configuration (event_position_df)\nSimpy Resource Enhancement (CustomResource, Store, populate_store)\nSnapshot Preparation (reshape_for_animations & generate_animation_df)\nAnimation Generation (generate_animation)\n\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Tutorial: vidigi"
    ]
  },
  {
    "objectID": "autodoc_v3/06_animation_generation_generate_animation_.html",
    "href": "autodoc_v3/06_animation_generation_generate_animation_.html",
    "title": "Chapter 6: Action! Making the Movie with generate_animation",
    "section": "",
    "text": "Great Scott! In Chapter 5: Prepare for Snapshots, McFly! (reshape_for_animations & generate_animation_df), we saw how vidigi acts like a skilled film crew, taking our raw Event Log (the script) and turning it into a detailed storyboard (full_patient_df_plus_pos). This storyboard tells us exactly who (Maverick, Goose) is doing what (‘wait_for_simulator’, ‘start_simulator’), when (minute 10, 15, etc.), and precisely where on the screen (‘x_final’, ‘y_final’) they should be, complete with their assigned icon (like giving Johnny 5 his signature look!).\nBut a storyboard isn’t a movie! We need to actually project these frames onto the screen, make them move smoothly, add the background scenery, and get the VCR (or maybe the Betamax?) rolling. We need the final rendering engine, the movie projector, the director yelling “Action!”\nThat’s the role of the generate_animation function! It takes the perfectly prepared snapshot data and uses the power of Plotly Express (think of it as the special effects department, maybe ILM back in the 80s) to create the final, interactive animation. It’s time to bring your data to life!\n\n\nOur mission, should we choose to accept it, is to take the full_patient_df_plus_pos DataFrame – our meticulously prepared sequence of snapshots with precise coordinates – and turn it into a slick, animated visualization. We want to see Maverick and Goose (represented by cool 80s-style emoji icons, naturally) move through the ‘Hangar Deck’, queue in the ‘Ready Room’, use the ‘Simulator Bays’, and finally head to ‘Debriefing’, all smoothly animated over time with a playable timeline. Cue the Top Gun theme!\n\n\n\nThink of generate_animation as the high-tech projector in the back of the cinema. It knows how to take the film reel (full_patient_df_plus_pos) and display it frame by frame, creating the illusion of motion.\nIts core mechanism relies on plotly.express.scatter:\n\nInput Data: It receives the full_patient_df_plus_pos DataFrame, which has columns like minute (or minute_display for formatted time), patient, x_final, y_final, and icon. This is the complete set of instructions for where each actor (icon) should be in every frame (minute).\nPlotly Magic: It calls plotly.express.scatter, telling it:\n\nUse x_final and y_final for the position of each point.\nUse icon as the text label for each point (making the points themselves invisible, so we only see the emoji!).\nUse minute_display as the animation_frame. This tells Plotly to create a separate frame for each unique value in this column and add a slider to control time.\nUse patient as the animation_group. This tells Plotly that rows with the same patient ID across different frames represent the same object moving, allowing Plotly to create smooth transitions between positions. It’s like telling the computer that the ‘Maverick’ icon in frame 10 is the same dude as the ‘Maverick’ icon in frame 11, just potentially in a different spot.\n\nAdding Static Layers: After Plotly creates the basic animated scatter plot, generate_animation adds extra, non-moving elements:\n\nStage Labels: If display_stage_labels=True, it adds text labels (from the Layout Configuration (event_position_df)) at the specified base coordinates, like putting up signs for “Hangar Deck” or “Simulator Bays”.\nResource Placeholders: If a scenario object is provided, it uses the resource counts (e.g., g.n_simulators) and the layout information to draw placeholder icons (often light blue circles, but customizable!) for all available resource slots (like ‘Sim_1’, ‘Sim_2’). This lets you see empty bays waiting for pilots. It’s like showing the empty parking spots in the FLAG Mobile Unit for K.I.T.T. and K.A.R.R.\nBackground Image: If you provide add_background_image, it stretches your image across the plot area, like projecting a cool background matte painting from Labyrinth or the digital grid from Tron.\n\nFinal Touches: It configures the plot’s appearance (hiding axes, setting height/width, adjusting animation speed) and returns the final Plotly Figure object.\n\n\n\n\nYou usually won’t call generate_animation directly. The main animate_activity_log function calls it for you after preparing the data with reshape_for_animations and generate_animation_df. However, understanding its signature helps you know what customization options are passed through.\nHere’s a conceptual call, assuming data_ready_for_animation (the output from generate_animation_df) and layout_df (our event_position_df) exist:\nimport plotly.graph_objects as go\nfrom vidigi.animation import generate_animation # Import the function\n# Assume 'data_ready_for_animation' DataFrame exists (output of generate_animation_df)\n# Assume 'layout_df' DataFrame exists (our event_position_df)\n# Assume 'g' scenario object exists with g.n_simulators = 2\n\n# --- This function is usually called internally by animate_activity_log ---\nfinal_figure = generate_animation(\n    full_patient_df_plus_pos=data_ready_for_animation, # The movie reel\n    event_position_df=layout_df, # Needed for labels/resource positions\n    scenario=g, # Needed for resource placeholders\n    plotly_height=600, # Make the screen shorter\n    icon_and_text_size=30, # Bigger icons! RADICAL!\n    display_stage_labels=True, # Show \"Simulator Bays\" etc.\n    add_background_image=\"path/to/your/awesome_grid.png\", # Optional Tron background\n    frame_duration=500, # Slow down the frames a bit (milliseconds)\n    frame_transition_duration=500 # Smoother transitions\n)\n\n# If you called it directly, you'd show it like this:\n# final_figure.show() # Uncomment to display!\n\nprint(\"Plotly Figure generated! Ready to rock and roll!\")\nThis call tells generate_animation to take the prepared data, use the layout for context, show resource placeholders based on the scenario, customize the appearance, and return the finished Plotly Figure object, ready to be displayed.\n\n\n\nLet’s peek inside generate_animation without needing K.I.T.T.’s X-ray scanner.\nStep-by-Step:\n\nReceive Inputs: Gets the prepared data (full_patient_df_plus_pos), layout (event_position_df), scenario, and all the customization parameters.\nCalculate Boundaries: Determines the X and Y axis ranges for the plot based on the layout or overrides.\nFormat Time: If time_display_units is set (e.g., ‘dhm’), it converts the raw minute numbers into nicely formatted date/time strings for the animation slider, storing them in minute_display. It keeps the original minute column for sorting. It’s like adding subtitles to the film.\nCore Animation (px.scatter): This is the main event! It calls plotly.express.scatter, passing the prepared data and mapping columns:\n\nx=\"x_final\"\ny=\"y_final\"\nanimation_frame=\"minute_display\"\nanimation_group=\"patient\"\ntext=\"icon\" (with opacity=0 for the underlying marker)\nhover_name, hover_data for interactivity. Plotly Express does the heavy lifting here, creating the base figure with animated points and the time slider. It’s like the core rendering engine turning vectors into pixels on the Tron grid.\n\nAdd Stage Labels (go.Scatter): If enabled, it iterates through the event_position_df and adds a static go.Scatter trace with mode=\"text\" to display the label at the base x, y coordinates.\nAdd Resource Placeholders (go.Scatter): If a scenario is provided, it calculates the positions for all resource slots (using the base x, y from the layout, gap_between_resources, gap_between_rows, and wrap_resources_at). It then adds another static go.Scatter trace (either mode=\"markers\" for default circles or mode=\"markers+text\" if custom_resource_icon is used) to show these placeholders. It’s like drawing the empty docking bays on Red Dwarf’s status screen.\nAdd Background (add_layout_image): If an image path is provided, it adds the image to the layout, stretched to fit the plot area.\nConfigure Layout: Updates the figure’s layout: sets height/width, hides axes and gridlines (unless setup_mode=True), ensures the play button is configured (or removed), and sets the animation frame/transition durations (frame_duration, frame_transition_duration).\nReturn Figure: Returns the fully constructed and configured plotly.graph_objs.Figure object.\n\nSequence Diagram:\n\n\n\n\n\nsequenceDiagram\n    participant Caller as Your Code / animate_activity_log\n    participant GA as generate_animation\n    participant DataIn as data_with_positions (DataFrame)\n    participant Layout as event_position_df (DataFrame)\n    participant Scenario as Scenario Object\n    participant PlotlyEx as Plotly Express\n    participant PlotlyGO as Plotly Graph Objects\n    participant PlotlyFig as Plotly Figure Output\n\n    Caller-&gt;&gt;GA: Call(data_with_positions, layout, scenario, ...)\n    GA-&gt;&gt;DataIn: Read positions, icons, minute\n    GA-&gt;&gt;Layout: Read base positions, labels\n    GA-&gt;&gt;Scenario: Read resource counts (if provided)\n    GA-&gt;&gt;PlotlyEx: px.scatter(DataIn, animation_frame='minute_display', ...)\n    PlotlyEx--&gt;&gt;GA: Return base animated Figure\n    alt display_stage_labels is True\n        GA-&gt;&gt;PlotlyGO: fig.add_trace(go.Scatter(mode='text', ...))\n    end\n    alt scenario is not None\n        GA-&gt;&gt;PlotlyGO: fig.add_trace(go.Scatter(mode='markers', ...)) # Resource placeholders\n    end\n    alt add_background_image is not None\n        GA-&gt;&gt;PlotlyFig: fig.add_layout_image(...)\n    end\n    GA-&gt;&gt;PlotlyFig: fig.update_layout(axes, speed, ...)\n    PlotlyFig--&gt;&gt;GA: Return configured Figure\n    GA--&gt;&gt;Caller: Return final_figure\n\n\n\n\n\n\nCode Snippets (Simplified from vidigi/animation.py):\nThe core animation command:\n# --- Inside generate_animation (Simplified) ---\nimport plotly.express as px\n\n# (Assume data_ready_for_animation has columns:\n#  'x_final', 'y_final', 'minute_display', 'patient', 'icon', 'event', ...)\n\nfig = px.scatter(\n    data_ready_for_animation.sort_values('minute'), # Sort by time!\n    x=\"x_final\",\n    y=\"y_final\",\n    animation_frame=\"minute_display\", # Tells Plotly how to make frames\n    animation_group=\"patient\",       # Tells Plotly how to connect dots\n    text=\"icon\",                    # Display the emoji icon\n    hover_name=\"event\",             # Show event name on hover\n    # ... other parameters like hover_data, ranges, height ...\n    opacity=0                       # Make the underlying point invisible\n)\n# Status: Base animation created! Like the raw footage.\n# --- End Snippet ---\nThis single call creates the moving emojis and the time slider. Everything else builds on this foundation.\nAdding static stage labels:\n# --- Inside generate_animation (Simplified) ---\nimport plotly.graph_objects as go\n# (Assume 'layout_df' has columns 'x', 'y', 'label')\n\nif display_stage_labels:\n    fig.add_trace(go.Scatter(\n        x=layout_df['x'], # Base X coordinates\n        y=layout_df['y'], # Base Y coordinates\n        mode=\"text\",     # We just want text, no markers\n        name=\"\",         # No legend entry needed\n        text=layout_df['label'], # The labels to display\n        textposition=\"middle right\", # Position relative to x,y\n        hoverinfo='none' # Don't show hover info for labels\n    ))\n# Status: Added signs like \"Welcome to Hill Valley\".\n# --- End Snippet ---\nAdding static resource placeholder icons:\n# --- Inside generate_animation (Simplified) ---\nimport plotly.graph_objects as go\nimport pandas as pd\n# (Assume 'events_with_resources' DataFrame is calculated with columns:\n#  'x_final', 'y_final' for each resource slot position)\n\nif scenario is not None:\n    # (Calculation of 'events_with_resources' positions omitted for brevity)\n    # ... calculates x_final, y_final for each resource slot ...\n\n    fig.add_trace(go.Scatter(\n        x=events_with_resources['x_final'],\n        y=[i - 10 for i in events_with_resources['y_final']], # Slightly offset Y\n        mode=\"markers\", # Draw markers (default: circles)\n        marker=dict(\n            color='LightSkyBlue',\n            size=15), # Appearance of markers\n        opacity=resource_opacity, # Make them semi-transparent\n        hoverinfo='none' # No hover needed\n    ))\n# Status: Added placeholders for empty simulator bays. Number 5 is... available!\n# --- End Snippet ---\nAdding the background image:\n# --- Inside generate_animation (Simplified) ---\n# (Assume 'add_background_image' holds the file path string)\n\nif add_background_image is not None:\n    fig.add_layout_image(\n        dict(\n            source=add_background_image, # Path to the image file\n            xref=\"x domain\", yref=\"y domain\", # Stretch across axes\n            x=1, y=1, sizex=1, sizey=1, # Cover the whole area\n            xanchor=\"right\", yanchor=\"top\",\n            sizing=\"stretch\", # Stretch to fit\n            opacity=0.5,      # Make it slightly transparent\n            layer=\"below\"     # Draw it underneath everything else\n        )\n    )\n# Status: Laid down the background, maybe the entrance to Jareth's Labyrinth!\n# --- End Snippet ---\nThese snippets show how generate_animation builds the final plot layer by layer, starting with the core animation from Plotly Express and adding static elements using Plotly Graph Objects.\n\n\n\nYou’ve reached the end of the production line! generate_animation is the final function in the vidigi animation pipeline, the projector that takes the meticulously prepared snapshot data (full_patient_df_plus_pos) and renders it into a dynamic, interactive Plotly animation. It leverages Plotly Express for the core animation and adds essential static layers like stage labels, resource placeholders, and background images.\nThis function, along with its partners reshape_for_animations and generate_animation_df, does the heavy lifting behind the scenes when you call the main animate_activity_log function. Together, they turn your raw simulation Event Log and Layout Configuration (event_position_df) into a visual story, letting you see your process unfold like never before – hopefully without disrupting the space-time continuum!\nYou now understand the key components and the flow of data required to create vidigi animations. Go forth and visualize your processes – make them totally awesome, to the max!\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 6: Action! Making the Movie with `generate_animation`"
    ]
  },
  {
    "objectID": "autodoc_v3/06_animation_generation_generate_animation_.html#the-mission-rolling-film",
    "href": "autodoc_v3/06_animation_generation_generate_animation_.html#the-mission-rolling-film",
    "title": "Chapter 6: Action! Making the Movie with generate_animation",
    "section": "",
    "text": "Our mission, should we choose to accept it, is to take the full_patient_df_plus_pos DataFrame – our meticulously prepared sequence of snapshots with precise coordinates – and turn it into a slick, animated visualization. We want to see Maverick and Goose (represented by cool 80s-style emoji icons, naturally) move through the ‘Hangar Deck’, queue in the ‘Ready Room’, use the ‘Simulator Bays’, and finally head to ‘Debriefing’, all smoothly animated over time with a playable timeline. Cue the Top Gun theme!",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 6: Action! Making the Movie with `generate_animation`"
    ]
  },
  {
    "objectID": "autodoc_v3/06_animation_generation_generate_animation_.html#the-projector-how-generate_animation-works",
    "href": "autodoc_v3/06_animation_generation_generate_animation_.html#the-projector-how-generate_animation-works",
    "title": "Chapter 6: Action! Making the Movie with generate_animation",
    "section": "",
    "text": "Think of generate_animation as the high-tech projector in the back of the cinema. It knows how to take the film reel (full_patient_df_plus_pos) and display it frame by frame, creating the illusion of motion.\nIts core mechanism relies on plotly.express.scatter:\n\nInput Data: It receives the full_patient_df_plus_pos DataFrame, which has columns like minute (or minute_display for formatted time), patient, x_final, y_final, and icon. This is the complete set of instructions for where each actor (icon) should be in every frame (minute).\nPlotly Magic: It calls plotly.express.scatter, telling it:\n\nUse x_final and y_final for the position of each point.\nUse icon as the text label for each point (making the points themselves invisible, so we only see the emoji!).\nUse minute_display as the animation_frame. This tells Plotly to create a separate frame for each unique value in this column and add a slider to control time.\nUse patient as the animation_group. This tells Plotly that rows with the same patient ID across different frames represent the same object moving, allowing Plotly to create smooth transitions between positions. It’s like telling the computer that the ‘Maverick’ icon in frame 10 is the same dude as the ‘Maverick’ icon in frame 11, just potentially in a different spot.\n\nAdding Static Layers: After Plotly creates the basic animated scatter plot, generate_animation adds extra, non-moving elements:\n\nStage Labels: If display_stage_labels=True, it adds text labels (from the Layout Configuration (event_position_df)) at the specified base coordinates, like putting up signs for “Hangar Deck” or “Simulator Bays”.\nResource Placeholders: If a scenario object is provided, it uses the resource counts (e.g., g.n_simulators) and the layout information to draw placeholder icons (often light blue circles, but customizable!) for all available resource slots (like ‘Sim_1’, ‘Sim_2’). This lets you see empty bays waiting for pilots. It’s like showing the empty parking spots in the FLAG Mobile Unit for K.I.T.T. and K.A.R.R.\nBackground Image: If you provide add_background_image, it stretches your image across the plot area, like projecting a cool background matte painting from Labyrinth or the digital grid from Tron.\n\nFinal Touches: It configures the plot’s appearance (hiding axes, setting height/width, adjusting animation speed) and returns the final Plotly Figure object.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 6: Action! Making the Movie with `generate_animation`"
    ]
  },
  {
    "objectID": "autodoc_v3/06_animation_generation_generate_animation_.html#using-the-projector-code-example",
    "href": "autodoc_v3/06_animation_generation_generate_animation_.html#using-the-projector-code-example",
    "title": "Chapter 6: Action! Making the Movie with generate_animation",
    "section": "",
    "text": "You usually won’t call generate_animation directly. The main animate_activity_log function calls it for you after preparing the data with reshape_for_animations and generate_animation_df. However, understanding its signature helps you know what customization options are passed through.\nHere’s a conceptual call, assuming data_ready_for_animation (the output from generate_animation_df) and layout_df (our event_position_df) exist:\nimport plotly.graph_objects as go\nfrom vidigi.animation import generate_animation # Import the function\n# Assume 'data_ready_for_animation' DataFrame exists (output of generate_animation_df)\n# Assume 'layout_df' DataFrame exists (our event_position_df)\n# Assume 'g' scenario object exists with g.n_simulators = 2\n\n# --- This function is usually called internally by animate_activity_log ---\nfinal_figure = generate_animation(\n    full_patient_df_plus_pos=data_ready_for_animation, # The movie reel\n    event_position_df=layout_df, # Needed for labels/resource positions\n    scenario=g, # Needed for resource placeholders\n    plotly_height=600, # Make the screen shorter\n    icon_and_text_size=30, # Bigger icons! RADICAL!\n    display_stage_labels=True, # Show \"Simulator Bays\" etc.\n    add_background_image=\"path/to/your/awesome_grid.png\", # Optional Tron background\n    frame_duration=500, # Slow down the frames a bit (milliseconds)\n    frame_transition_duration=500 # Smoother transitions\n)\n\n# If you called it directly, you'd show it like this:\n# final_figure.show() # Uncomment to display!\n\nprint(\"Plotly Figure generated! Ready to rock and roll!\")\nThis call tells generate_animation to take the prepared data, use the layout for context, show resource placeholders based on the scenario, customize the appearance, and return the finished Plotly Figure object, ready to be displayed.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 6: Action! Making the Movie with `generate_animation`"
    ]
  },
  {
    "objectID": "autodoc_v3/06_animation_generation_generate_animation_.html#under-the-hood-inside-the-projection-booth",
    "href": "autodoc_v3/06_animation_generation_generate_animation_.html#under-the-hood-inside-the-projection-booth",
    "title": "Chapter 6: Action! Making the Movie with generate_animation",
    "section": "",
    "text": "Let’s peek inside generate_animation without needing K.I.T.T.’s X-ray scanner.\nStep-by-Step:\n\nReceive Inputs: Gets the prepared data (full_patient_df_plus_pos), layout (event_position_df), scenario, and all the customization parameters.\nCalculate Boundaries: Determines the X and Y axis ranges for the plot based on the layout or overrides.\nFormat Time: If time_display_units is set (e.g., ‘dhm’), it converts the raw minute numbers into nicely formatted date/time strings for the animation slider, storing them in minute_display. It keeps the original minute column for sorting. It’s like adding subtitles to the film.\nCore Animation (px.scatter): This is the main event! It calls plotly.express.scatter, passing the prepared data and mapping columns:\n\nx=\"x_final\"\ny=\"y_final\"\nanimation_frame=\"minute_display\"\nanimation_group=\"patient\"\ntext=\"icon\" (with opacity=0 for the underlying marker)\nhover_name, hover_data for interactivity. Plotly Express does the heavy lifting here, creating the base figure with animated points and the time slider. It’s like the core rendering engine turning vectors into pixels on the Tron grid.\n\nAdd Stage Labels (go.Scatter): If enabled, it iterates through the event_position_df and adds a static go.Scatter trace with mode=\"text\" to display the label at the base x, y coordinates.\nAdd Resource Placeholders (go.Scatter): If a scenario is provided, it calculates the positions for all resource slots (using the base x, y from the layout, gap_between_resources, gap_between_rows, and wrap_resources_at). It then adds another static go.Scatter trace (either mode=\"markers\" for default circles or mode=\"markers+text\" if custom_resource_icon is used) to show these placeholders. It’s like drawing the empty docking bays on Red Dwarf’s status screen.\nAdd Background (add_layout_image): If an image path is provided, it adds the image to the layout, stretched to fit the plot area.\nConfigure Layout: Updates the figure’s layout: sets height/width, hides axes and gridlines (unless setup_mode=True), ensures the play button is configured (or removed), and sets the animation frame/transition durations (frame_duration, frame_transition_duration).\nReturn Figure: Returns the fully constructed and configured plotly.graph_objs.Figure object.\n\nSequence Diagram:\n\n\n\n\n\nsequenceDiagram\n    participant Caller as Your Code / animate_activity_log\n    participant GA as generate_animation\n    participant DataIn as data_with_positions (DataFrame)\n    participant Layout as event_position_df (DataFrame)\n    participant Scenario as Scenario Object\n    participant PlotlyEx as Plotly Express\n    participant PlotlyGO as Plotly Graph Objects\n    participant PlotlyFig as Plotly Figure Output\n\n    Caller-&gt;&gt;GA: Call(data_with_positions, layout, scenario, ...)\n    GA-&gt;&gt;DataIn: Read positions, icons, minute\n    GA-&gt;&gt;Layout: Read base positions, labels\n    GA-&gt;&gt;Scenario: Read resource counts (if provided)\n    GA-&gt;&gt;PlotlyEx: px.scatter(DataIn, animation_frame='minute_display', ...)\n    PlotlyEx--&gt;&gt;GA: Return base animated Figure\n    alt display_stage_labels is True\n        GA-&gt;&gt;PlotlyGO: fig.add_trace(go.Scatter(mode='text', ...))\n    end\n    alt scenario is not None\n        GA-&gt;&gt;PlotlyGO: fig.add_trace(go.Scatter(mode='markers', ...)) # Resource placeholders\n    end\n    alt add_background_image is not None\n        GA-&gt;&gt;PlotlyFig: fig.add_layout_image(...)\n    end\n    GA-&gt;&gt;PlotlyFig: fig.update_layout(axes, speed, ...)\n    PlotlyFig--&gt;&gt;GA: Return configured Figure\n    GA--&gt;&gt;Caller: Return final_figure\n\n\n\n\n\n\nCode Snippets (Simplified from vidigi/animation.py):\nThe core animation command:\n# --- Inside generate_animation (Simplified) ---\nimport plotly.express as px\n\n# (Assume data_ready_for_animation has columns:\n#  'x_final', 'y_final', 'minute_display', 'patient', 'icon', 'event', ...)\n\nfig = px.scatter(\n    data_ready_for_animation.sort_values('minute'), # Sort by time!\n    x=\"x_final\",\n    y=\"y_final\",\n    animation_frame=\"minute_display\", # Tells Plotly how to make frames\n    animation_group=\"patient\",       # Tells Plotly how to connect dots\n    text=\"icon\",                    # Display the emoji icon\n    hover_name=\"event\",             # Show event name on hover\n    # ... other parameters like hover_data, ranges, height ...\n    opacity=0                       # Make the underlying point invisible\n)\n# Status: Base animation created! Like the raw footage.\n# --- End Snippet ---\nThis single call creates the moving emojis and the time slider. Everything else builds on this foundation.\nAdding static stage labels:\n# --- Inside generate_animation (Simplified) ---\nimport plotly.graph_objects as go\n# (Assume 'layout_df' has columns 'x', 'y', 'label')\n\nif display_stage_labels:\n    fig.add_trace(go.Scatter(\n        x=layout_df['x'], # Base X coordinates\n        y=layout_df['y'], # Base Y coordinates\n        mode=\"text\",     # We just want text, no markers\n        name=\"\",         # No legend entry needed\n        text=layout_df['label'], # The labels to display\n        textposition=\"middle right\", # Position relative to x,y\n        hoverinfo='none' # Don't show hover info for labels\n    ))\n# Status: Added signs like \"Welcome to Hill Valley\".\n# --- End Snippet ---\nAdding static resource placeholder icons:\n# --- Inside generate_animation (Simplified) ---\nimport plotly.graph_objects as go\nimport pandas as pd\n# (Assume 'events_with_resources' DataFrame is calculated with columns:\n#  'x_final', 'y_final' for each resource slot position)\n\nif scenario is not None:\n    # (Calculation of 'events_with_resources' positions omitted for brevity)\n    # ... calculates x_final, y_final for each resource slot ...\n\n    fig.add_trace(go.Scatter(\n        x=events_with_resources['x_final'],\n        y=[i - 10 for i in events_with_resources['y_final']], # Slightly offset Y\n        mode=\"markers\", # Draw markers (default: circles)\n        marker=dict(\n            color='LightSkyBlue',\n            size=15), # Appearance of markers\n        opacity=resource_opacity, # Make them semi-transparent\n        hoverinfo='none' # No hover needed\n    ))\n# Status: Added placeholders for empty simulator bays. Number 5 is... available!\n# --- End Snippet ---\nAdding the background image:\n# --- Inside generate_animation (Simplified) ---\n# (Assume 'add_background_image' holds the file path string)\n\nif add_background_image is not None:\n    fig.add_layout_image(\n        dict(\n            source=add_background_image, # Path to the image file\n            xref=\"x domain\", yref=\"y domain\", # Stretch across axes\n            x=1, y=1, sizex=1, sizey=1, # Cover the whole area\n            xanchor=\"right\", yanchor=\"top\",\n            sizing=\"stretch\", # Stretch to fit\n            opacity=0.5,      # Make it slightly transparent\n            layer=\"below\"     # Draw it underneath everything else\n        )\n    )\n# Status: Laid down the background, maybe the entrance to Jareth's Labyrinth!\n# --- End Snippet ---\nThese snippets show how generate_animation builds the final plot layer by layer, starting with the core animation from Plotly Express and adding static elements using Plotly Graph Objects.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 6: Action! Making the Movie with `generate_animation`"
    ]
  },
  {
    "objectID": "autodoc_v3/06_animation_generation_generate_animation_.html#conclusion-thats-a-wrap",
    "href": "autodoc_v3/06_animation_generation_generate_animation_.html#conclusion-thats-a-wrap",
    "title": "Chapter 6: Action! Making the Movie with generate_animation",
    "section": "",
    "text": "You’ve reached the end of the production line! generate_animation is the final function in the vidigi animation pipeline, the projector that takes the meticulously prepared snapshot data (full_patient_df_plus_pos) and renders it into a dynamic, interactive Plotly animation. It leverages Plotly Express for the core animation and adds essential static layers like stage labels, resource placeholders, and background images.\nThis function, along with its partners reshape_for_animations and generate_animation_df, does the heavy lifting behind the scenes when you call the main animate_activity_log function. Together, they turn your raw simulation Event Log and Layout Configuration (event_position_df) into a visual story, letting you see your process unfold like never before – hopefully without disrupting the space-time continuum!\nYou now understand the key components and the flow of data required to create vidigi animations. Go forth and visualize your processes – make them totally awesome, to the max!\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 6: Action! Making the Movie with `generate_animation`"
    ]
  },
  {
    "objectID": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html",
    "href": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html",
    "title": "Chapter 4: More Input! Giving Your Resources an Upgrade (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Great Scott! In Chapter 3: Where Am I? Mapping the Grid with event_position_df, we learned how to tell vidigi where on the screen to place our entities for different activities, like mapping out the Grid for Tron. We know where the ‘Simulator Bays’ are, but what if we want to see Maverick consistently use Simulator 1 while Goose uses Simulator 2?\nStandard Simpy resources (like simpy.Resource) are a bit like the identical worker droids in Silent Running or maybe a whole fleet of K.I.T.T. prototypes before the final Knight Rider – they all look and act the same from the outside. If you have 3 nurses represented by a simpy.Resource(env, capacity=3), when a patient grabs one, Simpy just knows one of the three is busy. It doesn’t track which specific one.\nThis is usually fine for simulation results, but for our animation, it’s like trying to film Top Gun without knowing which specific F-14 Tomcat Maverick is flying in each scene! We want to see consistency. If Maverick starts using Nurse Jackie #1, we want the animation to show him staying with Nurse Jackie #1 until he’s done.\nThat’s where vidigi‘s resource enhancement pattern comes in. It’s like giving each resource worker a unique ID badge or maybe painting a different number on each Ghostbusters’ proton pack.\n\n\nOur mission is to adapt our Simpy simulation model so that vidigi can track the usage of individual resource units. We need a way to: 1. Give each unit of a resource (like each nurse, simulator, or maybe each power loader Ripley might use) a unique ID. 2. Record this unique ID in our Event Log whenever an entity starts or stops using that specific resource unit.\nThis recorded ID (resource_id) is the crucial piece of information vidigi needs to make the animation show consistent resource use.\n\n\n\nThe first piece of our upgrade kit is the CustomResource. It’s a very simple enhancement to the standard simpy.Resource. Think of it as taking a standard Cylon Centurion and welding a unique serial number onto its chassis.\nCustomResource is a class provided in vidigi.utils that inherits everything from simpy.Resource but adds one important thing: an id_attribute.\nHere’s a peek under the hood (you don’t usually need to write this yourself, just import it!):\n# Located in vidigi/utils.py (simplified)\nimport simpy\n\nclass CustomResource(simpy.Resource):\n    \"\"\"A custom resource with an ID.\"\"\"\n    def __init__(self, env, capacity, id_attribute=None):\n        # Call the original simpy.Resource setup\n        super().__init__(env, capacity)\n        # Add our special ID badge!\n        self.id_attribute = id_attribute\n\n    # Request and release methods are inherited, but could be customized\n    # (vidigi's default doesn't need to change them)\nSee? It’s mostly just a standard simpy.Resource, but it has that extra id_attribute ready to store a unique identifier, like ‘Nurse_1’ or ‘Sim_Bay_Alpha’. Number 5 is alive… and has an ID!\n\n\n\nOkay, we have resources with ID badges (CustomResource), but how do we manage a pool of them? If we have 3 nurses, we need a way to hold all 3 CustomResource instances. We can’t just use simpy.Resource(env, capacity=3) anymore, because that creates one resource object managing 3 anonymous slots.\nInstead, we use simpy.Store. A Store is like a magical container, maybe the Labyrinth’s oubliette, or the Ghostbusters’ Ecto-Containment Unit, or perhaps a vending machine that holds items. You can put items into the store and get items out.\nCrucially for us, we can put our individual CustomResource instances (each with its unique id_attribute) into the Store. When an entity needs a resource, it will yield store.get(), and Simpy will hand it one of the available CustomResource objects from the store.\n\n\n\nManually creating each CustomResource and putting it into the Store can be a bit repetitive, like programming the same patrol route for multiple ED-209s.\n# --- The Manual Way (Don't do this!) ---\nimport simpy\nfrom vidigi.utils import CustomResource\n\nenv = simpy.Environment()\nnum_nurses = 3\nnurse_store = simpy.Store(env)\n\n# Create and add Nurse 1\nnurse_1 = CustomResource(env, capacity=1, id_attribute='Nurse_1')\nnurse_store.put(nurse_1)\n\n# Create and add Nurse 2\nnurse_2 = CustomResource(env, capacity=1, id_attribute='Nurse_2')\nnurse_store.put(nurse_2)\n\n# Create and add Nurse 3\nnurse_3 = CustomResource(env, capacity=1, id_attribute='Nurse_3')\nnurse_store.put(nurse_3)\n\nprint(f\"Store now has {len(nurse_store.items)} nurses.\")\n# --- End Manual Way ---\nThat’s a bit much! To make this easier, vidigi provides a helper function: populate_store. It’s like calling Q branch – you tell it how many resources you need (num_resources), which store to put them in (simpy_store), and the simulation environment (sim_env), and it does the work for you!\nHere’s how to use it (this is the recommended way!):\nimport simpy\nfrom vidigi.utils import populate_store # Import the helper\n\nenv = simpy.Environment()\nnum_nurses = 3 # How many nurses we need\n\n# Create the empty store\nnurse_store = simpy.Store(env)\n\n# Use the helper to fill the store! Way easier!\npopulate_store(\n    num_resources=num_nurses,\n    simpy_store=nurse_store,\n    sim_env=env\n)\n\nprint(f\"Store now has {len(nurse_store.items)} nurses, created the easy way!\")\nMuch cleaner! populate_store automatically creates num_nurses instances of CustomResource, gives each one a unique id_attribute (1, 2, 3,…), and puts them into nurse_store. Ready for action!\n\n\n\nNow, let’s see how to use this pattern in a typical Simpy process function.\nScenario: A patient needs to see a nurse.\n1. Old Way (using simpy.Resource)\n# --- Before Vidigi Enhancement ---\nimport simpy\n\n# Assume g.n_nurses = 3, env exists\n# Assume nurses = simpy.Resource(env, capacity=g.n_nurses)\n# Assume event_log = [] exists\n\ndef patient_process_old(env, patient_id, nurses, event_log):\n    print(f\"{env.now}: Patient {patient_id} waiting for any nurse.\")\n    # Request ANY available nurse slot\n    with nurses.request() as req:\n        yield req\n        print(f\"{env.now}: Patient {patient_id} got a nurse (don't know which!).\")\n        # --- LOGGING PROBLEM: No specific resource_id ---\n        # event_log.append({'patient': patient_id, ..., 'resource_id': ???})\n\n        # Simulate treatment time\n        yield env.timeout(15) # 15 minutes treatment\n\n    print(f\"{env.now}: Patient {patient_id} finished with nurse.\")\n    # --- LOGGING PROBLEM: No specific resource_id ---\nIn this version, we don’t know which of the 3 nurse slots the patient used, so we can’t log a specific resource_id.\n2. New Way (using Store with CustomResource)\nFirst, set up the resource store (usually in your model’s __init__ or init_resources method):\n# --- Setting up the Store (e.g., in Model.__init__) ---\nimport simpy\nfrom vidigi.utils import populate_store\n\nclass YourModel:\n    def __init__(self, env, num_nurses):\n        self.env = env\n        self.nurse_store = simpy.Store(env)\n        populate_store(num_nurses, self.nurse_store, self.env)\n        # ... other setup ...\nNow, modify the process function to use the store and log the ID:\n# --- After Vidigi Enhancement ---\n# Assume model.nurse_store exists and was populated\n# Assume event_log = [] exists\n\ndef patient_process_new(env, patient_id, nurse_store, event_log):\n    print(f\"{env.now}: Patient {patient_id} waiting for a specific nurse.\")\n    # Request a SPECIFIC nurse instance from the store\n    nurse_resource = yield nurse_store.get() # Like getting a specific item\n\n    try:\n        # We got one! Access its unique ID badge\n        nurse_id = nurse_resource.id_attribute\n        print(f\"{env.now}: Patient {patient_id} got nurse {nurse_id}!\")\n\n        # --- LOGGING SUCCESS! ---\n        event_log.append({\n            'patient': patient_id, 'event_type': 'resource_use',\n            'event': 'start_nurse_visit', 'time': env.now,\n            'resource_id': nurse_id # &lt;--- Log the specific ID!\n        })\n\n        # Simulate treatment time\n        yield env.timeout(15) # 15 minutes treatment\n\n        print(f\"{env.now}: Patient {patient_id} finished with nurse {nurse_id}.\")\n        # --- LOGGING SUCCESS! ---\n        event_log.append({\n            'patient': patient_id, 'event_type': 'resource_use_end',\n            'event': 'end_nurse_visit', 'time': env.now,\n            'resource_id': nurse_id # &lt;--- Log the same ID!\n        })\n\n    finally:\n        # IMPORTANT: Put the specific nurse back in the store!\n        # Like returning your proton pack to the rack.\n        nurse_store.put(nurse_resource)\nKey changes: * We use yield nurse_store.get() instead of nurses.request(). * We get back a specific nurse_resource object (an instance of CustomResource). * We access its unique ID using nurse_resource.id_attribute. * We log this ID in the resource_id column of our Event Log for both resource_use and resource_use_end events. * Crucially, we use nurse_store.put(nurse_resource) to return the exact same nurse instance back to the pool when we’re done. (Using try...finally ensures it gets put back even if something goes wrong during treatment).\nThis pattern ensures our event log contains the specific resource_id, allowing vidigi to render the animation correctly!\nHere’s a visual summary of the interaction:\n\n\n\n\n\nsequenceDiagram\n    participant Entity as Patient Process\n    participant Store as simpy.Store (Nurse Store)\n    participant CR as CustomResource (Nurse_1)\n    participant Log as Event Log List\n\n    Entity-&gt;&gt;Store: yield store.get()\n    Store--&gt;&gt;CR: Selects available CustomResource (e.g., Nurse_1)\n    CR--&gt;&gt;Entity: Returns Nurse_1 instance\n    Entity-&gt;&gt;Log: Append 'resource_use' event (resource_id = Nurse_1.id_attribute)\n    Note over Entity: Use the resource (yield timeout)\n    Entity-&gt;&gt;Log: Append 'resource_use_end' event (resource_id = Nurse_1.id_attribute)\n    Entity-&gt;&gt;Store: store.put(Nurse_1)\n\n\n\n\n\n\n\n\n\nHow does this magic work? It’s actually quite straightforward, no 1.21 gigawatts required!\n\nCustomResource (vidigi/utils.py): As we saw, it’s just a standard simpy.Resource with an extra id_attribute added during initialization (__init__).\n# From vidigi/utils.py\nclass CustomResource(simpy.Resource):\n    def __init__(self, env, capacity, id_attribute=None):\n        super().__init__(env, capacity)\n        self.id_attribute = id_attribute # The only addition!\npopulate_store (vidigi/utils.py): This function simply runs a loop. For the number of resources requested, it creates a CustomResource instance (giving it i+1 as the id_attribute) and calls the store’s put method.\n# From vidigi/utils.py (Simplified)\ndef populate_store(num_resources, simpy_store, sim_env):\n    for i in range(num_resources):\n        # Create a resource with ID i+1 (so IDs start from 1)\n        resource_instance = CustomResource(\n            sim_env,\n            capacity=1, # Usually 1 for items in a store\n            id_attribute = i+1\n        )\n        # Put it in the store\n        simpy_store.put(resource_instance)\nLogging: Your simulation code is responsible for grabbing the .id_attribute from the resource instance obtained via store.get() and putting it into the resource_id column of your event log dictionary/DataFrame.\nAnimation Use: Later, when animate_activity_log runs, its helper function generate_animation_df reads your Event Log. When it sees a resource_use event, it uses the logged resource_id along with the base position from the Layout Configuration (event_position_df) to calculate the exact, consistent screen position for that entity using that specific resource instance (as explained conceptually in Chapter 3).\n\nThis simple pattern of adding an ID and using a Store is all it takes to give vidigi the information it needs!\n\n\n\nYou’ve successfully navigated the resource enhancement quadrant! You now know why standard simpy.Resource isn’t enough for detailed animation tracking and how the CustomResource + simpy.Store + populate_store pattern solves this. It’s like giving every resource worker their own unique callsign – Maverick, Goose, Iceman – instead of just ‘Pilot’.\nBy using yield store.get(), logging the .id_attribute as resource_id, and using store.put(), you provide the crucial link vidigi needs to show entities consistently interacting with the same resource icon throughout the animation.\nWith our event logs (Chapter 2: Event Log) correctly recording events and specific resource IDs, and our layout (Chapter 3: Layout Configuration (event_position_df)) defined, we’re almost ready to make the animation movie. But first, vidigi needs to process that raw event log into a format suitable for animation frames – like taking snapshots of the action.\nLet’s jump in the DeLorean and head to the next chapter: Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df). Get ready to reshape time… I mean, data!\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 4: More Input! Giving Your Resources an Upgrade (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#the-mission-identifying-individual-resources",
    "href": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#the-mission-identifying-individual-resources",
    "title": "Chapter 4: More Input! Giving Your Resources an Upgrade (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Our mission is to adapt our Simpy simulation model so that vidigi can track the usage of individual resource units. We need a way to: 1. Give each unit of a resource (like each nurse, simulator, or maybe each power loader Ripley might use) a unique ID. 2. Record this unique ID in our Event Log whenever an entity starts or stops using that specific resource unit.\nThis recorded ID (resource_id) is the crucial piece of information vidigi needs to make the animation show consistent resource use.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 4: More Input! Giving Your Resources an Upgrade (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#need-input-the-customresource",
    "href": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#need-input-the-customresource",
    "title": "Chapter 4: More Input! Giving Your Resources an Upgrade (CustomResource, Store, populate_store)",
    "section": "",
    "text": "The first piece of our upgrade kit is the CustomResource. It’s a very simple enhancement to the standard simpy.Resource. Think of it as taking a standard Cylon Centurion and welding a unique serial number onto its chassis.\nCustomResource is a class provided in vidigi.utils that inherits everything from simpy.Resource but adds one important thing: an id_attribute.\nHere’s a peek under the hood (you don’t usually need to write this yourself, just import it!):\n# Located in vidigi/utils.py (simplified)\nimport simpy\n\nclass CustomResource(simpy.Resource):\n    \"\"\"A custom resource with an ID.\"\"\"\n    def __init__(self, env, capacity, id_attribute=None):\n        # Call the original simpy.Resource setup\n        super().__init__(env, capacity)\n        # Add our special ID badge!\n        self.id_attribute = id_attribute\n\n    # Request and release methods are inherited, but could be customized\n    # (vidigi's default doesn't need to change them)\nSee? It’s mostly just a standard simpy.Resource, but it has that extra id_attribute ready to store a unique identifier, like ‘Nurse_1’ or ‘Sim_Bay_Alpha’. Number 5 is alive… and has an ID!",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 4: More Input! Giving Your Resources an Upgrade (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#storing-the-goods-simpy.store",
    "href": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#storing-the-goods-simpy.store",
    "title": "Chapter 4: More Input! Giving Your Resources an Upgrade (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Okay, we have resources with ID badges (CustomResource), but how do we manage a pool of them? If we have 3 nurses, we need a way to hold all 3 CustomResource instances. We can’t just use simpy.Resource(env, capacity=3) anymore, because that creates one resource object managing 3 anonymous slots.\nInstead, we use simpy.Store. A Store is like a magical container, maybe the Labyrinth’s oubliette, or the Ghostbusters’ Ecto-Containment Unit, or perhaps a vending machine that holds items. You can put items into the store and get items out.\nCrucially for us, we can put our individual CustomResource instances (each with its unique id_attribute) into the Store. When an entity needs a resource, it will yield store.get(), and Simpy will hand it one of the available CustomResource objects from the store.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 4: More Input! Giving Your Resources an Upgrade (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#the-easy-button-populate_store",
    "href": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#the-easy-button-populate_store",
    "title": "Chapter 4: More Input! Giving Your Resources an Upgrade (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Manually creating each CustomResource and putting it into the Store can be a bit repetitive, like programming the same patrol route for multiple ED-209s.\n# --- The Manual Way (Don't do this!) ---\nimport simpy\nfrom vidigi.utils import CustomResource\n\nenv = simpy.Environment()\nnum_nurses = 3\nnurse_store = simpy.Store(env)\n\n# Create and add Nurse 1\nnurse_1 = CustomResource(env, capacity=1, id_attribute='Nurse_1')\nnurse_store.put(nurse_1)\n\n# Create and add Nurse 2\nnurse_2 = CustomResource(env, capacity=1, id_attribute='Nurse_2')\nnurse_store.put(nurse_2)\n\n# Create and add Nurse 3\nnurse_3 = CustomResource(env, capacity=1, id_attribute='Nurse_3')\nnurse_store.put(nurse_3)\n\nprint(f\"Store now has {len(nurse_store.items)} nurses.\")\n# --- End Manual Way ---\nThat’s a bit much! To make this easier, vidigi provides a helper function: populate_store. It’s like calling Q branch – you tell it how many resources you need (num_resources), which store to put them in (simpy_store), and the simulation environment (sim_env), and it does the work for you!\nHere’s how to use it (this is the recommended way!):\nimport simpy\nfrom vidigi.utils import populate_store # Import the helper\n\nenv = simpy.Environment()\nnum_nurses = 3 # How many nurses we need\n\n# Create the empty store\nnurse_store = simpy.Store(env)\n\n# Use the helper to fill the store! Way easier!\npopulate_store(\n    num_resources=num_nurses,\n    simpy_store=nurse_store,\n    sim_env=env\n)\n\nprint(f\"Store now has {len(nurse_store.items)} nurses, created the easy way!\")\nMuch cleaner! populate_store automatically creates num_nurses instances of CustomResource, gives each one a unique id_attribute (1, 2, 3,…), and puts them into nurse_store. Ready for action!",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 4: More Input! Giving Your Resources an Upgrade (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#putting-it-all-together-modifying-your-simulation",
    "href": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#putting-it-all-together-modifying-your-simulation",
    "title": "Chapter 4: More Input! Giving Your Resources an Upgrade (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Now, let’s see how to use this pattern in a typical Simpy process function.\nScenario: A patient needs to see a nurse.\n1. Old Way (using simpy.Resource)\n# --- Before Vidigi Enhancement ---\nimport simpy\n\n# Assume g.n_nurses = 3, env exists\n# Assume nurses = simpy.Resource(env, capacity=g.n_nurses)\n# Assume event_log = [] exists\n\ndef patient_process_old(env, patient_id, nurses, event_log):\n    print(f\"{env.now}: Patient {patient_id} waiting for any nurse.\")\n    # Request ANY available nurse slot\n    with nurses.request() as req:\n        yield req\n        print(f\"{env.now}: Patient {patient_id} got a nurse (don't know which!).\")\n        # --- LOGGING PROBLEM: No specific resource_id ---\n        # event_log.append({'patient': patient_id, ..., 'resource_id': ???})\n\n        # Simulate treatment time\n        yield env.timeout(15) # 15 minutes treatment\n\n    print(f\"{env.now}: Patient {patient_id} finished with nurse.\")\n    # --- LOGGING PROBLEM: No specific resource_id ---\nIn this version, we don’t know which of the 3 nurse slots the patient used, so we can’t log a specific resource_id.\n2. New Way (using Store with CustomResource)\nFirst, set up the resource store (usually in your model’s __init__ or init_resources method):\n# --- Setting up the Store (e.g., in Model.__init__) ---\nimport simpy\nfrom vidigi.utils import populate_store\n\nclass YourModel:\n    def __init__(self, env, num_nurses):\n        self.env = env\n        self.nurse_store = simpy.Store(env)\n        populate_store(num_nurses, self.nurse_store, self.env)\n        # ... other setup ...\nNow, modify the process function to use the store and log the ID:\n# --- After Vidigi Enhancement ---\n# Assume model.nurse_store exists and was populated\n# Assume event_log = [] exists\n\ndef patient_process_new(env, patient_id, nurse_store, event_log):\n    print(f\"{env.now}: Patient {patient_id} waiting for a specific nurse.\")\n    # Request a SPECIFIC nurse instance from the store\n    nurse_resource = yield nurse_store.get() # Like getting a specific item\n\n    try:\n        # We got one! Access its unique ID badge\n        nurse_id = nurse_resource.id_attribute\n        print(f\"{env.now}: Patient {patient_id} got nurse {nurse_id}!\")\n\n        # --- LOGGING SUCCESS! ---\n        event_log.append({\n            'patient': patient_id, 'event_type': 'resource_use',\n            'event': 'start_nurse_visit', 'time': env.now,\n            'resource_id': nurse_id # &lt;--- Log the specific ID!\n        })\n\n        # Simulate treatment time\n        yield env.timeout(15) # 15 minutes treatment\n\n        print(f\"{env.now}: Patient {patient_id} finished with nurse {nurse_id}.\")\n        # --- LOGGING SUCCESS! ---\n        event_log.append({\n            'patient': patient_id, 'event_type': 'resource_use_end',\n            'event': 'end_nurse_visit', 'time': env.now,\n            'resource_id': nurse_id # &lt;--- Log the same ID!\n        })\n\n    finally:\n        # IMPORTANT: Put the specific nurse back in the store!\n        # Like returning your proton pack to the rack.\n        nurse_store.put(nurse_resource)\nKey changes: * We use yield nurse_store.get() instead of nurses.request(). * We get back a specific nurse_resource object (an instance of CustomResource). * We access its unique ID using nurse_resource.id_attribute. * We log this ID in the resource_id column of our Event Log for both resource_use and resource_use_end events. * Crucially, we use nurse_store.put(nurse_resource) to return the exact same nurse instance back to the pool when we’re done. (Using try...finally ensures it gets put back even if something goes wrong during treatment).\nThis pattern ensures our event log contains the specific resource_id, allowing vidigi to render the animation correctly!\nHere’s a visual summary of the interaction:\n\n\n\n\n\nsequenceDiagram\n    participant Entity as Patient Process\n    participant Store as simpy.Store (Nurse Store)\n    participant CR as CustomResource (Nurse_1)\n    participant Log as Event Log List\n\n    Entity-&gt;&gt;Store: yield store.get()\n    Store--&gt;&gt;CR: Selects available CustomResource (e.g., Nurse_1)\n    CR--&gt;&gt;Entity: Returns Nurse_1 instance\n    Entity-&gt;&gt;Log: Append 'resource_use' event (resource_id = Nurse_1.id_attribute)\n    Note over Entity: Use the resource (yield timeout)\n    Entity-&gt;&gt;Log: Append 'resource_use_end' event (resource_id = Nurse_1.id_attribute)\n    Entity-&gt;&gt;Store: store.put(Nurse_1)",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 4: More Input! Giving Your Resources an Upgrade (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#under-the-hood-no-need-for-a-flux-capacitor",
    "href": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#under-the-hood-no-need-for-a-flux-capacitor",
    "title": "Chapter 4: More Input! Giving Your Resources an Upgrade (CustomResource, Store, populate_store)",
    "section": "",
    "text": "How does this magic work? It’s actually quite straightforward, no 1.21 gigawatts required!\n\nCustomResource (vidigi/utils.py): As we saw, it’s just a standard simpy.Resource with an extra id_attribute added during initialization (__init__).\n# From vidigi/utils.py\nclass CustomResource(simpy.Resource):\n    def __init__(self, env, capacity, id_attribute=None):\n        super().__init__(env, capacity)\n        self.id_attribute = id_attribute # The only addition!\npopulate_store (vidigi/utils.py): This function simply runs a loop. For the number of resources requested, it creates a CustomResource instance (giving it i+1 as the id_attribute) and calls the store’s put method.\n# From vidigi/utils.py (Simplified)\ndef populate_store(num_resources, simpy_store, sim_env):\n    for i in range(num_resources):\n        # Create a resource with ID i+1 (so IDs start from 1)\n        resource_instance = CustomResource(\n            sim_env,\n            capacity=1, # Usually 1 for items in a store\n            id_attribute = i+1\n        )\n        # Put it in the store\n        simpy_store.put(resource_instance)\nLogging: Your simulation code is responsible for grabbing the .id_attribute from the resource instance obtained via store.get() and putting it into the resource_id column of your event log dictionary/DataFrame.\nAnimation Use: Later, when animate_activity_log runs, its helper function generate_animation_df reads your Event Log. When it sees a resource_use event, it uses the logged resource_id along with the base position from the Layout Configuration (event_position_df) to calculate the exact, consistent screen position for that entity using that specific resource instance (as explained conceptually in Chapter 3).\n\nThis simple pattern of adding an ID and using a Store is all it takes to give vidigi the information it needs!",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 4: More Input! Giving Your Resources an Upgrade (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#conclusion-resources-identified",
    "href": "autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html#conclusion-resources-identified",
    "title": "Chapter 4: More Input! Giving Your Resources an Upgrade (CustomResource, Store, populate_store)",
    "section": "",
    "text": "You’ve successfully navigated the resource enhancement quadrant! You now know why standard simpy.Resource isn’t enough for detailed animation tracking and how the CustomResource + simpy.Store + populate_store pattern solves this. It’s like giving every resource worker their own unique callsign – Maverick, Goose, Iceman – instead of just ‘Pilot’.\nBy using yield store.get(), logging the .id_attribute as resource_id, and using store.put(), you provide the crucial link vidigi needs to show entities consistently interacting with the same resource icon throughout the animation.\nWith our event logs (Chapter 2: Event Log) correctly recording events and specific resource IDs, and our layout (Chapter 3: Layout Configuration (event_position_df)) defined, we’re almost ready to make the animation movie. But first, vidigi needs to process that raw event log into a format suitable for animation frames – like taking snapshots of the action.\nLet’s jump in the DeLorean and head to the next chapter: Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df). Get ready to reshape time… I mean, data!\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 4: More Input! Giving Your Resources an Upgrade (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v3/02_event_log_.html",
    "href": "autodoc_v3/02_event_log_.html",
    "title": "Chapter 2: Log Everything! Like K.I.T.T.’s Mission Recorder",
    "section": "",
    "text": "Great Scott! In Chapter 1: Great Scott! Making Animations Easy with animate_activity_log, we met animate_activity_log, our trusty DeLorean control panel for creating process animations. We saw how it takes the key ingredients and produces a visual masterpiece. But what’s the most crucial ingredient? It’s the script, the minute-by-minute breakdown of the action – the Event Log.\nImagine trying to understand what K.I.T.T. did all day just by looking at his parking spot. Impossible! You need his internal logs, telling you when he scanned for trouble, when he deployed the smokescreen, and when he used Turbo Boost. That’s exactly what the Event Log does for vidigi.\n\n\nThink back to our clinic simulation. We need to tell vidigi precisely when each patient arrived, when they started waiting, when they began treatment (and with which nurse!), when they finished, and when they left. It’s like writing a detailed diary entry for every single patient (or maybe for every droid like R2-D2 on a mission).\nWithout this detailed log, animate_activity_log is like a director with no script – it doesn’t know what story to tell! The Event Log provides the raw sequence of events and times that vidigi needs to reconstruct the system’s dynamics visually.\n\n\n\nSo, what does this “diary” or “log file” look like? It’s simply a table, usually a pandas DataFrame, with specific columns that vidigi understands. Think of it as the standard report format requested by Devon Miles at FLAG.\nHere are the essential columns:\n\npatient: This is the unique identifier for the entity moving through the system. It could be a patient ID, a serial number for a component (like Johnny 5!), or even a callsign (like ‘Maverick’ or ‘Goose’). Each row in the log belongs to one specific patient.\nevent_type: This tells vidigi the kind of activity being recorded. It’s like classifying K.I.T.T.’s actions: ‘Scanning’, ‘Driving’, ‘Special Maneuver’. vidigi recognizes specific types:\n\narrival_departure: Marks when the entity enters or leaves the system. These are the opening and closing scenes!\nqueue: Indicates the entity has started waiting for something (like waiting for E.T. to phone home, or waiting for a treatment cubicle).\nresource_use: Signals that the entity has started using a specific resource (like a nurse seeing a patient, or Ripley getting into a specific Power Loader).\nresource_use_end: Signals that the entity has finished using that specific resource.\n\nevent: This is a more specific name for the event that occurred. You get to define most of these! Examples: ‘Arrival_Clinic’, ‘Wait_for_Nurse’, ‘Start_Treatment’, ‘End_Treatment’, ‘Depart_Clinic’.\n\nCrucial Note: For arrival_departure event types, vidigi specifically expects the event names to be exactly 'arrival' and 'depart'. Don’t get creative here, or the system won’t know when things start and end! Think of these as the fixed “Power On” and “Shutdown” commands.\n\ntime: This is the timestamp when the event occurred, measured in your simulation’s time units (e.g., minutes, hours, parsecs!). It’s the “when” for every “what”.\n\nBonus Column for Resources:\n\nresource_id (Required for resource_use and resource_use_end): When an entity uses a resource (like one of the Ghostbusters using a specific Proton Pack), we need to know which one. This column holds the unique ID of the specific resource unit being used or released. This is essential for tracking which specific nurse (Nurse Jackie 1, Nurse Jackie 2, etc.) is busy. We’ll talk more about how these IDs come from the Simpy Resource Enhancement (CustomResource, Store, populate_store).\n\n\n\n\nOkay, let’s build an Event Log for our Top Gun trainees, Maverick and Goose. We’ll use pandas, the go-to library for data tables in Python.\nFirst, make sure you have pandas imported:\nimport pandas as pd\nNow, let’s create the data as a list of dictionaries. Each dictionary represents one event (one row in our log):\n# Define the events for Maverick and Goose\nevent_data = [\n    # Maverick's Journey\n    {'patient': 'Maverick', 'event_type': 'arrival_departure', 'event': 'arrival', 'time': 0},\n    {'patient': 'Maverick', 'event_type': 'queue', 'event': 'wait_for_simulator', 'time': 1}, # Starts waiting\n    {'patient': 'Maverick', 'event_type': 'resource_use', 'event': 'start_simulator', 'time': 10, 'resource_id': 'Sim_1'}, # Got Simulator 1\n    {'patient': 'Maverick', 'event_type': 'resource_use_end', 'event': 'end_simulator', 'time': 50, 'resource_id': 'Sim_1'}, # Finished Sim 1\n    {'patient': 'Maverick', 'event_type': 'arrival_departure', 'event': 'depart', 'time': 55},\n\n    # Goose's Journey\n    {'patient': 'Goose', 'event_type': 'arrival_departure', 'event': 'arrival', 'time': 5},\n    {'patient': 'Goose', 'event_type': 'queue', 'event': 'wait_for_simulator', 'time': 6}, # Starts waiting\n    {'patient': 'Goose', 'event_type': 'resource_use', 'event': 'start_simulator', 'time': 15, 'resource_id': 'Sim_2'}, # Got Simulator 2\n    {'patient': 'Goose', 'event_type': 'resource_use_end', 'event': 'end_simulator', 'time': 65, 'resource_id': 'Sim_2'}, # Finished Sim 2\n    {'patient': 'Goose', 'event_type': 'arrival_departure', 'event': 'depart', 'time': 70}\n]\n\n# Convert the list of dictionaries into a pandas DataFrame\nevent_log_df = pd.DataFrame(event_data)\n\n# Let's see what we made! Print the first few rows.\nprint(\"Our Awesome Event Log:\")\nprint(event_log_df.head(10)) # Show first 10 rows\nThis code creates our list of event records and then uses pd.DataFrame() to turn it into the table format vidigi loves. We print the first 10 rows using .head(10) to check our work.\nNotice how: * Each row has the required columns (patient, event_type, event, time). * The resource_use and resource_use_end events also have resource_id (‘Sim_1’ or ‘Sim_2’). * The entry and exit points use the mandatory event names 'arrival' and 'depart' with the event_type ‘arrival_departure’. * Events are recorded chronologically per patient, but the overall log doesn’t strictly need to be sorted by time (though it often helps for readability). vidigi will figure out the sequence.\nThis event_log_df is exactly what you’d pass into the animate_activity_log function we learned about in Chapter 1!\n\n\n\nThe Event Log itself is just data – it’s like the script lying on the table. It doesn’t do anything on its own. Other parts of vidigi read this script to understand the plot.\nThe main consumer of the event_log is the reshape_for_animations function (which we’ll explore in detail later). Think of reshape_for_animations as the assistant director reading the script and figuring out who needs to be where for every single “snapshot” in time.\nHere’s a simplified idea of what happens when reshape_for_animations gets the event_log:\n\n\n\n\n\nsequenceDiagram\n    participant EL as Event Log (Data)\n    participant RFA as reshape_for_animations\n    participant Output as Snapshots (Who is where, when)\n\n    RFA-&gt;&gt;EL: Read all event records\n    Note over RFA: For each time point (e.g., every minute):\n    RFA-&gt;&gt;EL: Find events that happened *before* this time point for each patient\n    RFA-&gt;&gt;EL: Identify the *most recent* event for each patient still in the system\n    RFA--&gt;&gt;Output: Record patient's current state (event name) at this time point\n\n\n\n\n\n\nEssentially, reshape_for_animations scans through time. At each step (say, every minute), it looks at the event_log to determine the last thing each active patient did. This tells it whether Maverick is currently ‘waiting_for_simulator’ or ‘start_simulator’ at that specific minute.\nInternally (looking at vidigi/prep.py), reshape_for_animations might do things like:\n# --- Inside reshape_for_animations (Simplified Concept) ---\n# (Input: event_log_df)\n\n# Pivot the log to easily find start/end times (like 'arrival', 'depart')\npivoted_log = event_log_df.pivot_table(...)\n\n# Loop through time points (e.g., minute 0, 1, 2...)\nfor minute in range(simulation_duration):\n    # Find patients who arrived before 'minute' and haven't departed yet\n    active_patients = find_active_patients(pivoted_log, minute)\n\n    # Filter the original log for these active patients up to 'minute'\n    relevant_events = event_log_df[\n        (event_log_df['patient'].isin(active_patients)) &\n        (event_log_df['time'] &lt;= minute)\n    ]\n\n    # For each active patient, find their *very last* event in relevant_events\n    latest_states = relevant_events.sort_values('time').groupby('patient').tail(1)\n\n    # Store these latest states as the snapshot for 'minute'\n    # ... add to list of snapshots ...\n\n# (Output: A DataFrame where each row is a patient's state at a specific minute)\nThis process transforms the sequential, event-based log into a state-based log, telling us where everyone is at every moment needed for the animation frames.\n\n\n\nYou’ve now mastered the concept of the Event Log – the vital, detailed diary that fuels vidigi’s visualizations. It’s the raw data stream, the script detailing every significant moment for every entity, captured with specific columns like patient, event_type, event, time, and sometimes resource_id. Without a good Event Log, our animation DeLorean can’t even reach 88 miles per hour!\nYou learned the required structure and how to create a basic one using pandas. This log is the fundamental input passed to animate_activity_log, which then uses helpers like reshape_for_animations to process it.\nBut knowing what happened and when isn’t the whole story. We also need to tell vidigi where on the screen these events should take place. How do we map ‘wait_for_simulator’ or ‘start_simulator’ to actual coordinates? That’s the job of the Layout Configuration!\nEngage! Let’s warp to Chapter 3: Layout Configuration (event_position_df).\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 2: Log Everything! Like K.I.T.T.'s Mission Recorder"
    ]
  },
  {
    "objectID": "autodoc_v3/02_event_log_.html#the-mission-recording-the-action",
    "href": "autodoc_v3/02_event_log_.html#the-mission-recording-the-action",
    "title": "Chapter 2: Log Everything! Like K.I.T.T.’s Mission Recorder",
    "section": "",
    "text": "Think back to our clinic simulation. We need to tell vidigi precisely when each patient arrived, when they started waiting, when they began treatment (and with which nurse!), when they finished, and when they left. It’s like writing a detailed diary entry for every single patient (or maybe for every droid like R2-D2 on a mission).\nWithout this detailed log, animate_activity_log is like a director with no script – it doesn’t know what story to tell! The Event Log provides the raw sequence of events and times that vidigi needs to reconstruct the system’s dynamics visually.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 2: Log Everything! Like K.I.T.T.'s Mission Recorder"
    ]
  },
  {
    "objectID": "autodoc_v3/02_event_log_.html#the-blueprint-anatomy-of-an-event-log",
    "href": "autodoc_v3/02_event_log_.html#the-blueprint-anatomy-of-an-event-log",
    "title": "Chapter 2: Log Everything! Like K.I.T.T.’s Mission Recorder",
    "section": "",
    "text": "So, what does this “diary” or “log file” look like? It’s simply a table, usually a pandas DataFrame, with specific columns that vidigi understands. Think of it as the standard report format requested by Devon Miles at FLAG.\nHere are the essential columns:\n\npatient: This is the unique identifier for the entity moving through the system. It could be a patient ID, a serial number for a component (like Johnny 5!), or even a callsign (like ‘Maverick’ or ‘Goose’). Each row in the log belongs to one specific patient.\nevent_type: This tells vidigi the kind of activity being recorded. It’s like classifying K.I.T.T.’s actions: ‘Scanning’, ‘Driving’, ‘Special Maneuver’. vidigi recognizes specific types:\n\narrival_departure: Marks when the entity enters or leaves the system. These are the opening and closing scenes!\nqueue: Indicates the entity has started waiting for something (like waiting for E.T. to phone home, or waiting for a treatment cubicle).\nresource_use: Signals that the entity has started using a specific resource (like a nurse seeing a patient, or Ripley getting into a specific Power Loader).\nresource_use_end: Signals that the entity has finished using that specific resource.\n\nevent: This is a more specific name for the event that occurred. You get to define most of these! Examples: ‘Arrival_Clinic’, ‘Wait_for_Nurse’, ‘Start_Treatment’, ‘End_Treatment’, ‘Depart_Clinic’.\n\nCrucial Note: For arrival_departure event types, vidigi specifically expects the event names to be exactly 'arrival' and 'depart'. Don’t get creative here, or the system won’t know when things start and end! Think of these as the fixed “Power On” and “Shutdown” commands.\n\ntime: This is the timestamp when the event occurred, measured in your simulation’s time units (e.g., minutes, hours, parsecs!). It’s the “when” for every “what”.\n\nBonus Column for Resources:\n\nresource_id (Required for resource_use and resource_use_end): When an entity uses a resource (like one of the Ghostbusters using a specific Proton Pack), we need to know which one. This column holds the unique ID of the specific resource unit being used or released. This is essential for tracking which specific nurse (Nurse Jackie 1, Nurse Jackie 2, etc.) is busy. We’ll talk more about how these IDs come from the Simpy Resource Enhancement (CustomResource, Store, populate_store).",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 2: Log Everything! Like K.I.T.T.'s Mission Recorder"
    ]
  },
  {
    "objectID": "autodoc_v3/02_event_log_.html#creating-your-own-log-lets-get-coding",
    "href": "autodoc_v3/02_event_log_.html#creating-your-own-log-lets-get-coding",
    "title": "Chapter 2: Log Everything! Like K.I.T.T.’s Mission Recorder",
    "section": "",
    "text": "Okay, let’s build an Event Log for our Top Gun trainees, Maverick and Goose. We’ll use pandas, the go-to library for data tables in Python.\nFirst, make sure you have pandas imported:\nimport pandas as pd\nNow, let’s create the data as a list of dictionaries. Each dictionary represents one event (one row in our log):\n# Define the events for Maverick and Goose\nevent_data = [\n    # Maverick's Journey\n    {'patient': 'Maverick', 'event_type': 'arrival_departure', 'event': 'arrival', 'time': 0},\n    {'patient': 'Maverick', 'event_type': 'queue', 'event': 'wait_for_simulator', 'time': 1}, # Starts waiting\n    {'patient': 'Maverick', 'event_type': 'resource_use', 'event': 'start_simulator', 'time': 10, 'resource_id': 'Sim_1'}, # Got Simulator 1\n    {'patient': 'Maverick', 'event_type': 'resource_use_end', 'event': 'end_simulator', 'time': 50, 'resource_id': 'Sim_1'}, # Finished Sim 1\n    {'patient': 'Maverick', 'event_type': 'arrival_departure', 'event': 'depart', 'time': 55},\n\n    # Goose's Journey\n    {'patient': 'Goose', 'event_type': 'arrival_departure', 'event': 'arrival', 'time': 5},\n    {'patient': 'Goose', 'event_type': 'queue', 'event': 'wait_for_simulator', 'time': 6}, # Starts waiting\n    {'patient': 'Goose', 'event_type': 'resource_use', 'event': 'start_simulator', 'time': 15, 'resource_id': 'Sim_2'}, # Got Simulator 2\n    {'patient': 'Goose', 'event_type': 'resource_use_end', 'event': 'end_simulator', 'time': 65, 'resource_id': 'Sim_2'}, # Finished Sim 2\n    {'patient': 'Goose', 'event_type': 'arrival_departure', 'event': 'depart', 'time': 70}\n]\n\n# Convert the list of dictionaries into a pandas DataFrame\nevent_log_df = pd.DataFrame(event_data)\n\n# Let's see what we made! Print the first few rows.\nprint(\"Our Awesome Event Log:\")\nprint(event_log_df.head(10)) # Show first 10 rows\nThis code creates our list of event records and then uses pd.DataFrame() to turn it into the table format vidigi loves. We print the first 10 rows using .head(10) to check our work.\nNotice how: * Each row has the required columns (patient, event_type, event, time). * The resource_use and resource_use_end events also have resource_id (‘Sim_1’ or ‘Sim_2’). * The entry and exit points use the mandatory event names 'arrival' and 'depart' with the event_type ‘arrival_departure’. * Events are recorded chronologically per patient, but the overall log doesn’t strictly need to be sorted by time (though it often helps for readability). vidigi will figure out the sequence.\nThis event_log_df is exactly what you’d pass into the animate_activity_log function we learned about in Chapter 1!",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 2: Log Everything! Like K.I.T.T.'s Mission Recorder"
    ]
  },
  {
    "objectID": "autodoc_v3/02_event_log_.html#under-the-hood-how-vidigi-uses-the-log",
    "href": "autodoc_v3/02_event_log_.html#under-the-hood-how-vidigi-uses-the-log",
    "title": "Chapter 2: Log Everything! Like K.I.T.T.’s Mission Recorder",
    "section": "",
    "text": "The Event Log itself is just data – it’s like the script lying on the table. It doesn’t do anything on its own. Other parts of vidigi read this script to understand the plot.\nThe main consumer of the event_log is the reshape_for_animations function (which we’ll explore in detail later). Think of reshape_for_animations as the assistant director reading the script and figuring out who needs to be where for every single “snapshot” in time.\nHere’s a simplified idea of what happens when reshape_for_animations gets the event_log:\n\n\n\n\n\nsequenceDiagram\n    participant EL as Event Log (Data)\n    participant RFA as reshape_for_animations\n    participant Output as Snapshots (Who is where, when)\n\n    RFA-&gt;&gt;EL: Read all event records\n    Note over RFA: For each time point (e.g., every minute):\n    RFA-&gt;&gt;EL: Find events that happened *before* this time point for each patient\n    RFA-&gt;&gt;EL: Identify the *most recent* event for each patient still in the system\n    RFA--&gt;&gt;Output: Record patient's current state (event name) at this time point\n\n\n\n\n\n\nEssentially, reshape_for_animations scans through time. At each step (say, every minute), it looks at the event_log to determine the last thing each active patient did. This tells it whether Maverick is currently ‘waiting_for_simulator’ or ‘start_simulator’ at that specific minute.\nInternally (looking at vidigi/prep.py), reshape_for_animations might do things like:\n# --- Inside reshape_for_animations (Simplified Concept) ---\n# (Input: event_log_df)\n\n# Pivot the log to easily find start/end times (like 'arrival', 'depart')\npivoted_log = event_log_df.pivot_table(...)\n\n# Loop through time points (e.g., minute 0, 1, 2...)\nfor minute in range(simulation_duration):\n    # Find patients who arrived before 'minute' and haven't departed yet\n    active_patients = find_active_patients(pivoted_log, minute)\n\n    # Filter the original log for these active patients up to 'minute'\n    relevant_events = event_log_df[\n        (event_log_df['patient'].isin(active_patients)) &\n        (event_log_df['time'] &lt;= minute)\n    ]\n\n    # For each active patient, find their *very last* event in relevant_events\n    latest_states = relevant_events.sort_values('time').groupby('patient').tail(1)\n\n    # Store these latest states as the snapshot for 'minute'\n    # ... add to list of snapshots ...\n\n# (Output: A DataFrame where each row is a patient's state at a specific minute)\nThis process transforms the sequential, event-based log into a state-based log, telling us where everyone is at every moment needed for the animation frames.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 2: Log Everything! Like K.I.T.T.'s Mission Recorder"
    ]
  },
  {
    "objectID": "autodoc_v3/02_event_log_.html#conclusion-fueling-the-flux-capacitor",
    "href": "autodoc_v3/02_event_log_.html#conclusion-fueling-the-flux-capacitor",
    "title": "Chapter 2: Log Everything! Like K.I.T.T.’s Mission Recorder",
    "section": "",
    "text": "You’ve now mastered the concept of the Event Log – the vital, detailed diary that fuels vidigi’s visualizations. It’s the raw data stream, the script detailing every significant moment for every entity, captured with specific columns like patient, event_type, event, time, and sometimes resource_id. Without a good Event Log, our animation DeLorean can’t even reach 88 miles per hour!\nYou learned the required structure and how to create a basic one using pandas. This log is the fundamental input passed to animate_activity_log, which then uses helpers like reshape_for_animations to process it.\nBut knowing what happened and when isn’t the whole story. We also need to tell vidigi where on the screen these events should take place. How do we map ‘wait_for_simulator’ or ‘start_simulator’ to actual coordinates? That’s the job of the Layout Configuration!\nEngage! Let’s warp to Chapter 3: Layout Configuration (event_position_df).\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 2: Log Everything! Like K.I.T.T.'s Mission Recorder"
    ]
  },
  {
    "objectID": "autodoc_v2/index.html",
    "href": "autodoc_v2/index.html",
    "title": "Tutorial: vidigi",
    "section": "",
    "text": "vidigi helps you visualize the output of discrete event simulations, especially those built with the Simpy library. It takes a detailed Event Log (tracking entities like patients through stages) and transforms it into an animated scatter plot using Plotly. This allows users to visually validate model logic and understand system dynamics like queues and resource usage over time. Key components handle preparing data into snapshots, generating the animation, configuring the visual layout, and enhancing Simpy resources for better tracking.\nSource Repository: https://github.com/Bergam0t/vidigi\n\n\n\n\n\nflowchart TD\n    A0[\"Event Log\"]\n    A1[\"Snapshot Preparation - reshape_for_animations & generate_animation_df\"]\n    A2[\"Animation Generation - generate_animation\"]\n    A3[\"Layout Configuration - event_position_df\"]\n    A4[\"Simpy Resource Enhancement - CustomResource, Store, populate_store\"]\n    A5[\"Animation Facade - animate_activity_log\"]\n    A0 -- \"Provides data for\" --&gt; A1\n    A0 -- \"Is input to\" --&gt; A5\n    A1 -- \"Provides data for\" --&gt; A2\n    A3 -- \"Defines positions for\" --&gt; A1\n    A3 -- \"Defines layout for\" --&gt; A2\n    A3 -- \"Is input to\" --&gt; A5\n    A4 -- \"Enables resource ID logging in\" --&gt; A0\n    A4 -- \"Provides resource info to\" --&gt; A2\n    A5 -- \"Calls\" --&gt; A1\n    A5 -- \"Calls\" --&gt; A2\n\n\n\n\n\n\n\n\n\nAnimation Facade (animate_activity_log)\nEvent Log\nLayout Configuration (event_position_df)\nSimpy Resource Enhancement (CustomResource, Store, populate_store)\nSnapshot Preparation (reshape_for_animations & generate_animation_df)\nAnimation Generation (generate_animation)\n\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Tutorial: vidigi"
    ]
  },
  {
    "objectID": "autodoc_v2/index.html#chapters",
    "href": "autodoc_v2/index.html#chapters",
    "title": "Tutorial: vidigi",
    "section": "",
    "text": "Animation Facade (animate_activity_log)\nEvent Log\nLayout Configuration (event_position_df)\nSimpy Resource Enhancement (CustomResource, Store, populate_store)\nSnapshot Preparation (reshape_for_animations & generate_animation_df)\nAnimation Generation (generate_animation)\n\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Tutorial: vidigi"
    ]
  },
  {
    "objectID": "autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html",
    "href": "autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "In Chapter 4: Simpy Resource Enhancement, we saw how to modify a simpy model using CustomResource and simpy.Store to log the specific resource_id used by each entity. This detailed tracking is crucial for accurate visualisation. Now, we move on to the next stage: transforming the raw simulation output (the Event Log) into a format suitable for creating the animation frames.\n\n\nThink back to the Event Log. It’s like a detailed diary, recording every significant event (arrival, start queue, start treatment, departure) for each entity precisely when it happened. This is great for analysis, but for an animation, we need something different. An animation is like a film reel – a sequence of static images (frames or snapshots) shown in quick succession. Each frame needs to show the position of every entity visible at that specific moment in time.\nOur raw event_log tells us when Patient 5 started treatment, but it doesn’t directly tell us where Patient 5 was at exactly 10:30 AM, or who else was in the clinic at that time and where they were. We need a process to convert the event-driven diary into a time-sliced film reel.\nThis conversion is the core task of the snapshot preparation stage, handled primarily by two functions: reshape_for_animations and generate_animation_df.\n\n\n\nThe transformation happens in two main steps, orchestrated behind the scenes by the main Animation Facade (animate_activity_log):\n\nreshape_for_animations (Time Slicing): This function takes the raw event_log and slices simulation time into regular intervals (e.g., every 1 minute, every 10 minutes, controlled by the every_x_time_units parameter). For each time slice, it determines the state (i.e., the last recorded event, like ‘wait_nurse’ or ‘use_nurse’) of every entity currently active in the system. It effectively answers the question: “At time T, who was doing what?” It also calculates the rank of entities within the same state (e.g., position in a queue).\ngenerate_animation_df (Position Calculation): This function takes the output from reshape_for_animations (which tells us who is doing what at each time slice) and combines it with the layout information from the Layout Configuration (event_position_df). Its job is to calculate the exact x_final and y_final coordinates for every entity in every time slice. It handles the logic for arranging entities in queues (potentially wrapping them) and placing entities using specific resources based on their resource_id. It answers: “Given who is doing what at time T, and the layout map, where exactly should each entity be placed on the screen?”\n\nThe overall flow looks like this:\n\n\n\n\n\ngraph LR\n    A[Raw `event_log` DataFrame &lt;br&gt;(From Chapter 2)] --&gt; B(reshape_for_animations);\n    B -- every_x_time_units --&gt; C[Snapshot DataFrame &lt;br&gt;(`full_patient_df`) &lt;br&gt; Columns: patient, minute, event, event_type, rank, resource_id...];\n    C --&gt; D(generate_animation_df);\n    E[Layout `event_position_df` DataFrame &lt;br&gt;(From Chapter 3)] --&gt; D;\n    F[Layout Params &lt;br&gt;(wrap_queues_at, gaps...)] --&gt; D;\n    D --&gt; G[Positioned Snapshot DataFrame &lt;br&gt;(`full_patient_df_plus_pos`) &lt;br&gt; Columns: patient, minute, event, icon, x_final, y_final...];\n    G --&gt; H[Animation Generation &lt;br&gt;(generate_animation) &lt;br&gt;(Chapter 6)];\n\n\n\n\n\n\nLet’s delve into how each function works.\n\n\n\nThe primary goal of reshape_for_animations is to convert the sparse, event-driven log into a dense, time-step-based representation.\nPurpose: To determine the state (most recent event) and rank (e.g., queue position) of every active entity at regular time intervals.\nInputs: * event_log: The raw DataFrame as described in Chapter 2: Event Log. * every_x_time_units: The gap between consecutive time snapshots (e.g., 1 for every minute, 10 for every 10 minutes). * limit_duration: The maximum simulation time to process. * step_snapshot_max: Limits how many entities are processed per event type in a single snapshot (for performance with very large queues).\nProcess (Conceptual):\n\nPivot (Optional but helpful): The code often starts by pivoting the event_log slightly to easily access arrival and departure times per patient.\nIterate Through Time: Loop through simulation time from 0 up to limit_duration, taking steps of size every_x_time_units. Let the current time step be minute.\nIdentify Active Entities: For the current minute, find all patient identifiers that have arrival time &lt;= minute AND (depart time &gt;= minute OR depart time is missing/null). These are the entities currently “in the system”.\nFind Latest State: Filter the original event_log to include only events for these active entities that occurred at or before the current minute. For each active entity, find their very last event in this filtered set (using groupby('patient').tail(1) after sorting by time). This last event represents the entity’s state (e.g., ‘wait_nurse’, ‘use_nurse’) at this specific minute.\nRank Entities: Within each event category at the current minute, rank the entities based on when they entered that state (often approximated by the original event log’s index or time). This gives us the rank column, crucial for queue ordering.\nLimit Snapshot Size: Apply the step_snapshot_max limit if needed.\nStore Snapshot: Store the details (patient, event, event_type, resource_id, rank, original event time, current snapshot minute) for this time step.\nConcatenate: After looping through all time steps, combine the stored snapshots into a single large DataFrame (full_patient_df).\nAdd Exit State: Append a final ‘exit’ event for each patient one time step after their last recorded event. This ensures entities visibly leave the animation area rather than just vanishing.\n\nOutput (full_patient_df): A DataFrame where each row represents a specific entity (patient) in a specific state (event, event_type, potentially using resource_id) at a specific snapshot time (minute), along with their rank within that state at that time.\nCode Glimpse:\nHere’s a simplified view of the core logic inside vidigi.prep.reshape_for_animations:\n# From: vidigi/prep.py (Simplified)\n\ndef reshape_for_animations(event_log,\n                           every_x_time_units=10,\n                           limit_duration=14400, # e.g., 10 days in minutes\n                           step_snapshot_max=50,\n                           debug_mode=False):\n\n    patient_dfs = [] # To store snapshots for each minute\n\n    # 1. Pivot helps find arrival/departure easily (simplified view)\n    pivoted_log = event_log.pivot_table(values=\"time\", index=\"patient\",\n                                        columns=\"event\",\n                                        aggfunc='first') # Simplified pivot\n\n    # 2. Iterate Through Time\n    for minute in range(0, limit_duration, every_x_time_units):\n\n        # 3. Identify Active Entities\n        active_patients_mask = (pivoted_log['arrival'] &lt;= minute) & \\\n                               ((pivoted_log['depart'] &gt;= minute) | pd.isnull(pivoted_log['depart']))\n        current_patients_in_moment = pivoted_log[active_patients_mask].index\n\n        if not current_patients_in_moment.empty:\n            # 4. Find Latest State for active patients up to this minute\n            patient_minute_df = event_log[\n                (event_log['patient'].isin(current_patients_in_moment)) &\n                (event_log['time'] &lt;= minute)\n            ].copy() # Filter original log\n\n            # Sort by time, then use groupby().tail(1) to get the latest event per patient\n            patient_minute_df = patient_minute_df.sort_values(['time', 'index']) # Assuming 'index' preserves original order\n            most_recent_events = patient_minute_df.groupby('patient').tail(1)\n\n            # 5. Rank Entities within each event group\n            most_recent_events['rank'] = most_recent_events.groupby('event')['time'] \\\n                                        .rank(method='first', ascending=True)\n\n            # 6. Limit Snapshot Size (simplified)\n            most_recent_events = most_recent_events.groupby('event').head(step_snapshot_max)\n\n            # 7. Store Snapshot (adding the current minute)\n            patient_dfs.append(most_recent_events.assign(minute=minute))\n\n    # 8. Concatenate all snapshots\n    full_patient_df = pd.concat(patient_dfs, ignore_index=True) if patient_dfs else pd.DataFrame()\n\n    # 9. Add Exit State (simplified logic)\n    if not full_patient_df.empty:\n        final_step = full_patient_df.loc[full_patient_df.groupby('patient')['minute'].idxmax()]\n        final_step = final_step.copy()\n        final_step['minute'] = final_step['minute'] + every_x_time_units\n        final_step['event'] = \"exit\"\n        final_step['event_type'] = \"arrival_departure\" # Consistent type needed\n        full_patient_df = pd.concat([full_patient_df, final_step], ignore_index=True)\n\n    return full_patient_df.sort_values([\"minute\", \"event\"]).reset_index(drop=True)\nThis function takes the raw event stream and effectively samples the state of the system at regular intervals, preparing the ground for spatial layout.\n\n\n\nNow that we know who is doing what at each time slice (minute), generate_animation_df figures out exactly where they should be drawn.\nPurpose: To calculate the final X and Y coordinates (x_final, y_final) for each entity in each snapshot, based on their state, rank/resource ID, and the defined layout.\nInputs: * full_patient_df: The DataFrame output by reshape_for_animations. * event_position_df: The layout DataFrame from Chapter 3: Layout Configuration. * Layout parameters: wrap_queues_at, wrap_resources_at, gap_between_entities, gap_between_resources, gap_between_rows. * custom_entity_icon_list: Optional list of emojis/icons to use for entities.\nProcess (Conceptual):\n\nMerge Layout: Join full_patient_df with event_position_df on the event column. This brings the base x and y coordinates for each entity’s current state into the main DataFrame.\nSplit by Event Type: Conceptually (or literally in the code), separate the rows based on event_type because positioning logic differs:\n\nQueues (event_type == 'queue'):\n\nStart with the base x, y from the layout.\nCalculate x_final: Typically subtract rank * gap_between_entities from the base x (queues usually extend leftwards).\nCalculate y_final: Initially the base y.\nHandle Wrapping: If wrap_queues_at is set, use the rank and wrap_queues_at to determine the row number (row = floor((rank - 1) / wrap_queues_at)). Adjust x_final (resetting based on position within the row) and y_final (adding row * gap_between_rows).\n\nResource Use (event_type == 'resource_use'):\n\nStart with the base x, y.\nRequires the resource_id column populated as per Chapter 4.\nCalculate x_final: Typically subtract resource_id * gap_between_resources from the base x.\nCalculate y_final: Initially the base y.\nHandle Wrapping: Similar to queues, but using resource_id and wrap_resources_at. Adjust x_final and y_final based on the resource row.\n\nOther Events (e.g., arrival, exit, custom non-queue/resource steps):\n\nUsually, x_final and y_final are simply set to the base x and y from the layout.\n\n\nCombine Back: Concatenate the processed subsets back into a single DataFrame.\nAssign Icons: Generate a mapping from unique patient identifiers to icons (e.g., emojis from the default list or custom_entity_icon_list). Add an icon column to the DataFrame.\nHandle Snapshot Limit Visuals: If step_snapshot_max was applied in reshape_for_animations, this function might modify the icon/text for the last displayed entity in a truncated queue/resource group to indicate that more entities exist but aren’t shown (e.g., displaying “+ 5 more”).\n\nOutput (full_patient_df_plus_pos): The final DataFrame ready for plotting. Contains patient, minute, event, icon, and the crucial x_final, y_final coordinates, along with other potentially useful columns.\nCode Glimpse:\nHere’s a simplified look at the positioning logic within vidigi.prep.generate_animation_df:\n# From: vidigi/prep.py (Simplified)\nimport numpy as np\nimport pandas as pd\n\ndef generate_animation_df(\n        full_patient_df,\n        event_position_df,\n        wrap_queues_at=20,\n        wrap_resources_at=20,\n        gap_between_entities=10,\n        gap_between_resources=10,\n        gap_between_rows=30,\n        # ... other params ...\n        custom_entity_icon_list=None\n):\n\n    # 1. Merge Layout info (base x, y)\n    # Assumes 'rank' column already exists from reshape_for_animations\n    df_plus_pos = full_patient_df.merge(event_position_df[['event', 'x', 'y']],\n                                        on=\"event\", how='left')\n\n    # --- 2. Split and Calculate Positions ---\n    # Handle Queues\n    queues = df_plus_pos[df_plus_pos['event_type'] == 'queue'].copy()\n    if not queues.empty:\n        queues['x_final'] = queues['x'] - queues['rank'] * gap_between_entities\n        queues['y_final'] = queues['y']\n        if wrap_queues_at is not None:\n            queues['row'] = np.floor((queues['rank'] - 1) / wrap_queues_at)\n            # Adjust x based on position in the row\n            queues['x_final'] += (wrap_queues_at * queues['row'] * gap_between_entities) + gap_between_entities\n            # Adjust y based on the row\n            queues['y_final'] += queues['row'] * gap_between_rows\n\n    # Handle Resource Use\n    resources = df_plus_pos[df_plus_pos['event_type'] == 'resource_use'].copy()\n    if not resources.empty:\n        # Assumes 'resource_id' column exists and is numeric (1-based)\n        resources['x_final'] = resources['x'] - resources['resource_id'] * gap_between_resources\n        resources['y_final'] = resources['y']\n        if wrap_resources_at is not None:\n            resources['row'] = np.floor((resources['resource_id'] - 1) / wrap_resources_at)\n            # Adjust x based on position in the row\n            resources['x_final'] += (wrap_resources_at * resources['row'] * gap_between_resources) + gap_between_resources\n            # Adjust y based on the row\n            resources['y_final'] += resources['row'] * gap_between_rows\n\n    # Handle Other events (simplified - assume they just use base x, y)\n    others = df_plus_pos[~df_plus_pos['event_type'].isin(['queue', 'resource_use'])].copy()\n    if not others.empty:\n        others['x_final'] = others['x']\n        others['y_final'] = others['y']\n\n    # 3. Combine Back\n    final_df_parts = [part for part in [queues, resources, others] if not part.empty]\n    final_df = pd.concat(final_df_parts, ignore_index=True) if final_df_parts else pd.DataFrame()\n\n    # 4. Assign Icons (simplified)\n    if not final_df.empty:\n        unique_patients = final_df['patient'].unique()\n        # Default icon list or custom list\n        icon_list = custom_entity_icon_list or get_default_icon_list()\n        icon_map = {patient: icon_list[i % len(icon_list)] for i, patient in enumerate(unique_patients)}\n        final_df['icon'] = final_df['patient'].map(icon_map)\n\n        # 5. Handle Snapshot Limit Visuals (logic omitted for brevity)\n        # ... code to potentially modify 'icon' for truncated groups ...\n\n    return final_df.sort_values(['minute', 'patient']) # Return sorted\n\n# Helper function (conceptual)\ndef get_default_icon_list():\n    return ['🧔🏼', '👨🏿‍🦯', '👨🏻‍🦰', '🧑🏻', '👩🏿‍🦱', '🤰', '👳🏽', '👩🏼‍🦳', '👨🏿‍🦳', '👩🏼‍🦱', ...] # A long list of emojis\nThis function takes the time-sliced data and applies the spatial rules defined by the layout, producing the exact coordinates needed frame-by-frame.\n\n\n\nThe snapshot preparation stage, comprising reshape_for_animations and generate_animation_df, is the crucial data transformation engine within vidigi. It bridges the gap between the raw, event-based simulation output (event_log) and the frame-by-frame requirements of an animation.\nreshape_for_animations processes the event log to determine who is doing what at regular time intervals, creating time slices. generate_animation_df then takes these time slices and the layout configuration (event_position_df) to calculate the precise X/Y coordinates for each entity in each slice, handling queue formation and resource allocation visually.\nThe result is a comprehensive DataFrame (full_patient_df_plus_pos) containing everything needed to draw each frame: the entity identifier, the time snapshot, the assigned icon, and the final x_final, y_final position.\nWith this meticulously prepared data, we are finally ready to generate the animation itself using Plotly.\nNext: Chapter 6: Animation Generation (generate_animation)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#motivation-from-diary-to-film-reel",
    "href": "autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#motivation-from-diary-to-film-reel",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Think back to the Event Log. It’s like a detailed diary, recording every significant event (arrival, start queue, start treatment, departure) for each entity precisely when it happened. This is great for analysis, but for an animation, we need something different. An animation is like a film reel – a sequence of static images (frames or snapshots) shown in quick succession. Each frame needs to show the position of every entity visible at that specific moment in time.\nOur raw event_log tells us when Patient 5 started treatment, but it doesn’t directly tell us where Patient 5 was at exactly 10:30 AM, or who else was in the clinic at that time and where they were. We need a process to convert the event-driven diary into a time-sliced film reel.\nThis conversion is the core task of the snapshot preparation stage, handled primarily by two functions: reshape_for_animations and generate_animation_df.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#key-concepts-slicing-time-and-placing-pieces",
    "href": "autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#key-concepts-slicing-time-and-placing-pieces",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "The transformation happens in two main steps, orchestrated behind the scenes by the main Animation Facade (animate_activity_log):\n\nreshape_for_animations (Time Slicing): This function takes the raw event_log and slices simulation time into regular intervals (e.g., every 1 minute, every 10 minutes, controlled by the every_x_time_units parameter). For each time slice, it determines the state (i.e., the last recorded event, like ‘wait_nurse’ or ‘use_nurse’) of every entity currently active in the system. It effectively answers the question: “At time T, who was doing what?” It also calculates the rank of entities within the same state (e.g., position in a queue).\ngenerate_animation_df (Position Calculation): This function takes the output from reshape_for_animations (which tells us who is doing what at each time slice) and combines it with the layout information from the Layout Configuration (event_position_df). Its job is to calculate the exact x_final and y_final coordinates for every entity in every time slice. It handles the logic for arranging entities in queues (potentially wrapping them) and placing entities using specific resources based on their resource_id. It answers: “Given who is doing what at time T, and the layout map, where exactly should each entity be placed on the screen?”\n\nThe overall flow looks like this:\n\n\n\n\n\ngraph LR\n    A[Raw `event_log` DataFrame &lt;br&gt;(From Chapter 2)] --&gt; B(reshape_for_animations);\n    B -- every_x_time_units --&gt; C[Snapshot DataFrame &lt;br&gt;(`full_patient_df`) &lt;br&gt; Columns: patient, minute, event, event_type, rank, resource_id...];\n    C --&gt; D(generate_animation_df);\n    E[Layout `event_position_df` DataFrame &lt;br&gt;(From Chapter 3)] --&gt; D;\n    F[Layout Params &lt;br&gt;(wrap_queues_at, gaps...)] --&gt; D;\n    D --&gt; G[Positioned Snapshot DataFrame &lt;br&gt;(`full_patient_df_plus_pos`) &lt;br&gt; Columns: patient, minute, event, icon, x_final, y_final...];\n    G --&gt; H[Animation Generation &lt;br&gt;(generate_animation) &lt;br&gt;(Chapter 6)];\n\n\n\n\n\n\nLet’s delve into how each function works.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#time-slicing-with-reshape_for_animations",
    "href": "autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#time-slicing-with-reshape_for_animations",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "The primary goal of reshape_for_animations is to convert the sparse, event-driven log into a dense, time-step-based representation.\nPurpose: To determine the state (most recent event) and rank (e.g., queue position) of every active entity at regular time intervals.\nInputs: * event_log: The raw DataFrame as described in Chapter 2: Event Log. * every_x_time_units: The gap between consecutive time snapshots (e.g., 1 for every minute, 10 for every 10 minutes). * limit_duration: The maximum simulation time to process. * step_snapshot_max: Limits how many entities are processed per event type in a single snapshot (for performance with very large queues).\nProcess (Conceptual):\n\nPivot (Optional but helpful): The code often starts by pivoting the event_log slightly to easily access arrival and departure times per patient.\nIterate Through Time: Loop through simulation time from 0 up to limit_duration, taking steps of size every_x_time_units. Let the current time step be minute.\nIdentify Active Entities: For the current minute, find all patient identifiers that have arrival time &lt;= minute AND (depart time &gt;= minute OR depart time is missing/null). These are the entities currently “in the system”.\nFind Latest State: Filter the original event_log to include only events for these active entities that occurred at or before the current minute. For each active entity, find their very last event in this filtered set (using groupby('patient').tail(1) after sorting by time). This last event represents the entity’s state (e.g., ‘wait_nurse’, ‘use_nurse’) at this specific minute.\nRank Entities: Within each event category at the current minute, rank the entities based on when they entered that state (often approximated by the original event log’s index or time). This gives us the rank column, crucial for queue ordering.\nLimit Snapshot Size: Apply the step_snapshot_max limit if needed.\nStore Snapshot: Store the details (patient, event, event_type, resource_id, rank, original event time, current snapshot minute) for this time step.\nConcatenate: After looping through all time steps, combine the stored snapshots into a single large DataFrame (full_patient_df).\nAdd Exit State: Append a final ‘exit’ event for each patient one time step after their last recorded event. This ensures entities visibly leave the animation area rather than just vanishing.\n\nOutput (full_patient_df): A DataFrame where each row represents a specific entity (patient) in a specific state (event, event_type, potentially using resource_id) at a specific snapshot time (minute), along with their rank within that state at that time.\nCode Glimpse:\nHere’s a simplified view of the core logic inside vidigi.prep.reshape_for_animations:\n# From: vidigi/prep.py (Simplified)\n\ndef reshape_for_animations(event_log,\n                           every_x_time_units=10,\n                           limit_duration=14400, # e.g., 10 days in minutes\n                           step_snapshot_max=50,\n                           debug_mode=False):\n\n    patient_dfs = [] # To store snapshots for each minute\n\n    # 1. Pivot helps find arrival/departure easily (simplified view)\n    pivoted_log = event_log.pivot_table(values=\"time\", index=\"patient\",\n                                        columns=\"event\",\n                                        aggfunc='first') # Simplified pivot\n\n    # 2. Iterate Through Time\n    for minute in range(0, limit_duration, every_x_time_units):\n\n        # 3. Identify Active Entities\n        active_patients_mask = (pivoted_log['arrival'] &lt;= minute) & \\\n                               ((pivoted_log['depart'] &gt;= minute) | pd.isnull(pivoted_log['depart']))\n        current_patients_in_moment = pivoted_log[active_patients_mask].index\n\n        if not current_patients_in_moment.empty:\n            # 4. Find Latest State for active patients up to this minute\n            patient_minute_df = event_log[\n                (event_log['patient'].isin(current_patients_in_moment)) &\n                (event_log['time'] &lt;= minute)\n            ].copy() # Filter original log\n\n            # Sort by time, then use groupby().tail(1) to get the latest event per patient\n            patient_minute_df = patient_minute_df.sort_values(['time', 'index']) # Assuming 'index' preserves original order\n            most_recent_events = patient_minute_df.groupby('patient').tail(1)\n\n            # 5. Rank Entities within each event group\n            most_recent_events['rank'] = most_recent_events.groupby('event')['time'] \\\n                                        .rank(method='first', ascending=True)\n\n            # 6. Limit Snapshot Size (simplified)\n            most_recent_events = most_recent_events.groupby('event').head(step_snapshot_max)\n\n            # 7. Store Snapshot (adding the current minute)\n            patient_dfs.append(most_recent_events.assign(minute=minute))\n\n    # 8. Concatenate all snapshots\n    full_patient_df = pd.concat(patient_dfs, ignore_index=True) if patient_dfs else pd.DataFrame()\n\n    # 9. Add Exit State (simplified logic)\n    if not full_patient_df.empty:\n        final_step = full_patient_df.loc[full_patient_df.groupby('patient')['minute'].idxmax()]\n        final_step = final_step.copy()\n        final_step['minute'] = final_step['minute'] + every_x_time_units\n        final_step['event'] = \"exit\"\n        final_step['event_type'] = \"arrival_departure\" # Consistent type needed\n        full_patient_df = pd.concat([full_patient_df, final_step], ignore_index=True)\n\n    return full_patient_df.sort_values([\"minute\", \"event\"]).reset_index(drop=True)\nThis function takes the raw event stream and effectively samples the state of the system at regular intervals, preparing the ground for spatial layout.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#calculating-positions-with-generate_animation_df",
    "href": "autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#calculating-positions-with-generate_animation_df",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Now that we know who is doing what at each time slice (minute), generate_animation_df figures out exactly where they should be drawn.\nPurpose: To calculate the final X and Y coordinates (x_final, y_final) for each entity in each snapshot, based on their state, rank/resource ID, and the defined layout.\nInputs: * full_patient_df: The DataFrame output by reshape_for_animations. * event_position_df: The layout DataFrame from Chapter 3: Layout Configuration. * Layout parameters: wrap_queues_at, wrap_resources_at, gap_between_entities, gap_between_resources, gap_between_rows. * custom_entity_icon_list: Optional list of emojis/icons to use for entities.\nProcess (Conceptual):\n\nMerge Layout: Join full_patient_df with event_position_df on the event column. This brings the base x and y coordinates for each entity’s current state into the main DataFrame.\nSplit by Event Type: Conceptually (or literally in the code), separate the rows based on event_type because positioning logic differs:\n\nQueues (event_type == 'queue'):\n\nStart with the base x, y from the layout.\nCalculate x_final: Typically subtract rank * gap_between_entities from the base x (queues usually extend leftwards).\nCalculate y_final: Initially the base y.\nHandle Wrapping: If wrap_queues_at is set, use the rank and wrap_queues_at to determine the row number (row = floor((rank - 1) / wrap_queues_at)). Adjust x_final (resetting based on position within the row) and y_final (adding row * gap_between_rows).\n\nResource Use (event_type == 'resource_use'):\n\nStart with the base x, y.\nRequires the resource_id column populated as per Chapter 4.\nCalculate x_final: Typically subtract resource_id * gap_between_resources from the base x.\nCalculate y_final: Initially the base y.\nHandle Wrapping: Similar to queues, but using resource_id and wrap_resources_at. Adjust x_final and y_final based on the resource row.\n\nOther Events (e.g., arrival, exit, custom non-queue/resource steps):\n\nUsually, x_final and y_final are simply set to the base x and y from the layout.\n\n\nCombine Back: Concatenate the processed subsets back into a single DataFrame.\nAssign Icons: Generate a mapping from unique patient identifiers to icons (e.g., emojis from the default list or custom_entity_icon_list). Add an icon column to the DataFrame.\nHandle Snapshot Limit Visuals: If step_snapshot_max was applied in reshape_for_animations, this function might modify the icon/text for the last displayed entity in a truncated queue/resource group to indicate that more entities exist but aren’t shown (e.g., displaying “+ 5 more”).\n\nOutput (full_patient_df_plus_pos): The final DataFrame ready for plotting. Contains patient, minute, event, icon, and the crucial x_final, y_final coordinates, along with other potentially useful columns.\nCode Glimpse:\nHere’s a simplified look at the positioning logic within vidigi.prep.generate_animation_df:\n# From: vidigi/prep.py (Simplified)\nimport numpy as np\nimport pandas as pd\n\ndef generate_animation_df(\n        full_patient_df,\n        event_position_df,\n        wrap_queues_at=20,\n        wrap_resources_at=20,\n        gap_between_entities=10,\n        gap_between_resources=10,\n        gap_between_rows=30,\n        # ... other params ...\n        custom_entity_icon_list=None\n):\n\n    # 1. Merge Layout info (base x, y)\n    # Assumes 'rank' column already exists from reshape_for_animations\n    df_plus_pos = full_patient_df.merge(event_position_df[['event', 'x', 'y']],\n                                        on=\"event\", how='left')\n\n    # --- 2. Split and Calculate Positions ---\n    # Handle Queues\n    queues = df_plus_pos[df_plus_pos['event_type'] == 'queue'].copy()\n    if not queues.empty:\n        queues['x_final'] = queues['x'] - queues['rank'] * gap_between_entities\n        queues['y_final'] = queues['y']\n        if wrap_queues_at is not None:\n            queues['row'] = np.floor((queues['rank'] - 1) / wrap_queues_at)\n            # Adjust x based on position in the row\n            queues['x_final'] += (wrap_queues_at * queues['row'] * gap_between_entities) + gap_between_entities\n            # Adjust y based on the row\n            queues['y_final'] += queues['row'] * gap_between_rows\n\n    # Handle Resource Use\n    resources = df_plus_pos[df_plus_pos['event_type'] == 'resource_use'].copy()\n    if not resources.empty:\n        # Assumes 'resource_id' column exists and is numeric (1-based)\n        resources['x_final'] = resources['x'] - resources['resource_id'] * gap_between_resources\n        resources['y_final'] = resources['y']\n        if wrap_resources_at is not None:\n            resources['row'] = np.floor((resources['resource_id'] - 1) / wrap_resources_at)\n            # Adjust x based on position in the row\n            resources['x_final'] += (wrap_resources_at * resources['row'] * gap_between_resources) + gap_between_resources\n            # Adjust y based on the row\n            resources['y_final'] += resources['row'] * gap_between_rows\n\n    # Handle Other events (simplified - assume they just use base x, y)\n    others = df_plus_pos[~df_plus_pos['event_type'].isin(['queue', 'resource_use'])].copy()\n    if not others.empty:\n        others['x_final'] = others['x']\n        others['y_final'] = others['y']\n\n    # 3. Combine Back\n    final_df_parts = [part for part in [queues, resources, others] if not part.empty]\n    final_df = pd.concat(final_df_parts, ignore_index=True) if final_df_parts else pd.DataFrame()\n\n    # 4. Assign Icons (simplified)\n    if not final_df.empty:\n        unique_patients = final_df['patient'].unique()\n        # Default icon list or custom list\n        icon_list = custom_entity_icon_list or get_default_icon_list()\n        icon_map = {patient: icon_list[i % len(icon_list)] for i, patient in enumerate(unique_patients)}\n        final_df['icon'] = final_df['patient'].map(icon_map)\n\n        # 5. Handle Snapshot Limit Visuals (logic omitted for brevity)\n        # ... code to potentially modify 'icon' for truncated groups ...\n\n    return final_df.sort_values(['minute', 'patient']) # Return sorted\n\n# Helper function (conceptual)\ndef get_default_icon_list():\n    return ['🧔🏼', '👨🏿‍🦯', '👨🏻‍🦰', '🧑🏻', '👩🏿‍🦱', '🤰', '👳🏽', '👩🏼‍🦳', '👨🏿‍🦳', '👩🏼‍🦱', ...] # A long list of emojis\nThis function takes the time-sliced data and applies the spatial rules defined by the layout, producing the exact coordinates needed frame-by-frame.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#conclusion",
    "href": "autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#conclusion",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "The snapshot preparation stage, comprising reshape_for_animations and generate_animation_df, is the crucial data transformation engine within vidigi. It bridges the gap between the raw, event-based simulation output (event_log) and the frame-by-frame requirements of an animation.\nreshape_for_animations processes the event log to determine who is doing what at regular time intervals, creating time slices. generate_animation_df then takes these time slices and the layout configuration (event_position_df) to calculate the precise X/Y coordinates for each entity in each slice, handling queue formation and resource allocation visually.\nThe result is a comprehensive DataFrame (full_patient_df_plus_pos) containing everything needed to draw each frame: the entity identifier, the time snapshot, the assigned icon, and the final x_final, y_final position.\nWith this meticulously prepared data, we are finally ready to generate the animation itself using Plotly.\nNext: Chapter 6: Animation Generation (generate_animation)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/03_layout_configuration_event_position_df_.html",
    "href": "autodoc_v2/03_layout_configuration_event_position_df_.html",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "In the previous chapter, Chapter 2: Event Log, we explored how to structure the event_log DataFrame to record the ‘who, what, and when’ of entity movements in your simulation. Now, we need to tell vidigi where these events should visually occur on the animation canvas. That’s the job of the Layout Configuration, represented by the event_position_df DataFrame.\n\n\nImagine you’re describing the layout of our simple clinic to someone. You might say, “The entrance is on the left, then there’s a waiting area in the middle, and the treatment rooms are further to the right.” To create a meaningful animation, vidigi needs precisely this kind of spatial information. Without it, all the entities would just pile up at the default coordinates (0,0)!\nThe event_position_df acts as a blueprint or a map for your animation’s background. It defines fixed anchor points on the 2D plane for each key stage or event in your process. These anchor points are then used by vidigi to position entities, whether they are queuing or using a resource.\n\n\n\nThe event_position_df is, fundamentally, a pandas DataFrame. Each row defines the base visual location for a specific event name that appears in your event_log.\nThink of it as a lookup table mapping event names to coordinates and other display properties.\n\n\nYour event_position_df must contain the following columns:\n\nevent: A string that matches a specific event name found in the event column of your event_log. Critically, this DataFrame must include entries for 'arrival' and the special 'exit' event (which vidigi uses internally, as created by reshape_for_animations). It should also include entries for any event names you used in the event_log that correspond to the start of a queue (event_type='queue') or the start of resource use (event_type='resource_use') that you wish to visualise. You generally don’t need entries for event_type='resource_use_end' or 'depart' (as 'exit' handles the final visual state).\nx: A numerical value representing the base X-coordinate for this event on the animation canvas.\ny: A numerical value representing the base Y-coordinate for this event.\n\n\n\n\nYou can add these columns for more control and clarity:\n\nlabel: A string providing a human-readable name for the stage corresponding to this event (e.g., “Waiting Area”, “Treatment Room 1”). If the display_stage_labels parameter in animate_activity_log is True, these labels will be drawn on the animation near the (x, y) coordinates. It’s good practice to always include this, even if you don’t display them initially.\nresource: A string that links an event associated with resource usage (i.e., one where entities have event_type='resource_use' in the event_log) to an attribute name in your scenario object. This attribute in the scenario object should hold the capacity (number of available instances) of that resource. For example, if your event is 'use_nurse' and your scenario object has an attribute scenario.n_nurses = 3, you would put 'n_nurses' in the resource column for the 'use_nurse' row. This tells vidigi how many resource ‘slots’ to visualise and allows it to correctly place entities using specific resource_ids (like nurse 1, nurse 2, nurse 3). This column should be None or NaN for non-resource-use events like 'arrival' or queue events.\n\n\n\n\n\nLet’s revisit our clinic example and define its layout. Suppose we have arrival, a waiting area ('wait_nurse' event), a treatment area ('use_nurse' event), and the exit point. We also have a scenario object where scenario.n_nurses defines the number of nurses.\nimport pandas as pd\nimport numpy as np\n\n# Example event_position_df\nevent_position_df = pd.DataFrame([\n    {'event': 'arrival',        # Matches 'arrival' in event_log\n     'x': 50, 'y': 200,\n     'label': \"Arrival Area\",   # Human-readable label\n     'resource': np.nan},       # Not a resource use step\n\n    {'event': 'wait_nurse',     # Matches 'wait_nurse' (queue event) in event_log\n     'x': 150, 'y': 250,\n     'label': \"Waiting Area\",\n     'resource': np.nan},       # Queue, not direct resource use\n\n    {'event': 'use_nurse',      # Matches 'use_nurse' (resource_use event) in event_log\n     'x': 250, 'y': 150,\n     'label': \"Treatment Bays\",\n     'resource': 'n_nurses'},   # Links to scenario.n_nurses for capacity\n\n    {'event': 'exit',           # Matches the special 'exit' event\n     'x': 350, 'y': 200,\n     'label': \"Exit Point\",\n     'resource': np.nan}        # Not a resource use step\n])\n\n# --- Placeholder Scenario Object (Assume this exists elsewhere) ---\nclass Scenario:\n    n_nurses = 2 # Let's say there are 2 nurses\nscenario_config = Scenario()\n# --- End Placeholder ---\n\nprint(event_position_df)\nOutput:\n          event    x    y             label  resource\n0       arrival   50  200      Arrival Area       NaN\n1    wait_nurse  150  250      Waiting Area       NaN\n2     use_nurse  250  150    Treatment Bays  n_nurses\n3          exit  350  200        Exit Point       NaN\nThis DataFrame provides vidigi with the necessary spatial anchors.\n\n\n\nThe event_position_df is primarily used within the Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df) stage, specifically by the generate_animation_df function, and also by the Chapter 6: Animation Generation (generate_animation) function for drawing labels and resource placeholders.\nHere’s a conceptual walkthrough of how generate_animation_df uses it:\n\nInput: It receives the snapshot DataFrame (output from reshape_for_animations, detailing which entity is performing which event at each minute) and the event_position_df.\nMerge/Lookup: For each row in the snapshot DataFrame, it looks up the corresponding event in event_position_df to find the base x and y coordinates.\nCalculate Final Position (x_final, y_final):\n\nFor simple events (like 'arrival', 'exit'): The x_final, y_final might be directly set to the base x, y.\nFor 'queue' events: It calculates the entity’s position within the queue (based on arrival time at that queue step, using the rank column generated earlier). The queue typically extends leftwards from the base x coordinate. So, the first person might be at x, the second at x - gap_between_entities, the third at x - 2 * gap_between_entities, and so on. If wrap_queues_at is set, it will wrap the queue onto new rows below the base y coordinate.\nFor 'resource_use' events: It uses the resource_id associated with the entity (from the event_log) and the base x, y. Similar to queues, resources are typically placed extending leftwards. If resource='n_nurses', resource 1 might be at x - gap_between_resources, resource 2 at x - 2 * gap_between_resources, etc. The entity is placed at the coordinates corresponding to its assigned resource_id. Wrapping via wrap_resources_at also applies.\n\nOutput: It returns an enhanced DataFrame (full_patient_df_plus_pos) which now includes the calculated x_final and y_final coordinates for every entity at every time snapshot.\n\nThe generate_animation function then uses this full_patient_df_plus_pos to create the scatter plot. It also uses the original event_position_df again: * To draw the stage labels (if display_stage_labels=True) near the base x, y coordinates. * To draw placeholder markers for the available resources (using the resource column to find the capacity in the scenario object) near the base x, y coordinates for resource stages.\n\n\n\nThe connection between event_position_df and the scenario object is vital for visualising resource utilisation accurately.\n\nIn event_position_df, you identify a resource stage (e.g., 'use_nurse').\nYou add the resource column and put the name of the attribute in your scenario object that holds the capacity (e.g., 'n_nurses').\nWhen generate_animation runs, it looks at this row in event_position_df.\nIt sees resource = 'n_nurses'.\nIt accesses the provided scenario object and retrieves the value of getattr(scenario, 'n_nurses') (which might be, say, 2).\nIt now knows it needs to display 2 placeholder resource markers (e.g., light blue circles) near the base coordinates (x, y) defined for 'use_nurse'.\nSimultaneously, generate_animation_df uses this information (and the resource_id from the event log) to ensure Patient A using Nurse 1 is placed at the coordinates for resource slot 1, and Patient B using Nurse 2 is placed at the coordinates for resource slot 2.\n\nHere’s a simplified snippet from vidigi.animation.generate_animation showing how the resource count is retrieved:\n# From: vidigi/animation.py (Simplified inside generate_animation)\n\ndef generate_animation(\n        # ... other parameters ...\n        event_position_df,\n        scenario=None,\n        # ... other parameters ...\n):\n    # ... setup code ...\n\n    # --- Resource Placeholder Generation ---\n    if scenario is not None:\n        # 1. Filter event_position_df to rows where 'resource' is not null\n        events_with_resources = event_position_df[event_position_df['resource'].notnull()].copy()\n\n        # 2. Get the count for each resource from the scenario object\n        #    It applies getattr(scenario, resource_name) to each row\n        events_with_resources['resource_count'] = events_with_resources['resource'].apply(\n            lambda resource_name: getattr(scenario, resource_name)\n        )\n\n        # 3. Calculate positions for each resource instance marker\n        #    (Simplified - actual code handles wrapping and gaps)\n        resource_positions = []\n        for _, row in events_with_resources.iterrows():\n            base_x, base_y = row['x'], row['y']\n            count = row['resource_count']\n            for i in range(count):\n                # Example: place leftwards\n                res_x = base_x - (gap_between_resources * (i + 1))\n                res_y = base_y # (Actual code handles wrapping in y-dimension too)\n                resource_positions.append({'x': res_x, 'y': res_y})\n\n        resource_pos_df = pd.DataFrame(resource_positions)\n\n        # 4. Add a scatter trace to the plot for these resource positions\n        fig.add_trace(go.Scatter(\n            x=resource_pos_df['x'],\n            y=resource_pos_df['y'] - 10, # Offset slightly\n            mode=\"markers\",\n            marker=dict(color='LightSkyBlue', size=15, opacity=resource_opacity),\n            hoverinfo='none'\n            # ... other trace parameters ...\n        ))\n\n    # ... code to add entity traces, labels, background image etc. ...\n\n    return fig\nThis snippet illustrates how the resource column acts as the bridge between the layout definition and the scenario’s parameters to determine how many resource slots to show. The actual placement of entities into these slots happens in generate_animation_df using the resource_id from the event_log.\n\n\n\nDefining coordinates can sometimes involve a bit of trial and error. Here are a couple of tips:\n\nUse setup_mode=True: When calling animate_activity_log, set setup_mode=True. This will display the plot axes with grid lines and coordinate values, making it much easier to estimate appropriate x and y values for your event_position_df.\nSketch it Out: Draw a rough sketch of your desired layout on paper first. This can help you think about the relative positioning of stages before you start coding the coordinates.\nIterate: Don’t expect to get it perfect on the first try. Define initial coordinates, run the animation (perhaps with limit_duration set low for speed), see how it looks, and adjust the x, y values in event_position_df as needed. The HSMA example in the documentation (vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.qmd) shows this iterative process.\n\n\n\n\nThe event_position_df is your key tool for controlling the visual layout of your vidigi animation. By mapping event names from your simulation log to specific X and Y coordinates, providing human-readable labels, and linking resource-use events to capacities defined in a scenario object, you create the essential blueprint that guides how entities are positioned on the screen. It translates the abstract sequence of events from your event_log into a spatially meaningful visualisation.\nWe’ve seen how this DataFrame specifies base locations and how it interacts with the scenario object for resource visualisation. However, correctly logging the resource_id for individual resource instances relies on enhancements to standard simpy resources. In the next chapter, we’ll look at how vidigi uses CustomResource objects, often managed within simpy.Stores, to facilitate this detailed tracking.\nNext: Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/03_layout_configuration_event_position_df_.html#motivation-drawing-the-map",
    "href": "autodoc_v2/03_layout_configuration_event_position_df_.html#motivation-drawing-the-map",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "Imagine you’re describing the layout of our simple clinic to someone. You might say, “The entrance is on the left, then there’s a waiting area in the middle, and the treatment rooms are further to the right.” To create a meaningful animation, vidigi needs precisely this kind of spatial information. Without it, all the entities would just pile up at the default coordinates (0,0)!\nThe event_position_df acts as a blueprint or a map for your animation’s background. It defines fixed anchor points on the 2D plane for each key stage or event in your process. These anchor points are then used by vidigi to position entities, whether they are queuing or using a resource.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/03_layout_configuration_event_position_df_.html#the-core-concept-a-dataframe-for-coordinates",
    "href": "autodoc_v2/03_layout_configuration_event_position_df_.html#the-core-concept-a-dataframe-for-coordinates",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "The event_position_df is, fundamentally, a pandas DataFrame. Each row defines the base visual location for a specific event name that appears in your event_log.\nThink of it as a lookup table mapping event names to coordinates and other display properties.\n\n\nYour event_position_df must contain the following columns:\n\nevent: A string that matches a specific event name found in the event column of your event_log. Critically, this DataFrame must include entries for 'arrival' and the special 'exit' event (which vidigi uses internally, as created by reshape_for_animations). It should also include entries for any event names you used in the event_log that correspond to the start of a queue (event_type='queue') or the start of resource use (event_type='resource_use') that you wish to visualise. You generally don’t need entries for event_type='resource_use_end' or 'depart' (as 'exit' handles the final visual state).\nx: A numerical value representing the base X-coordinate for this event on the animation canvas.\ny: A numerical value representing the base Y-coordinate for this event.\n\n\n\n\nYou can add these columns for more control and clarity:\n\nlabel: A string providing a human-readable name for the stage corresponding to this event (e.g., “Waiting Area”, “Treatment Room 1”). If the display_stage_labels parameter in animate_activity_log is True, these labels will be drawn on the animation near the (x, y) coordinates. It’s good practice to always include this, even if you don’t display them initially.\nresource: A string that links an event associated with resource usage (i.e., one where entities have event_type='resource_use' in the event_log) to an attribute name in your scenario object. This attribute in the scenario object should hold the capacity (number of available instances) of that resource. For example, if your event is 'use_nurse' and your scenario object has an attribute scenario.n_nurses = 3, you would put 'n_nurses' in the resource column for the 'use_nurse' row. This tells vidigi how many resource ‘slots’ to visualise and allows it to correctly place entities using specific resource_ids (like nurse 1, nurse 2, nurse 3). This column should be None or NaN for non-resource-use events like 'arrival' or queue events.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/03_layout_configuration_event_position_df_.html#usage-example-defining-the-clinic-layout",
    "href": "autodoc_v2/03_layout_configuration_event_position_df_.html#usage-example-defining-the-clinic-layout",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "Let’s revisit our clinic example and define its layout. Suppose we have arrival, a waiting area ('wait_nurse' event), a treatment area ('use_nurse' event), and the exit point. We also have a scenario object where scenario.n_nurses defines the number of nurses.\nimport pandas as pd\nimport numpy as np\n\n# Example event_position_df\nevent_position_df = pd.DataFrame([\n    {'event': 'arrival',        # Matches 'arrival' in event_log\n     'x': 50, 'y': 200,\n     'label': \"Arrival Area\",   # Human-readable label\n     'resource': np.nan},       # Not a resource use step\n\n    {'event': 'wait_nurse',     # Matches 'wait_nurse' (queue event) in event_log\n     'x': 150, 'y': 250,\n     'label': \"Waiting Area\",\n     'resource': np.nan},       # Queue, not direct resource use\n\n    {'event': 'use_nurse',      # Matches 'use_nurse' (resource_use event) in event_log\n     'x': 250, 'y': 150,\n     'label': \"Treatment Bays\",\n     'resource': 'n_nurses'},   # Links to scenario.n_nurses for capacity\n\n    {'event': 'exit',           # Matches the special 'exit' event\n     'x': 350, 'y': 200,\n     'label': \"Exit Point\",\n     'resource': np.nan}        # Not a resource use step\n])\n\n# --- Placeholder Scenario Object (Assume this exists elsewhere) ---\nclass Scenario:\n    n_nurses = 2 # Let's say there are 2 nurses\nscenario_config = Scenario()\n# --- End Placeholder ---\n\nprint(event_position_df)\nOutput:\n          event    x    y             label  resource\n0       arrival   50  200      Arrival Area       NaN\n1    wait_nurse  150  250      Waiting Area       NaN\n2     use_nurse  250  150    Treatment Bays  n_nurses\n3          exit  350  200        Exit Point       NaN\nThis DataFrame provides vidigi with the necessary spatial anchors.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/03_layout_configuration_event_position_df_.html#how-vidigi-uses-the-layout",
    "href": "autodoc_v2/03_layout_configuration_event_position_df_.html#how-vidigi-uses-the-layout",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "The event_position_df is primarily used within the Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df) stage, specifically by the generate_animation_df function, and also by the Chapter 6: Animation Generation (generate_animation) function for drawing labels and resource placeholders.\nHere’s a conceptual walkthrough of how generate_animation_df uses it:\n\nInput: It receives the snapshot DataFrame (output from reshape_for_animations, detailing which entity is performing which event at each minute) and the event_position_df.\nMerge/Lookup: For each row in the snapshot DataFrame, it looks up the corresponding event in event_position_df to find the base x and y coordinates.\nCalculate Final Position (x_final, y_final):\n\nFor simple events (like 'arrival', 'exit'): The x_final, y_final might be directly set to the base x, y.\nFor 'queue' events: It calculates the entity’s position within the queue (based on arrival time at that queue step, using the rank column generated earlier). The queue typically extends leftwards from the base x coordinate. So, the first person might be at x, the second at x - gap_between_entities, the third at x - 2 * gap_between_entities, and so on. If wrap_queues_at is set, it will wrap the queue onto new rows below the base y coordinate.\nFor 'resource_use' events: It uses the resource_id associated with the entity (from the event_log) and the base x, y. Similar to queues, resources are typically placed extending leftwards. If resource='n_nurses', resource 1 might be at x - gap_between_resources, resource 2 at x - 2 * gap_between_resources, etc. The entity is placed at the coordinates corresponding to its assigned resource_id. Wrapping via wrap_resources_at also applies.\n\nOutput: It returns an enhanced DataFrame (full_patient_df_plus_pos) which now includes the calculated x_final and y_final coordinates for every entity at every time snapshot.\n\nThe generate_animation function then uses this full_patient_df_plus_pos to create the scatter plot. It also uses the original event_position_df again: * To draw the stage labels (if display_stage_labels=True) near the base x, y coordinates. * To draw placeholder markers for the available resources (using the resource column to find the capacity in the scenario object) near the base x, y coordinates for resource stages.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/03_layout_configuration_event_position_df_.html#linking-resources-via-the-scenario-object",
    "href": "autodoc_v2/03_layout_configuration_event_position_df_.html#linking-resources-via-the-scenario-object",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "The connection between event_position_df and the scenario object is vital for visualising resource utilisation accurately.\n\nIn event_position_df, you identify a resource stage (e.g., 'use_nurse').\nYou add the resource column and put the name of the attribute in your scenario object that holds the capacity (e.g., 'n_nurses').\nWhen generate_animation runs, it looks at this row in event_position_df.\nIt sees resource = 'n_nurses'.\nIt accesses the provided scenario object and retrieves the value of getattr(scenario, 'n_nurses') (which might be, say, 2).\nIt now knows it needs to display 2 placeholder resource markers (e.g., light blue circles) near the base coordinates (x, y) defined for 'use_nurse'.\nSimultaneously, generate_animation_df uses this information (and the resource_id from the event log) to ensure Patient A using Nurse 1 is placed at the coordinates for resource slot 1, and Patient B using Nurse 2 is placed at the coordinates for resource slot 2.\n\nHere’s a simplified snippet from vidigi.animation.generate_animation showing how the resource count is retrieved:\n# From: vidigi/animation.py (Simplified inside generate_animation)\n\ndef generate_animation(\n        # ... other parameters ...\n        event_position_df,\n        scenario=None,\n        # ... other parameters ...\n):\n    # ... setup code ...\n\n    # --- Resource Placeholder Generation ---\n    if scenario is not None:\n        # 1. Filter event_position_df to rows where 'resource' is not null\n        events_with_resources = event_position_df[event_position_df['resource'].notnull()].copy()\n\n        # 2. Get the count for each resource from the scenario object\n        #    It applies getattr(scenario, resource_name) to each row\n        events_with_resources['resource_count'] = events_with_resources['resource'].apply(\n            lambda resource_name: getattr(scenario, resource_name)\n        )\n\n        # 3. Calculate positions for each resource instance marker\n        #    (Simplified - actual code handles wrapping and gaps)\n        resource_positions = []\n        for _, row in events_with_resources.iterrows():\n            base_x, base_y = row['x'], row['y']\n            count = row['resource_count']\n            for i in range(count):\n                # Example: place leftwards\n                res_x = base_x - (gap_between_resources * (i + 1))\n                res_y = base_y # (Actual code handles wrapping in y-dimension too)\n                resource_positions.append({'x': res_x, 'y': res_y})\n\n        resource_pos_df = pd.DataFrame(resource_positions)\n\n        # 4. Add a scatter trace to the plot for these resource positions\n        fig.add_trace(go.Scatter(\n            x=resource_pos_df['x'],\n            y=resource_pos_df['y'] - 10, # Offset slightly\n            mode=\"markers\",\n            marker=dict(color='LightSkyBlue', size=15, opacity=resource_opacity),\n            hoverinfo='none'\n            # ... other trace parameters ...\n        ))\n\n    # ... code to add entity traces, labels, background image etc. ...\n\n    return fig\nThis snippet illustrates how the resource column acts as the bridge between the layout definition and the scenario’s parameters to determine how many resource slots to show. The actual placement of entities into these slots happens in generate_animation_df using the resource_id from the event_log.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/03_layout_configuration_event_position_df_.html#tips-for-setting-up-your-layout",
    "href": "autodoc_v2/03_layout_configuration_event_position_df_.html#tips-for-setting-up-your-layout",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "Defining coordinates can sometimes involve a bit of trial and error. Here are a couple of tips:\n\nUse setup_mode=True: When calling animate_activity_log, set setup_mode=True. This will display the plot axes with grid lines and coordinate values, making it much easier to estimate appropriate x and y values for your event_position_df.\nSketch it Out: Draw a rough sketch of your desired layout on paper first. This can help you think about the relative positioning of stages before you start coding the coordinates.\nIterate: Don’t expect to get it perfect on the first try. Define initial coordinates, run the animation (perhaps with limit_duration set low for speed), see how it looks, and adjust the x, y values in event_position_df as needed. The HSMA example in the documentation (vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.qmd) shows this iterative process.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/03_layout_configuration_event_position_df_.html#conclusion",
    "href": "autodoc_v2/03_layout_configuration_event_position_df_.html#conclusion",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "The event_position_df is your key tool for controlling the visual layout of your vidigi animation. By mapping event names from your simulation log to specific X and Y coordinates, providing human-readable labels, and linking resource-use events to capacities defined in a scenario object, you create the essential blueprint that guides how entities are positioned on the screen. It translates the abstract sequence of events from your event_log into a spatially meaningful visualisation.\nWe’ve seen how this DataFrame specifies base locations and how it interacts with the scenario object for resource visualisation. However, correctly logging the resource_id for individual resource instances relies on enhancements to standard simpy resources. In the next chapter, we’ll look at how vidigi uses CustomResource objects, often managed within simpy.Stores, to facilitate this detailed tracking.\nNext: Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "autodoc_v2/01_animation_facade_animate_activity_log_.html",
    "href": "autodoc_v2/01_animation_facade_animate_activity_log_.html",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "Welcome to the vidigi tutorial! If you’re looking to create animated visualisations from your discrete-event simulation (DES) models, you’re in the right place. Whether you’re modelling patient flow in a hospital, customer movement in a shop, or any other process involving entities moving through steps over time, vidigi aims to make visualising it straightforward.\nCreating these animations often involves several steps: preparing your raw simulation output, figuring out where each entity should be at specific time points, handling queues and resource usage visually, and finally generating the plot itself. This can be a bit fiddly.\nThat’s where animate_activity_log comes in. Think of it as the main control panel or the “easy button” for vidigi. It’s designed to be the primary function you’ll interact with, orchestrating all the necessary background steps to turn your simulation data into a polished animation with minimal fuss.\n\n\nLet’s imagine you’ve run a simulation of a simple clinic. Your simulation has produced a log detailing when patients arrived, when they started queuing for a nurse, when they began treatment, and when they left. You also have an idea of the physical layout – where the entrance is, where the waiting area is, and where the treatment cubicles are located.\nYour goal is to create an animation showing little icons representing patients moving through these stages over the simulated time. You want to see queues forming and shrinking, and patients occupying the treatment cubicles.\nThis is precisely the sort of task animate_activity_log is built for.\n\n\n\nTo use animate_activity_log, you primarily need two key pieces of information, prepared as pandas DataFrames:\n\nevent_log: This DataFrame contains the raw output from your simulation. It lists events (like ‘arrival’, ‘start_queue’, ‘start_treatment’, ‘departure’) for each entity (e.g., patient), along with the time the event occurred. We’ll dive deep into the required format in Chapter 2: Event Log.\nevent_position_df: This DataFrame defines the layout of your animation. It maps each key event (or stage) in your process to specific X and Y coordinates on the animation canvas. Think of it as drawing a map for vidigi. More details can be found in Chapter 3: Layout Configuration (event_position_df).\n\nOptionally, you might also provide:\n\nscenario: A simple Python object (like an instance of a class) that holds information about resource capacities (e.g., number of nurses). This helps vidigi visualise the available resources correctly. We touch on resources, especially related to simpy, in Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store).\n\nLet’s look at a basic example call. Assume you have your event_log_df and event_position_df ready, and perhaps a scenario_config object.\nimport pandas as pd\nfrom vidigi.animation import animate_activity_log\n\n# Assume these DataFrames and object are already defined:\n# event_log_df: Your simulation output log (See Chapter 2)\n# event_position_df: Your layout coordinates (See Chapter 3)\n# scenario_config: An object with resource counts (e.g., scenario_config.n_nurses = 5)\n\n# --- Placeholder DataFrames (Replace with your actual data) ---\nevent_log_df = pd.DataFrame({\n    'patient': [1, 1, 1, 2, 2, 2, 1, 2],\n    'event_type': ['arrival_departure', 'queue', 'resource_use', 'arrival_departure', 'queue', 'resource_use', 'arrival_departure', 'arrival_departure'],\n    'event': ['arrival', 'wait_nurse', 'use_nurse', 'arrival', 'wait_nurse', 'use_nurse', 'depart', 'depart'],\n    'time': [0, 10, 15, 5, 12, 20, 35, 40],\n    'resource_id': [None, None, 1, None, None, 2, None, None], # Optional, needed for resource tracking\n    'pathway': ['Routine', 'Routine', 'Routine', 'Routine', 'Routine', 'Routine', 'Routine', 'Routine'] # Optional grouping\n})\n\nevent_position_df = pd.DataFrame({\n    'event': ['arrival', 'wait_nurse', 'use_nurse', 'depart'],\n    'x': [50, 150, 250, 350],\n    'y': [200, 200, 200, 200],\n    'label': ['Arrival', 'Waiting Area', 'Treatment Room', 'Departure'], # Human-readable labels\n    'resource': [None, None, 'n_nurses', None] # Link to scenario attribute for resource count\n})\n\n# --- Placeholder Scenario Object ---\nclass Scenario:\n    n_nurses = 2\nscenario_config = Scenario()\n# --- End Placeholder Data ---\n\n\n# Generate the animation\nanimation_figure = animate_activity_log(\n    event_log=event_log_df,\n    event_position_df=event_position_df,\n    scenario=scenario_config,\n    every_x_time_units=1, # Time interval between animation frames\n    limit_duration=50,    # Maximum simulation time to animate\n    time_display_units='dhm', # Format time as days/hours/minutes\n    icon_and_text_size=20,   # Adjust icon size\n    plotly_height=600,       # Set figure height\n    debug_mode=False         # Turn off verbose output\n)\n\n# To display the animation (e.g., in a Jupyter Notebook or save to HTML)\n# animation_figure.show()\n# animation_figure.write_html(\"my_clinic_animation.html\")\nThis single function call triggers the entire process. It takes your raw data and layout, performs the necessary calculations to determine entity positions at each time step, and produces an interactive Plotly Figure object. This figure contains the animated scatter plot showing your entities moving through the system.\nanimate_activity_log also accepts numerous optional parameters for customisation (like wrap_queues_at, add_background_image, frame_duration, etc.), allowing you to fine-tune the appearance and behaviour of the animation. You can explore these in the function’s documentation.\n\n\n\nSo, what happens when you call animate_activity_log? It acts like a director, coordinating several backstage functions to prepare the data and generate the final animation. Here’s a step-by-step breakdown:\n\nInput Reception: animate_activity_log receives the event_log, event_position_df, scenario object, and any customisation parameters you’ve provided.\nSnapshot Preparation (Reshaping): It first calls the reshape_for_animations function (detailed in Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)). This function takes the raw event_log and transforms it. Instead of just listing when events occurred, it creates a “snapshot” DataFrame detailing the state (event/location) of every entity at regular time intervals (every_x_time_units).\nSnapshot Preparation (Positioning): Next, it passes the reshaped snapshot DataFrame and the event_position_df to the generate_animation_df function (also covered in Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)). This crucial step calculates the precise X, Y coordinates for each entity in each time snapshot, handling the layout of queues and the assignment of entities to specific resource instances (like nurse 1 vs. nurse 2). It also assigns visual icons (like emojis) to entities.\nAnimation Generation: Finally, the fully prepared DataFrame (containing entity IDs, icons, time snapshots, and exact X/Y coordinates) is passed to the generate_animation function along with the layout (event_position_df), scenario details, and customisation parameters (like figure size, background image, etc.). This function (explained in Chapter 6: Animation Generation (generate_animation)) uses Plotly Express to create the animated scatter plot, setting up the time slider, labels, resource visuals, and other graphical elements.\nReturn Figure: animate_activity_log returns the final Plotly Figure object created by generate_animation.\n\nWe can visualise this orchestration with a sequence diagram:\n\n\n\n\n\nsequenceDiagram\n    participant User\n    participant Facade as animate_activity_log\n    participant Reshaper as reshape_for_animations\n    participant PosGenerator as generate_animation_df\n    participant Animator as generate_animation\n\n    User-&gt;&gt;+Facade: Call animate_activity_log(event_log, pos_df, scenario, params...)\n    Facade-&gt;&gt;+Reshaper: Call reshape_for_animations(event_log, params...)\n    Reshaper--&gt;&gt;-Facade: Return snapshot_df\n    Facade-&gt;&gt;+PosGenerator: Call generate_animation_df(snapshot_df, pos_df, params...)\n    PosGenerator--&gt;&gt;-Facade: Return positioned_snapshot_df\n    Facade-&gt;&gt;+Animator: Call generate_animation(positioned_snapshot_df, pos_df, scenario, params...)\n    Animator--&gt;&gt;-Facade: Return plotly_figure\n    Facade--&gt;&gt;-User: Return plotly_figure\n\n\n\n\n\n\nLooking at the source code for animate_activity_log (simplified below), you can see this sequence clearly:\n# From: vidigi/animation.py\n\ndef animate_activity_log(\n        event_log,\n        event_position_df,\n        scenario=None,\n        # ... many other parameters ...\n        debug_mode=False,\n        custom_entity_icon_list=None\n        ):\n    \"\"\"\n    Generate an animated visualization of patient flow through a system.\n    (Docstring omitted for brevity)\n    \"\"\"\n    if debug_mode:\n        start_time_function = time.perf_counter()\n        print(f'Animation function called at {time.strftime(\"%H:%M:%S\", time.localtime())}')\n\n    # Step 1: Reshape the raw event log into time snapshots\n    full_patient_df = reshape_for_animations(\n        event_log,\n        # Pass relevant parameters like every_x_time_units, limit_duration etc.\n        every_x_time_units=every_x_time_units,\n        limit_duration=limit_duration,\n        step_snapshot_max=step_snapshot_max,\n        debug_mode=debug_mode\n    )\n\n    if debug_mode:\n        print(f'Reshaped animation dataframe finished construction at {time.strftime(\"%H:%M:%S\", time.localtime())}')\n\n    # Step 2: Calculate X, Y positions for each entity in each snapshot\n    full_patient_df_plus_pos = generate_animation_df(\n        full_patient_df=full_patient_df,\n        event_position_df=event_position_df,\n        # Pass relevant parameters like wrap_queues_at, gap_between_entities etc.\n        wrap_queues_at=wrap_queues_at,\n        wrap_resources_at=wrap_resources_at,\n        step_snapshot_max=step_snapshot_max,\n        gap_between_entities=gap_between_entities,\n        gap_between_resources=gap_between_resources,\n        gap_between_rows=gap_between_rows,\n        debug_mode=debug_mode,\n        custom_entity_icon_list=custom_entity_icon_list\n    )\n\n    # Step 3: Generate the Plotly animation figure using the positioned data\n    animation = generate_animation(\n        full_patient_df_plus_pos=full_patient_df_plus_pos,\n        event_position_df=event_position_df,\n        scenario=scenario,\n        # Pass relevant customization parameters like plotly_height, add_background_image etc.\n        plotly_height=plotly_height,\n        plotly_width=plotly_width,\n        include_play_button=include_play_button,\n        add_background_image=add_background_image,\n        # ... other parameters ...\n        debug_mode=debug_mode\n    )\n\n    if debug_mode:\n        end_time_function = time.perf_counter()\n        print(f'Total Time Elapsed: {(end_time_function - start_time_function):.2f} seconds')\n\n    # Step 4: Return the final figure\n    return animation\nBy wrapping these steps, animate_activity_log provides a convenient, high-level interface, shielding you from the internal complexities unless you specifically need to delve deeper or use the underlying functions individually.\n\n\n\nIn this chapter, we’ve introduced animate_activity_log, the primary function for creating animations with vidigi. We’ve seen how it acts as a facade, taking your core simulation outputs (event_log) and layout instructions (event_position_df) to produce an animated Plotly figure by orchestrating several internal data preparation and plotting steps.\nThis “easy button” approach allows you to generate insightful visualisations quickly. However, understanding the data it requires is crucial. In the next chapter, we’ll focus on the heart of the input: the event_log.\nNext: Chapter 2: Event Log\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "autodoc_v2/01_animation_facade_animate_activity_log_.html#the-core-task-visualising-patient-flow",
    "href": "autodoc_v2/01_animation_facade_animate_activity_log_.html#the-core-task-visualising-patient-flow",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "Let’s imagine you’ve run a simulation of a simple clinic. Your simulation has produced a log detailing when patients arrived, when they started queuing for a nurse, when they began treatment, and when they left. You also have an idea of the physical layout – where the entrance is, where the waiting area is, and where the treatment cubicles are located.\nYour goal is to create an animation showing little icons representing patients moving through these stages over the simulated time. You want to see queues forming and shrinking, and patients occupying the treatment cubicles.\nThis is precisely the sort of task animate_activity_log is built for.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "autodoc_v2/01_animation_facade_animate_activity_log_.html#using-the-facade-animate_activity_log",
    "href": "autodoc_v2/01_animation_facade_animate_activity_log_.html#using-the-facade-animate_activity_log",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "To use animate_activity_log, you primarily need two key pieces of information, prepared as pandas DataFrames:\n\nevent_log: This DataFrame contains the raw output from your simulation. It lists events (like ‘arrival’, ‘start_queue’, ‘start_treatment’, ‘departure’) for each entity (e.g., patient), along with the time the event occurred. We’ll dive deep into the required format in Chapter 2: Event Log.\nevent_position_df: This DataFrame defines the layout of your animation. It maps each key event (or stage) in your process to specific X and Y coordinates on the animation canvas. Think of it as drawing a map for vidigi. More details can be found in Chapter 3: Layout Configuration (event_position_df).\n\nOptionally, you might also provide:\n\nscenario: A simple Python object (like an instance of a class) that holds information about resource capacities (e.g., number of nurses). This helps vidigi visualise the available resources correctly. We touch on resources, especially related to simpy, in Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store).\n\nLet’s look at a basic example call. Assume you have your event_log_df and event_position_df ready, and perhaps a scenario_config object.\nimport pandas as pd\nfrom vidigi.animation import animate_activity_log\n\n# Assume these DataFrames and object are already defined:\n# event_log_df: Your simulation output log (See Chapter 2)\n# event_position_df: Your layout coordinates (See Chapter 3)\n# scenario_config: An object with resource counts (e.g., scenario_config.n_nurses = 5)\n\n# --- Placeholder DataFrames (Replace with your actual data) ---\nevent_log_df = pd.DataFrame({\n    'patient': [1, 1, 1, 2, 2, 2, 1, 2],\n    'event_type': ['arrival_departure', 'queue', 'resource_use', 'arrival_departure', 'queue', 'resource_use', 'arrival_departure', 'arrival_departure'],\n    'event': ['arrival', 'wait_nurse', 'use_nurse', 'arrival', 'wait_nurse', 'use_nurse', 'depart', 'depart'],\n    'time': [0, 10, 15, 5, 12, 20, 35, 40],\n    'resource_id': [None, None, 1, None, None, 2, None, None], # Optional, needed for resource tracking\n    'pathway': ['Routine', 'Routine', 'Routine', 'Routine', 'Routine', 'Routine', 'Routine', 'Routine'] # Optional grouping\n})\n\nevent_position_df = pd.DataFrame({\n    'event': ['arrival', 'wait_nurse', 'use_nurse', 'depart'],\n    'x': [50, 150, 250, 350],\n    'y': [200, 200, 200, 200],\n    'label': ['Arrival', 'Waiting Area', 'Treatment Room', 'Departure'], # Human-readable labels\n    'resource': [None, None, 'n_nurses', None] # Link to scenario attribute for resource count\n})\n\n# --- Placeholder Scenario Object ---\nclass Scenario:\n    n_nurses = 2\nscenario_config = Scenario()\n# --- End Placeholder Data ---\n\n\n# Generate the animation\nanimation_figure = animate_activity_log(\n    event_log=event_log_df,\n    event_position_df=event_position_df,\n    scenario=scenario_config,\n    every_x_time_units=1, # Time interval between animation frames\n    limit_duration=50,    # Maximum simulation time to animate\n    time_display_units='dhm', # Format time as days/hours/minutes\n    icon_and_text_size=20,   # Adjust icon size\n    plotly_height=600,       # Set figure height\n    debug_mode=False         # Turn off verbose output\n)\n\n# To display the animation (e.g., in a Jupyter Notebook or save to HTML)\n# animation_figure.show()\n# animation_figure.write_html(\"my_clinic_animation.html\")\nThis single function call triggers the entire process. It takes your raw data and layout, performs the necessary calculations to determine entity positions at each time step, and produces an interactive Plotly Figure object. This figure contains the animated scatter plot showing your entities moving through the system.\nanimate_activity_log also accepts numerous optional parameters for customisation (like wrap_queues_at, add_background_image, frame_duration, etc.), allowing you to fine-tune the appearance and behaviour of the animation. You can explore these in the function’s documentation.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "autodoc_v2/01_animation_facade_animate_activity_log_.html#under-the-bonnet-how-animate_activity_log-works",
    "href": "autodoc_v2/01_animation_facade_animate_activity_log_.html#under-the-bonnet-how-animate_activity_log-works",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "So, what happens when you call animate_activity_log? It acts like a director, coordinating several backstage functions to prepare the data and generate the final animation. Here’s a step-by-step breakdown:\n\nInput Reception: animate_activity_log receives the event_log, event_position_df, scenario object, and any customisation parameters you’ve provided.\nSnapshot Preparation (Reshaping): It first calls the reshape_for_animations function (detailed in Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)). This function takes the raw event_log and transforms it. Instead of just listing when events occurred, it creates a “snapshot” DataFrame detailing the state (event/location) of every entity at regular time intervals (every_x_time_units).\nSnapshot Preparation (Positioning): Next, it passes the reshaped snapshot DataFrame and the event_position_df to the generate_animation_df function (also covered in Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)). This crucial step calculates the precise X, Y coordinates for each entity in each time snapshot, handling the layout of queues and the assignment of entities to specific resource instances (like nurse 1 vs. nurse 2). It also assigns visual icons (like emojis) to entities.\nAnimation Generation: Finally, the fully prepared DataFrame (containing entity IDs, icons, time snapshots, and exact X/Y coordinates) is passed to the generate_animation function along with the layout (event_position_df), scenario details, and customisation parameters (like figure size, background image, etc.). This function (explained in Chapter 6: Animation Generation (generate_animation)) uses Plotly Express to create the animated scatter plot, setting up the time slider, labels, resource visuals, and other graphical elements.\nReturn Figure: animate_activity_log returns the final Plotly Figure object created by generate_animation.\n\nWe can visualise this orchestration with a sequence diagram:\n\n\n\n\n\nsequenceDiagram\n    participant User\n    participant Facade as animate_activity_log\n    participant Reshaper as reshape_for_animations\n    participant PosGenerator as generate_animation_df\n    participant Animator as generate_animation\n\n    User-&gt;&gt;+Facade: Call animate_activity_log(event_log, pos_df, scenario, params...)\n    Facade-&gt;&gt;+Reshaper: Call reshape_for_animations(event_log, params...)\n    Reshaper--&gt;&gt;-Facade: Return snapshot_df\n    Facade-&gt;&gt;+PosGenerator: Call generate_animation_df(snapshot_df, pos_df, params...)\n    PosGenerator--&gt;&gt;-Facade: Return positioned_snapshot_df\n    Facade-&gt;&gt;+Animator: Call generate_animation(positioned_snapshot_df, pos_df, scenario, params...)\n    Animator--&gt;&gt;-Facade: Return plotly_figure\n    Facade--&gt;&gt;-User: Return plotly_figure\n\n\n\n\n\n\nLooking at the source code for animate_activity_log (simplified below), you can see this sequence clearly:\n# From: vidigi/animation.py\n\ndef animate_activity_log(\n        event_log,\n        event_position_df,\n        scenario=None,\n        # ... many other parameters ...\n        debug_mode=False,\n        custom_entity_icon_list=None\n        ):\n    \"\"\"\n    Generate an animated visualization of patient flow through a system.\n    (Docstring omitted for brevity)\n    \"\"\"\n    if debug_mode:\n        start_time_function = time.perf_counter()\n        print(f'Animation function called at {time.strftime(\"%H:%M:%S\", time.localtime())}')\n\n    # Step 1: Reshape the raw event log into time snapshots\n    full_patient_df = reshape_for_animations(\n        event_log,\n        # Pass relevant parameters like every_x_time_units, limit_duration etc.\n        every_x_time_units=every_x_time_units,\n        limit_duration=limit_duration,\n        step_snapshot_max=step_snapshot_max,\n        debug_mode=debug_mode\n    )\n\n    if debug_mode:\n        print(f'Reshaped animation dataframe finished construction at {time.strftime(\"%H:%M:%S\", time.localtime())}')\n\n    # Step 2: Calculate X, Y positions for each entity in each snapshot\n    full_patient_df_plus_pos = generate_animation_df(\n        full_patient_df=full_patient_df,\n        event_position_df=event_position_df,\n        # Pass relevant parameters like wrap_queues_at, gap_between_entities etc.\n        wrap_queues_at=wrap_queues_at,\n        wrap_resources_at=wrap_resources_at,\n        step_snapshot_max=step_snapshot_max,\n        gap_between_entities=gap_between_entities,\n        gap_between_resources=gap_between_resources,\n        gap_between_rows=gap_between_rows,\n        debug_mode=debug_mode,\n        custom_entity_icon_list=custom_entity_icon_list\n    )\n\n    # Step 3: Generate the Plotly animation figure using the positioned data\n    animation = generate_animation(\n        full_patient_df_plus_pos=full_patient_df_plus_pos,\n        event_position_df=event_position_df,\n        scenario=scenario,\n        # Pass relevant customization parameters like plotly_height, add_background_image etc.\n        plotly_height=plotly_height,\n        plotly_width=plotly_width,\n        include_play_button=include_play_button,\n        add_background_image=add_background_image,\n        # ... other parameters ...\n        debug_mode=debug_mode\n    )\n\n    if debug_mode:\n        end_time_function = time.perf_counter()\n        print(f'Total Time Elapsed: {(end_time_function - start_time_function):.2f} seconds')\n\n    # Step 4: Return the final figure\n    return animation\nBy wrapping these steps, animate_activity_log provides a convenient, high-level interface, shielding you from the internal complexities unless you specifically need to delve deeper or use the underlying functions individually.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "autodoc_v2/01_animation_facade_animate_activity_log_.html#conclusion",
    "href": "autodoc_v2/01_animation_facade_animate_activity_log_.html#conclusion",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "In this chapter, we’ve introduced animate_activity_log, the primary function for creating animations with vidigi. We’ve seen how it acts as a facade, taking your core simulation outputs (event_log) and layout instructions (event_position_df) to produce an animated Plotly figure by orchestrating several internal data preparation and plotting steps.\nThis “easy button” approach allows you to generate insightful visualisations quickly. However, understanding the data it requires is crucial. In the next chapter, we’ll focus on the heart of the input: the event_log.\nNext: Chapter 2: Event Log\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html",
    "href": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "In Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store), we learned how to make sure our simulation records which specific resource (like Cubicle 1 vs. Cubicle 2) each patient is using. This gives us a detailed Event Log, the script of our process. We also have our stage map, the Layout Configuration (event_position_df).\nBut how do we turn this script and map into an actual movie? A movie isn’t just a list of events; it’s a series of frames, or snapshots, showing where everyone is at specific moments in time. This chapter explores how vidigi prepares these snapshots.\n\n\nThink about the Event Log. It’s like a detailed diary:\n\n9:00 AM: Alice arrived.\n9:01 AM: Alice started waiting.\n9:15 AM: Alice started treatment (Cubicle 1).\n9:30 AM: Alice finished treatment.\n9:31 AM: Alice departed.\n\nThis tells us when things change. But an animation needs to show the state of the system at regular intervals, say, every 5 minutes. What was happening at 9:05 AM? What about 9:10 AM?\nWe need to transform our event-based diary into a “flipbook” where each page shows the location and status of everyone at a specific time (e.g., 9:00, 9:05, 9:10, 9:15…). This process involves two main steps, handled by two helper functions within vidigi:\n\nreshape_for_animations: Figures out who is doing what at each snapshot time. (Like sketching the characters and their basic activity on each flipbook page).\ngenerate_animation_df: Calculates the exact (X, Y) screen coordinates for each character on each page, arranging them neatly in queues or placing them at specific resource spots. (Like precisely positioning the sketches on the page according to layout rules).\n\nThese functions usually work behind the scenes when you call the main animate_activity_log function (the “Easy Button” from Chapter 1). You typically don’t need to call them yourself, but understanding them helps you see how the animation is built.\n\n\n\nGoal: To determine the status (event, event type, resource used) of every entity at regular time intervals.\nImagine you have your event log diary. reshape_for_animations acts like someone reading the diary and creating a summary for specific times. You tell it how often to take a snapshot using the every_x_time_units parameter (e.g., every_x_time_units=5 means take a snapshot every 5 minutes).\nHow it works (conceptually):\n\nLook at a Snapshot Time: It starts at time 0, then time 5, then time 10, and so on, up to a specified limit (limit_duration).\nFind Active Patients: For each snapshot time (say, minute 10), it looks at the Event Log to find all patients who have arrival time &lt;= 10 AND (depart time &gt;= 10 OR depart time is missing). These are the patients currently “in the system”.\nFind Latest Status: For each of these active patients, it finds the most recent event that happened at or before the current snapshot time (minute 10). For example, if Alice arrived at 0 and started waiting at 1, her status at minute 10 is still ‘start_wait’. If Bob arrived at 2 and started treatment (Resource 2) at 8, his status at minute 10 is ‘start_treat’ using Resource 2.\nRank Entities: If multiple patients are in the same state (e.g., multiple people waiting), it ranks them based on when they entered that state. This “rank” is important for positioning them later (e.g., first in line, second in line).\nRecord Snapshot: It records this information (patient ID, event, event type, resource ID if applicable, rank) for the current snapshot time.\nRepeat: It does this for every snapshot time interval.\nAdd Exit: It adds a final ‘exit’ event for each patient slightly after their last recorded event to make them disappear cleanly from the animation.\n\nInput: A simplified Event Log DataFrame:\n# event_log (from Chapter 2)\n#    patient       event_type        event  time  resource_id\n# 0        1  arrival_departure      arrival     0          NaN\n# 1        1              queue   start_wait     0          NaN\n# 2        1       resource_use  start_treat     5          1.0  # Used resource 1\n# 3        1  arrival_departure       depart    15          NaN\n# 4        2  arrival_departure      arrival     2          NaN\n# 5        2              queue   start_wait     2          NaN\n# 6        2       resource_use  start_treat     8          2.0  # Used resource 2\n# 7        2  arrival_departure       depart    20          NaN\nOutput: A “reshaped” DataFrame (let’s assume every_x_time_units=5):\n# Output of reshape_for_animations (simplified)\n#    minute  patient       event_type        event  resource_id  rank\n# 0       0        1  arrival_departure      arrival          NaN   1.0 # At minute 0, Patient 1 arrived\n# 1       0        1              queue   start_wait          NaN   1.0 # Immediately started waiting\n# 2       5        1       resource_use  start_treat          1.0   1.0 # At minute 5, Patient 1 started treatment (Resource 1)\n# 3       5        2              queue   start_wait          NaN   1.0 # At minute 5, Patient 2 was waiting (arrived at 2)\n# 4      10        1       resource_use  start_treat          1.0   1.0 # At minute 10, Patient 1 still treating\n# 5      10        2       resource_use  start_treat          2.0   1.0 # At minute 10, Patient 2 started treatment (Resource 2)\n# 6      15        1  arrival_departure       depart          NaN   1.0 # At minute 15, Patient 1 departed\n# 7      15        2       resource_use  start_treat          2.0   1.0 # At minute 15, Patient 2 still treating\n# 8      20        2  arrival_departure       depart          NaN   1.0 # At minute 20, Patient 2 departed\n# ... (plus added 'exit' events shortly after depart)\nNotice how this table tells us the state of both patients at each 5-minute interval (minute column). The rank column tells us their order within that state at that time (here, they are mostly alone in their state, so rank is 1.0).\n(Code Reference: The actual logic lives in the reshape_for_animations function within the vidigi/prep.py file.)\n\n\n\nGoal: To calculate the precise (X, Y) screen coordinates for every entity in every snapshot, based on their status and the layout rules.\nNow we have our flipbook pages sketched (reshape_for_animations output), but the characters are just listed, not positioned. generate_animation_df takes these sketches and the Layout Configuration (event_position_df) (our stage map) and figures out exactly where to draw everyone.\nHow it works (conceptually):\n\nTake a Snapshot Row: It looks at each row from the reshape_for_animations output (e.g., “At minute 5, Patient 2 was start_wait, rank 1.0”).\nFind Base Position: It looks up the event (‘start_wait’) in the Layout Configuration (event_position_df) to get the base anchor coordinates (e.g., X=200, Y=250 from Chapter 3’s example).\nApply Layout Rules:\n\nIf it’s a Queue (event_type == ‘queue’): It uses the patient’s rank (1.0 in this case) and parameters like wrap_queues_at and gap_between_entities to calculate an offset from the base (X, Y). Rank 1 might be right at the base (X=200), Rank 2 might be slightly to the left (X = 200 - gap_between_entities), and so on, potentially wrapping to a new row above.\nIf it’s Resource Use (event_type == ‘resource_use’): It uses the patient’s specific resource_id (e.g., Resource 1 or Resource 2 from the reshape_for_animations output) and parameters like wrap_resources_at and gap_between_resources to calculate the position relative to the base (X, Y) defined for that resource event in the layout. Resource 1 might be at (X - gap_between_resources * 1), Resource 2 at (X - gap_between_resources * 2), etc., potentially wrapping.\nIf it’s Arrival/Departure: It typically just uses the base (X, Y) directly.\n\nAssign Icon: It picks an icon (like an emoji 👩🏽‍⚕️, 👨‍💻, 🏭) for the patient, making sure each unique patient gets the same icon throughout the animation.\nRecord Final Position: It stores the calculated x_final, y_final, and icon along with the original snapshot information.\n\nInput:\n\nThe reshaped DataFrame from reshape_for_animations.\nThe Layout Configuration (event_position_df).\n\nOutput: The final “animation-ready” DataFrame. This contains everything needed to draw each frame: the time (minute), who (patient), their icon (icon), their exact position (x_final, y_final), and hover text (label).\n# Output of generate_animation_df (simplified, adding X/Y and icons)\n#    minute  patient       event_type        event  resource_id  rank  x_final  y_final      icon                       label\n# 0       0        1  arrival_departure      arrival          NaN   1.0     50.0    200.0       '🧔🏼'                  'Entrance' # At base X/Y for arrival\n# 1       0        1              queue   start_wait          NaN   1.0    200.0    250.0       '🧔🏼'              'Waiting Area' # At base X/Y for queue (rank 1)\n# 2       5        1       resource_use  start_treat          1.0   1.0    190.0    150.0       '🧔🏼'            'Treatment Bays' # Offset for resource 1 (base X=200, Y=150)\n# 3       5        2              queue   start_wait          NaN   1.0    200.0    250.0       '👨🏿‍🦯'              'Waiting Area' # At base X/Y for queue (rank 1)\n# 4      10        1       resource_use  start_treat          1.0   1.0    190.0    150.0       '🧔🏼'            'Treatment Bays' # Still at resource 1 spot\n# 5      10        2       resource_use  start_treat          2.0   1.0    180.0    150.0       '👨🏿‍🦯'            'Treatment Bays' # Offset for resource 2\n# 6      15        1  arrival_departure       depart          NaN   1.0    350.0    150.0       '🧔🏼'                 'Discharge' # At base X/Y for depart\n# 7      15        2       resource_use  start_treat          2.0   1.0    180.0    150.0       '👨🏿‍🦯'            'Treatment Bays' # Still at resource 2 spot\n# 8      20        2  arrival_departure       depart          NaN   1.0    350.0    150.0       '👨🏿‍🦯'                 'Discharge' # At base X/Y for depart\n# ... (plus 'exit' events)\nThis final table is the direct input for the animation engine itself.\n(Code Reference: The actual logic lives in the generate_animation_df function within the vidigi/prep.py file.)\n\n\n\nThe main animate_activity_log function orchestrates these two steps before creating the final animation:\n\n\n\n\n\nsequenceDiagram\n    participant User\n    participant AAL as animate_activity_log\n    participant RFA as reshape_for_animations\n    participant GAD as generate_animation_df\n    participant GA as generate_animation (Chapter 6)\n\n    User-&gt;&gt;AAL: Call with event_log, layout, options\n    AAL-&gt;&gt;RFA: Pass event_log, time interval (every_x_time_units)\n    RFA--&gt;&gt;AAL: Return reshaped_df (time slices)\n    AAL-&gt;&gt;GAD: Pass reshaped_df, layout, queue/resource rules\n    GAD--&gt;&gt;AAL: Return animation_df (with X, Y, icons)\n    AAL-&gt;&gt;GA: Pass animation_df, display options\n    GA--&gt;&gt;AAL: Return Plotly Figure\n    AAL--&gt;&gt;User: Return Plotly Figure\n\n\n\n\n\n\nFirst, reshape_for_animations processes the raw log into time slices. Then, generate_animation_df takes those slices and calculates the precise visual positions using the layout map.\n\n\n\nSnapshot preparation is the crucial data transformation stage in vidigi. It bridges the gap between the raw, event-based simulation log and the frame-by-frame data needed for animation.\n\nreshape_for_animations acts like a scribe, turning the event diary into a flipbook summary by figuring out who is doing what at regular time intervals.\ngenerate_animation_df acts like an artist, taking the flipbook summary and the stage map (event_position_df) to calculate the exact (X, Y) coordinates for every character on every page, respecting queueing and resource layout rules.\n\nTogether, they produce a detailed DataFrame where each row represents an entity at a specific time with a specific icon and screen position. This prepared data is now ready to be fed into the final animation engine.\nHow does vidigi take this final DataFrame and actually draw the moving pictures using Plotly? That’s what we’ll explore in the next chapter!\nNext up: Chapter 6: Animation Generation (generate_animation)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#from-diary-to-flipbook-the-need-for-snapshots",
    "href": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#from-diary-to-flipbook-the-need-for-snapshots",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Think about the Event Log. It’s like a detailed diary:\n\n9:00 AM: Alice arrived.\n9:01 AM: Alice started waiting.\n9:15 AM: Alice started treatment (Cubicle 1).\n9:30 AM: Alice finished treatment.\n9:31 AM: Alice departed.\n\nThis tells us when things change. But an animation needs to show the state of the system at regular intervals, say, every 5 minutes. What was happening at 9:05 AM? What about 9:10 AM?\nWe need to transform our event-based diary into a “flipbook” where each page shows the location and status of everyone at a specific time (e.g., 9:00, 9:05, 9:10, 9:15…). This process involves two main steps, handled by two helper functions within vidigi:\n\nreshape_for_animations: Figures out who is doing what at each snapshot time. (Like sketching the characters and their basic activity on each flipbook page).\ngenerate_animation_df: Calculates the exact (X, Y) screen coordinates for each character on each page, arranging them neatly in queues or placing them at specific resource spots. (Like precisely positioning the sketches on the page according to layout rules).\n\nThese functions usually work behind the scenes when you call the main animate_activity_log function (the “Easy Button” from Chapter 1). You typically don’t need to call them yourself, but understanding them helps you see how the animation is built.",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#step-1-creating-time-slices-reshape_for_animations",
    "href": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#step-1-creating-time-slices-reshape_for_animations",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Goal: To determine the status (event, event type, resource used) of every entity at regular time intervals.\nImagine you have your event log diary. reshape_for_animations acts like someone reading the diary and creating a summary for specific times. You tell it how often to take a snapshot using the every_x_time_units parameter (e.g., every_x_time_units=5 means take a snapshot every 5 minutes).\nHow it works (conceptually):\n\nLook at a Snapshot Time: It starts at time 0, then time 5, then time 10, and so on, up to a specified limit (limit_duration).\nFind Active Patients: For each snapshot time (say, minute 10), it looks at the Event Log to find all patients who have arrival time &lt;= 10 AND (depart time &gt;= 10 OR depart time is missing). These are the patients currently “in the system”.\nFind Latest Status: For each of these active patients, it finds the most recent event that happened at or before the current snapshot time (minute 10). For example, if Alice arrived at 0 and started waiting at 1, her status at minute 10 is still ‘start_wait’. If Bob arrived at 2 and started treatment (Resource 2) at 8, his status at minute 10 is ‘start_treat’ using Resource 2.\nRank Entities: If multiple patients are in the same state (e.g., multiple people waiting), it ranks them based on when they entered that state. This “rank” is important for positioning them later (e.g., first in line, second in line).\nRecord Snapshot: It records this information (patient ID, event, event type, resource ID if applicable, rank) for the current snapshot time.\nRepeat: It does this for every snapshot time interval.\nAdd Exit: It adds a final ‘exit’ event for each patient slightly after their last recorded event to make them disappear cleanly from the animation.\n\nInput: A simplified Event Log DataFrame:\n# event_log (from Chapter 2)\n#    patient       event_type        event  time  resource_id\n# 0        1  arrival_departure      arrival     0          NaN\n# 1        1              queue   start_wait     0          NaN\n# 2        1       resource_use  start_treat     5          1.0  # Used resource 1\n# 3        1  arrival_departure       depart    15          NaN\n# 4        2  arrival_departure      arrival     2          NaN\n# 5        2              queue   start_wait     2          NaN\n# 6        2       resource_use  start_treat     8          2.0  # Used resource 2\n# 7        2  arrival_departure       depart    20          NaN\nOutput: A “reshaped” DataFrame (let’s assume every_x_time_units=5):\n# Output of reshape_for_animations (simplified)\n#    minute  patient       event_type        event  resource_id  rank\n# 0       0        1  arrival_departure      arrival          NaN   1.0 # At minute 0, Patient 1 arrived\n# 1       0        1              queue   start_wait          NaN   1.0 # Immediately started waiting\n# 2       5        1       resource_use  start_treat          1.0   1.0 # At minute 5, Patient 1 started treatment (Resource 1)\n# 3       5        2              queue   start_wait          NaN   1.0 # At minute 5, Patient 2 was waiting (arrived at 2)\n# 4      10        1       resource_use  start_treat          1.0   1.0 # At minute 10, Patient 1 still treating\n# 5      10        2       resource_use  start_treat          2.0   1.0 # At minute 10, Patient 2 started treatment (Resource 2)\n# 6      15        1  arrival_departure       depart          NaN   1.0 # At minute 15, Patient 1 departed\n# 7      15        2       resource_use  start_treat          2.0   1.0 # At minute 15, Patient 2 still treating\n# 8      20        2  arrival_departure       depart          NaN   1.0 # At minute 20, Patient 2 departed\n# ... (plus added 'exit' events shortly after depart)\nNotice how this table tells us the state of both patients at each 5-minute interval (minute column). The rank column tells us their order within that state at that time (here, they are mostly alone in their state, so rank is 1.0).\n(Code Reference: The actual logic lives in the reshape_for_animations function within the vidigi/prep.py file.)",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#step-2-calculating-positions-generate_animation_df",
    "href": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#step-2-calculating-positions-generate_animation_df",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Goal: To calculate the precise (X, Y) screen coordinates for every entity in every snapshot, based on their status and the layout rules.\nNow we have our flipbook pages sketched (reshape_for_animations output), but the characters are just listed, not positioned. generate_animation_df takes these sketches and the Layout Configuration (event_position_df) (our stage map) and figures out exactly where to draw everyone.\nHow it works (conceptually):\n\nTake a Snapshot Row: It looks at each row from the reshape_for_animations output (e.g., “At minute 5, Patient 2 was start_wait, rank 1.0”).\nFind Base Position: It looks up the event (‘start_wait’) in the Layout Configuration (event_position_df) to get the base anchor coordinates (e.g., X=200, Y=250 from Chapter 3’s example).\nApply Layout Rules:\n\nIf it’s a Queue (event_type == ‘queue’): It uses the patient’s rank (1.0 in this case) and parameters like wrap_queues_at and gap_between_entities to calculate an offset from the base (X, Y). Rank 1 might be right at the base (X=200), Rank 2 might be slightly to the left (X = 200 - gap_between_entities), and so on, potentially wrapping to a new row above.\nIf it’s Resource Use (event_type == ‘resource_use’): It uses the patient’s specific resource_id (e.g., Resource 1 or Resource 2 from the reshape_for_animations output) and parameters like wrap_resources_at and gap_between_resources to calculate the position relative to the base (X, Y) defined for that resource event in the layout. Resource 1 might be at (X - gap_between_resources * 1), Resource 2 at (X - gap_between_resources * 2), etc., potentially wrapping.\nIf it’s Arrival/Departure: It typically just uses the base (X, Y) directly.\n\nAssign Icon: It picks an icon (like an emoji 👩🏽‍⚕️, 👨‍💻, 🏭) for the patient, making sure each unique patient gets the same icon throughout the animation.\nRecord Final Position: It stores the calculated x_final, y_final, and icon along with the original snapshot information.\n\nInput:\n\nThe reshaped DataFrame from reshape_for_animations.\nThe Layout Configuration (event_position_df).\n\nOutput: The final “animation-ready” DataFrame. This contains everything needed to draw each frame: the time (minute), who (patient), their icon (icon), their exact position (x_final, y_final), and hover text (label).\n# Output of generate_animation_df (simplified, adding X/Y and icons)\n#    minute  patient       event_type        event  resource_id  rank  x_final  y_final      icon                       label\n# 0       0        1  arrival_departure      arrival          NaN   1.0     50.0    200.0       '🧔🏼'                  'Entrance' # At base X/Y for arrival\n# 1       0        1              queue   start_wait          NaN   1.0    200.0    250.0       '🧔🏼'              'Waiting Area' # At base X/Y for queue (rank 1)\n# 2       5        1       resource_use  start_treat          1.0   1.0    190.0    150.0       '🧔🏼'            'Treatment Bays' # Offset for resource 1 (base X=200, Y=150)\n# 3       5        2              queue   start_wait          NaN   1.0    200.0    250.0       '👨🏿‍🦯'              'Waiting Area' # At base X/Y for queue (rank 1)\n# 4      10        1       resource_use  start_treat          1.0   1.0    190.0    150.0       '🧔🏼'            'Treatment Bays' # Still at resource 1 spot\n# 5      10        2       resource_use  start_treat          2.0   1.0    180.0    150.0       '👨🏿‍🦯'            'Treatment Bays' # Offset for resource 2\n# 6      15        1  arrival_departure       depart          NaN   1.0    350.0    150.0       '🧔🏼'                 'Discharge' # At base X/Y for depart\n# 7      15        2       resource_use  start_treat          2.0   1.0    180.0    150.0       '👨🏿‍🦯'            'Treatment Bays' # Still at resource 2 spot\n# 8      20        2  arrival_departure       depart          NaN   1.0    350.0    150.0       '👨🏿‍🦯'                 'Discharge' # At base X/Y for depart\n# ... (plus 'exit' events)\nThis final table is the direct input for the animation engine itself.\n(Code Reference: The actual logic lives in the generate_animation_df function within the vidigi/prep.py file.)",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#how-they-work-together",
    "href": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#how-they-work-together",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "The main animate_activity_log function orchestrates these two steps before creating the final animation:\n\n\n\n\n\nsequenceDiagram\n    participant User\n    participant AAL as animate_activity_log\n    participant RFA as reshape_for_animations\n    participant GAD as generate_animation_df\n    participant GA as generate_animation (Chapter 6)\n\n    User-&gt;&gt;AAL: Call with event_log, layout, options\n    AAL-&gt;&gt;RFA: Pass event_log, time interval (every_x_time_units)\n    RFA--&gt;&gt;AAL: Return reshaped_df (time slices)\n    AAL-&gt;&gt;GAD: Pass reshaped_df, layout, queue/resource rules\n    GAD--&gt;&gt;AAL: Return animation_df (with X, Y, icons)\n    AAL-&gt;&gt;GA: Pass animation_df, display options\n    GA--&gt;&gt;AAL: Return Plotly Figure\n    AAL--&gt;&gt;User: Return Plotly Figure\n\n\n\n\n\n\nFirst, reshape_for_animations processes the raw log into time slices. Then, generate_animation_df takes those slices and calculates the precise visual positions using the layout map.",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#conclusion",
    "href": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#conclusion",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Snapshot preparation is the crucial data transformation stage in vidigi. It bridges the gap between the raw, event-based simulation log and the frame-by-frame data needed for animation.\n\nreshape_for_animations acts like a scribe, turning the event diary into a flipbook summary by figuring out who is doing what at regular time intervals.\ngenerate_animation_df acts like an artist, taking the flipbook summary and the stage map (event_position_df) to calculate the exact (X, Y) coordinates for every character on every page, respecting queueing and resource layout rules.\n\nTogether, they produce a detailed DataFrame where each row represents an entity at a specific time with a specific icon and screen position. This prepared data is now ready to be fed into the final animation engine.\nHow does vidigi take this final DataFrame and actually draw the moving pictures using Plotly? That’s what we’ll explore in the next chapter!\nNext up: Chapter 6: Animation Generation (generate_animation)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html",
    "href": "03_layout_configuration_event_position_df_.html",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "In Chapter 2: Event Log, we learned about the event_log, which is like the detailed script telling vidigi what happened, when, and to whom. But just knowing the script isn’t enough to make a movie – you also need to know where the scenes take place! Where is the entrance? Where’s the waiting area? Where are the treatment rooms located on the screen?\nThat’s where the Layout Configuration, represented by the event_position_df DataFrame, comes in. It’s the blueprint or map for your animation’s background.\n\n\nImagine you’re setting up a stage play. You need to decide:\n\nWhere will actors enter? (Stage Left)\nWhere is the waiting bench? (Center Stage)\nWhere is the doctor’s office set piece? (Stage Right)\n\nWithout this plan, the actors wouldn’t know where to go, and the audience would be confused.\nSimilarly, vidigi needs a map to know where to place the icons representing your patients or entities on the screen. The event_position_df provides exactly this map. For every key step (event) in your process, it defines a specific (X, Y) coordinate on the animation screen.\n\n\n\nThe event_position_df is typically a pandas DataFrame – essentially a table. Each row in this table describes a specific location or stage in your process.\nHere are the essential columns you need in this table:\n\nevent: This column contains the exact name of the event from your Event Log that corresponds to this location. For example, 'arrival', 'start_wait', 'treatment_begins'. This is how vidigi links the location map to the event script.\nx: The horizontal coordinate (position from left to right) for this event’s base location on the screen.\ny: The vertical coordinate (position from top to bottom) for this event’s base location on the screen.\n\nThink of the (X, Y) coordinates as anchor points.\n\nFor queues (like 'start_wait'), patients will line up extending leftwards from this anchor point.\nFor resources (like 'treatment_begins'), the available resource slots (e.g., treatment beds) will be placed near this anchor point, usually extending leftwards too.\nFor arrivals and departures, patients will appear or disappear at this exact anchor point.\n\nYou’ll often include these helpful optional columns too:\n\nlabel: A human-readable name for the stage (like \"Arrival Area\", \"Waiting Room\", \"Treatment Bays\"). vidigi can display these labels on the animation to make it easier to understand.\nresource: This column links events associated with resource usage (like 'treatment_begins') to the name of the resource capacity defined in an external object (often called scenario). For example, if you have an event 'treatment_begins' and your scenario object says you have scenario.n_nurses = 5 nurses, you would put 'n_nurses' in the resource column for the 'treatment_begins' row. This tells vidigi how many resource slots to draw and manage for that step.\n\n\n\n\nLet’s create a basic event_position_df for the simple clinic example we’ve been using.\nimport pandas as pd\n\n# Create the layout DataFrame\nlayout_data = {\n    'event': ['arrival', 'start_wait', 'treatment_begins', 'depart', 'exit'], # Must match event names in the log!\n    'x': [50, 200, 200, 350, 350],  # Horizontal positions\n    'y': [200, 250, 150, 150, 50],   # Vertical positions\n    'label': ['Entrance', 'Waiting Area', 'Treatment Bays', 'Discharge', 'Exit Point'], # Human-friendly names\n    'resource': [None, None, 'n_cubicles', None, None] # Link 'treatment_begins' to the number of cubicles\n}\nmy_layout = pd.DataFrame(layout_data)\n\nprint(my_layout)\n-*Output:**\n              event    x    y             label   resource\n0           arrival   50  200          Entrance       None\n1        start_wait  200  250      Waiting Area       None\n2  treatment_begins  200  150    Treatment Bays n_cubicles  # This step uses 'n_cubicles' resources\n3            depart  350  150         Discharge       None\n4              exit  350   50        Exit Point       None\nLet’s break this down:\n\nRow 0: Anyone recorded with the event ‘arrival’ in the log will appear at coordinates (X=50, Y=200). This spot will be labelled “Entrance”.\nRow 1: When a patient’s event becomes ‘start_wait’, they move towards (X=200, Y=250). If others are already waiting, they’ll queue up extending to the left from this point. This area is labelled “Waiting Area”.\nRow 2: When a patient’s event is ‘treatment_begins’, they move towards (X=200, Y=150). Because this row has 'n_cubicles' in the resource column, vidigi knows this involves using a resource. It will look up how many n_cubicles are available (from the scenario object you provide) and place the patient icon in the correct cubicle slot near (200, 150). This area is labelled “Treatment Bays”.\nRow 3 & 4: Patients move to (350, 150) for ‘depart’ and finally vanish at the ‘exit’ point (350, 50).\n\n-(Note: We added an ‘exit’ event here, which wasn’t in the Chapter 2 log but is often added automatically by vidigi’s internal processing to ensure entities cleanly leave the screen).*\n\n\n\nYou provide this event_position_df (our my_layout variable) directly to the main animate_activity_log function:\n# (Assuming my_event_log and scenario_details from Chapter 1 & 2 exist)\nfrom vidigi.animation import animate_activity_log\n\n# --- Our layout from above ---\n# my_layout = pd.DataFrame(...)\n\n# --- Pretend we have these ---\n# my_event_log = pd.DataFrame(...) from Chapter 2\n# class SimpleScenario: n_cubicles = 2 # From Chapter 1 layout example\n# scenario_details = SimpleScenario()\n\n# --- Call the animation function ---\nmy_animation = animate_activity_log(\n    event_log=my_event_log,\n    event_position_df=my_layout,  # &lt;-- Pass the layout here!\n    scenario=scenario_details,   # &lt;-- Needed for resource counts ('n_cubicles')\n    # ... other options like time_display_units, icon_size etc.\n)\n\n# my_animation.show()\nWhen you run this, vidigi uses my_layout to determine where to draw everything. Patients arrive near (50, 200), queue leftwards from (200, 250), occupy one of the (in this case 2) treatment slots near (200, 150), and then depart via (350, 150) and (350, 50).\n\n\n\nYou don’t usually need to worry about the deep internals, but it helps to understand the basics. When animate_activity_log needs to figure out the exact position of every patient at every snapshot in time, it uses a helper function called generate_animation_df.\nHere’s a simplified idea of what generate_animation_df does:\n\nGet Base Position: For a patient P whose current event is, say, 'start_wait' at time T, it looks up 'start_wait' in the event_position_df to find the base coordinates (e.g., X=200, Y=250).\nHandle Queues: If the event_type is 'queue', it checks how many other patients are also in the 'start_wait' state at time T. It calculates an offset (usually moving left and wrapping to new rows if needed) from the base (X, Y) based on the patient’s position in the queue.\nHandle Resources: If the event_type is 'resource_use' (like 'treatment_begins'), it checks the resource column in event_position_df (e.g., 'n_cubicles'). It then asks the scenario object, “How many n_cubicles are there?”. It also looks at the patient’s specific resource_id from the event log (e.g., they are using cubicle 1). It then calculates the exact position for cubicle 1 relative to the base (X, Y) for 'treatment_begins'.\nAssign Final Position: It stores these calculated (X, Y) coordinates for patient P at time T.\n\nThis process repeats for every patient at every time snapshot.\nHere’s a simplified diagram showing the interaction:\n\n\n\n\n\nsequenceDiagram\n    participant AAL as animate_activity_log\n    participant GAD as generate_animation_df\n    participant Layout as event_position_df (The Blueprint)\n    participant Log as Event Log\n    participant Scenario as scenario object\n\n    AAL-&gt;&gt;GAD: Calculate positions for all patients at all times\n    GAD-&gt;&gt;Log: Get patient P's event & resource_id at time T\n    GAD-&gt;&gt;Layout: Get base (x, y) & resource name for event\n    alt Event is Resource Use\n        GAD-&gt;&gt;Scenario: Get total count for resource name\n        GAD-&gt;&gt;GAD: Calculate position based on base(x,y), resource_id, total count\n    else Event is Queue\n        GAD-&gt;&gt;GAD: Calculate queue position offset from base(x,y)\n    else Event is Arrival/Depart\n        GAD-&gt;&gt;GAD: Use base(x,y) directly\n    end\n    GAD--&gt;&gt;AAL: Return DataFrame with calculated positions\n\n\n\n\n\n\n\n\n\n\nMatch Event Names: The event names in event_position_df must exactly match the event names used in your event_log.\nCoordinates are Anchors: Remember (X, Y) are often the bottom-right anchor for queues and resources, which typically extend leftwards and potentially upwards in rows.\nUse setup_mode: When first creating your layout, pass setup_mode=True to animate_activity_log. This will display grid lines and coordinate axes on the animation, making it much easier to figure out good X and Y values!\nIterate: Getting the layout perfect often takes a few tries. Run the animation, see how it looks, adjust the X/Y values in your DataFrame, and run it again.\n\n\n\n\nThe event_position_df is your essential blueprint for the visual layout of your vidigi animation. It’s a simple table (DataFrame) that tells vidigi the base (X, Y) coordinates for each key event, allows you to add descriptive labels, and connects resource-using events to their capacities defined in a scenario object. By carefully crafting this layout, you control where queues form, where resources are located, and how entities move across the screen, turning your raw event data into an understandable visual story.\nNow that we understand the script (event_log) and the stage map (event_position_df), we need to look closer at the actors that use specific props – the resources. How does vidigi handle knowing exactly which cubicle or which nurse a patient is using? That involves enhancing how we define and use resources in our simulation model, which is the topic of our next chapter.\nNext up: Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#setting-the-stage-why-we-need-a-layout",
    "href": "03_layout_configuration_event_position_df_.html#setting-the-stage-why-we-need-a-layout",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "Imagine you’re setting up a stage play. You need to decide:\n\nWhere will actors enter? (Stage Left)\nWhere is the waiting bench? (Center Stage)\nWhere is the doctor’s office set piece? (Stage Right)\n\nWithout this plan, the actors wouldn’t know where to go, and the audience would be confused.\nSimilarly, vidigi needs a map to know where to place the icons representing your patients or entities on the screen. The event_position_df provides exactly this map. For every key step (event) in your process, it defines a specific (X, Y) coordinate on the animation screen.",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#what-does-the-layout-blueprint-look-like",
    "href": "03_layout_configuration_event_position_df_.html#what-does-the-layout-blueprint-look-like",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "The event_position_df is typically a pandas DataFrame – essentially a table. Each row in this table describes a specific location or stage in your process.\nHere are the essential columns you need in this table:\n\nevent: This column contains the exact name of the event from your Event Log that corresponds to this location. For example, 'arrival', 'start_wait', 'treatment_begins'. This is how vidigi links the location map to the event script.\nx: The horizontal coordinate (position from left to right) for this event’s base location on the screen.\ny: The vertical coordinate (position from top to bottom) for this event’s base location on the screen.\n\nThink of the (X, Y) coordinates as anchor points.\n\nFor queues (like 'start_wait'), patients will line up extending leftwards from this anchor point.\nFor resources (like 'treatment_begins'), the available resource slots (e.g., treatment beds) will be placed near this anchor point, usually extending leftwards too.\nFor arrivals and departures, patients will appear or disappear at this exact anchor point.\n\nYou’ll often include these helpful optional columns too:\n\nlabel: A human-readable name for the stage (like \"Arrival Area\", \"Waiting Room\", \"Treatment Bays\"). vidigi can display these labels on the animation to make it easier to understand.\nresource: This column links events associated with resource usage (like 'treatment_begins') to the name of the resource capacity defined in an external object (often called scenario). For example, if you have an event 'treatment_begins' and your scenario object says you have scenario.n_nurses = 5 nurses, you would put 'n_nurses' in the resource column for the 'treatment_begins' row. This tells vidigi how many resource slots to draw and manage for that step.",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#a-simple-blueprint-example",
    "href": "03_layout_configuration_event_position_df_.html#a-simple-blueprint-example",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "Let’s create a basic event_position_df for the simple clinic example we’ve been using.\nimport pandas as pd\n\n# Create the layout DataFrame\nlayout_data = {\n    'event': ['arrival', 'start_wait', 'treatment_begins', 'depart', 'exit'], # Must match event names in the log!\n    'x': [50, 200, 200, 350, 350],  # Horizontal positions\n    'y': [200, 250, 150, 150, 50],   # Vertical positions\n    'label': ['Entrance', 'Waiting Area', 'Treatment Bays', 'Discharge', 'Exit Point'], # Human-friendly names\n    'resource': [None, None, 'n_cubicles', None, None] # Link 'treatment_begins' to the number of cubicles\n}\nmy_layout = pd.DataFrame(layout_data)\n\nprint(my_layout)\n-*Output:**\n              event    x    y             label   resource\n0           arrival   50  200          Entrance       None\n1        start_wait  200  250      Waiting Area       None\n2  treatment_begins  200  150    Treatment Bays n_cubicles  # This step uses 'n_cubicles' resources\n3            depart  350  150         Discharge       None\n4              exit  350   50        Exit Point       None\nLet’s break this down:\n\nRow 0: Anyone recorded with the event ‘arrival’ in the log will appear at coordinates (X=50, Y=200). This spot will be labelled “Entrance”.\nRow 1: When a patient’s event becomes ‘start_wait’, they move towards (X=200, Y=250). If others are already waiting, they’ll queue up extending to the left from this point. This area is labelled “Waiting Area”.\nRow 2: When a patient’s event is ‘treatment_begins’, they move towards (X=200, Y=150). Because this row has 'n_cubicles' in the resource column, vidigi knows this involves using a resource. It will look up how many n_cubicles are available (from the scenario object you provide) and place the patient icon in the correct cubicle slot near (200, 150). This area is labelled “Treatment Bays”.\nRow 3 & 4: Patients move to (350, 150) for ‘depart’ and finally vanish at the ‘exit’ point (350, 50).\n\n-(Note: We added an ‘exit’ event here, which wasn’t in the Chapter 2 log but is often added automatically by vidigi’s internal processing to ensure entities cleanly leave the screen).*",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#using-the-blueprint",
    "href": "03_layout_configuration_event_position_df_.html#using-the-blueprint",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "You provide this event_position_df (our my_layout variable) directly to the main animate_activity_log function:\n# (Assuming my_event_log and scenario_details from Chapter 1 & 2 exist)\nfrom vidigi.animation import animate_activity_log\n\n# --- Our layout from above ---\n# my_layout = pd.DataFrame(...)\n\n# --- Pretend we have these ---\n# my_event_log = pd.DataFrame(...) from Chapter 2\n# class SimpleScenario: n_cubicles = 2 # From Chapter 1 layout example\n# scenario_details = SimpleScenario()\n\n# --- Call the animation function ---\nmy_animation = animate_activity_log(\n    event_log=my_event_log,\n    event_position_df=my_layout,  # &lt;-- Pass the layout here!\n    scenario=scenario_details,   # &lt;-- Needed for resource counts ('n_cubicles')\n    # ... other options like time_display_units, icon_size etc.\n)\n\n# my_animation.show()\nWhen you run this, vidigi uses my_layout to determine where to draw everything. Patients arrive near (50, 200), queue leftwards from (200, 250), occupy one of the (in this case 2) treatment slots near (200, 150), and then depart via (350, 150) and (350, 50).",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#how-vidigi-reads-the-blueprint-under-the-hood",
    "href": "03_layout_configuration_event_position_df_.html#how-vidigi-reads-the-blueprint-under-the-hood",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "You don’t usually need to worry about the deep internals, but it helps to understand the basics. When animate_activity_log needs to figure out the exact position of every patient at every snapshot in time, it uses a helper function called generate_animation_df.\nHere’s a simplified idea of what generate_animation_df does:\n\nGet Base Position: For a patient P whose current event is, say, 'start_wait' at time T, it looks up 'start_wait' in the event_position_df to find the base coordinates (e.g., X=200, Y=250).\nHandle Queues: If the event_type is 'queue', it checks how many other patients are also in the 'start_wait' state at time T. It calculates an offset (usually moving left and wrapping to new rows if needed) from the base (X, Y) based on the patient’s position in the queue.\nHandle Resources: If the event_type is 'resource_use' (like 'treatment_begins'), it checks the resource column in event_position_df (e.g., 'n_cubicles'). It then asks the scenario object, “How many n_cubicles are there?”. It also looks at the patient’s specific resource_id from the event log (e.g., they are using cubicle 1). It then calculates the exact position for cubicle 1 relative to the base (X, Y) for 'treatment_begins'.\nAssign Final Position: It stores these calculated (X, Y) coordinates for patient P at time T.\n\nThis process repeats for every patient at every time snapshot.\nHere’s a simplified diagram showing the interaction:\n\n\n\n\n\nsequenceDiagram\n    participant AAL as animate_activity_log\n    participant GAD as generate_animation_df\n    participant Layout as event_position_df (The Blueprint)\n    participant Log as Event Log\n    participant Scenario as scenario object\n\n    AAL-&gt;&gt;GAD: Calculate positions for all patients at all times\n    GAD-&gt;&gt;Log: Get patient P's event & resource_id at time T\n    GAD-&gt;&gt;Layout: Get base (x, y) & resource name for event\n    alt Event is Resource Use\n        GAD-&gt;&gt;Scenario: Get total count for resource name\n        GAD-&gt;&gt;GAD: Calculate position based on base(x,y), resource_id, total count\n    else Event is Queue\n        GAD-&gt;&gt;GAD: Calculate queue position offset from base(x,y)\n    else Event is Arrival/Depart\n        GAD-&gt;&gt;GAD: Use base(x,y) directly\n    end\n    GAD--&gt;&gt;AAL: Return DataFrame with calculated positions",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#tips-for-setting-up-your-layout",
    "href": "03_layout_configuration_event_position_df_.html#tips-for-setting-up-your-layout",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "Match Event Names: The event names in event_position_df must exactly match the event names used in your event_log.\nCoordinates are Anchors: Remember (X, Y) are often the bottom-right anchor for queues and resources, which typically extend leftwards and potentially upwards in rows.\nUse setup_mode: When first creating your layout, pass setup_mode=True to animate_activity_log. This will display grid lines and coordinate axes on the animation, making it much easier to figure out good X and Y values!\nIterate: Getting the layout perfect often takes a few tries. Run the animation, see how it looks, adjust the X/Y values in your DataFrame, and run it again.",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#conclusion",
    "href": "03_layout_configuration_event_position_df_.html#conclusion",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "The event_position_df is your essential blueprint for the visual layout of your vidigi animation. It’s a simple table (DataFrame) that tells vidigi the base (X, Y) coordinates for each key event, allows you to add descriptive labels, and connects resource-using events to their capacities defined in a scenario object. By carefully crafting this layout, you control where queues form, where resources are located, and how entities move across the screen, turning your raw event data into an understandable visual story.\nNow that we understand the script (event_log) and the stage map (event_position_df), we need to look closer at the actors that use specific props – the resources. How does vidigi handle knowing exactly which cubicle or which nurse a patient is using? That involves enhancing how we define and use resources in our simulation model, which is the topic of our next chapter.\nNext up: Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "01_animation_facade_animate_activity_log_.html",
    "href": "01_animation_facade_animate_activity_log_.html",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "Welcome to vidigi! If you’ve ever watched a simulation of people moving through a hospital, a queue at a shop, or any process, you know how helpful visualizations can be. vidigi is designed to help you create exactly those kinds of animations from your process data.\nBut creating animations can seem complicated, right? You need to track where everyone is at every moment, figure out their positions on the screen, and then stitch it all together. It sounds like a lot of work!\nThat’s where animate_activity_log comes in. Think of it as the “Easy Button” for creating your vidigi animations.\n\n\nImagine you’re directing a movie. You have actors (your data points, like patients), a script (the sequence of events), and a set (the layout on the screen). As the director, you don’t need to personally handle the camera, the lighting, and the sound – you coordinate specialists who do that.\nanimate_activity_log is like that director. It’s the main, high-level function you’ll usually interact with. You give it the raw information:\n\nWhat happened? The sequence of events (like patient arrivals, waiting, treatment). This is called the Event Log.\nWhere should things be? The layout or map showing where different activities (like the waiting room or treatment cubicle) appear on the screen. This is the Layout Configuration (event_position_df).\nOptional Details: Extra information, like how many nurses are available (we call this scenario info), and how you want the animation to look (speed, icons, background image, etc.).\n\nYou provide these inputs, and animate_activity_log coordinates all the underlying steps needed to produce the final, animated movie (a Plotly figure). It simplifies the whole process for you!\n\n\n\nLet’s say you have your data ready in two tables (we’ll learn how to make these in later chapters!):\n\nmy_event_log: A table listing every time a patient arrived, started waiting, got treated, etc.\nmy_layout: A table defining the (x, y) coordinates on the screen for “Arrival”, “Waiting Area”, “Treatment Room”, and “Exit”.\n\nUsing animate_activity_log is straightforward:\n# Import the function first\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd # We'll use pandas DataFrames\n\n# --- Pretend we have these already ---\n# (Chapters 2 & 3 will show how to create these!)\nmy_event_log = pd.DataFrame({ # A simplified example log\n    'patient': [1, 1, 1, 1, 2, 2, 2, 2],\n    'event': ['arrival', 'start_wait', 'start_treat', 'depart',\n              'arrival', 'start_wait', 'start_treat', 'depart'],\n    'time': [0, 0, 5, 15, 2, 2, 8, 20],\n    # ... other columns needed like event_type, pathway, resource_id ...\n    'event_type': ['arrival_departure','queue','resource_use','arrival_departure',\n                   'arrival_departure','queue','resource_use','arrival_departure'],\n    'pathway': ['A','A','A','A', 'A','A','A','A'],\n    'resource_id': [None, None, 1, None, None, None, 2, None],\n    'run': [1,1,1,1, 1,1,1,1]\n})\n\nmy_layout = pd.DataFrame({ # A simplified example layout\n    'event': ['arrival', 'start_wait', 'start_treat', 'depart'],\n    'x': [10, 50, 100, 150],\n    'y': [50, 50, 50, 50],\n    'label': ['Arrival', 'Waiting', 'Treatment', 'Exit'], # Human-readable names\n    'resource': [None, None, 'treatment_rooms', None] # Link resource events to capacity\n})\n\n# --- A simple scenario object (optional) ---\nclass SimpleScenario:\n    treatment_rooms = 2 # Let's say we have 2 treatment rooms\nscenario_details = SimpleScenario()\n\n# --- Now, the magic happens! ---\n# Call the \"Easy Button\" function\nmy_animation = animate_activity_log(\n    event_log=my_event_log,          # What happened?\n    event_position_df=my_layout,     # Where should things be?\n    scenario=scenario_details,       # How many resources? (Optional)\n    time_display_units='dhm',        # Show time as days/hours/mins\n    icon_and_text_size=20,           # Make icons a bit smaller\n    every_x_time_units=1             # Take a snapshot every 1 time unit\n)\n\n# You can now display the animation (e.g., in a Jupyter Notebook)\n# my_animation.show() # This would pop up the interactive animation\nWhat happens when you run this?\nYou don’t get numbers or text back directly. Instead, my_animation holds an interactive Plotly animation object. If you were running this in a tool like a Jupyter Notebook and called my_animation.show(), you’d see an animation appear, showing little icons (representing patients) moving from the ‘Arrival’ location, possibly waiting at ‘Waiting’, moving to ‘Treatment’, and finally leaving via ‘Exit’, all synchronized with the times in my_event_log.\n\n\n\nanimate_activity_log acts like our movie director, but it relies on a crew of helper functions to do the actual work. Here’s a simplified view of the steps it takes internally when you call it:\n\nSnapshot Prep (Act 1): The raw event_log tells us when things change, but an animation needs to know where everyone is at regular intervals (like every minute, or every 10 minutes). animate_activity_log first calls helper functions (reshape_for_animations) to process the event log and figure out the status (location or activity) of every patient at each “snapshot” time.\nPosition Calculation (Act 2): Knowing a patient is “Waiting” isn’t enough for the animation; we need exact (x, y) screen coordinates. animate_activity_log uses another helper (generate_animation_df) along with your event_position_df (the layout) to calculate the precise (x, y) position for every patient in every snapshot, handling things like arranging patients neatly in queues or assigning them to specific resource slots (like Treatment Room 1 vs. Treatment Room 2).\nAnimation Generation (The Final Cut): With the fully prepared data frame containing patient IDs, icons, and precise (x, y) coordinates for every time snapshot, animate_activity_log calls the final specialist function (generate_animation). This function takes all that prepared data and uses the Plotly library to build the actual interactive animation figure, complete with a timeline slider, play/pause buttons, and tooltips.\n\nHere’s a diagram showing that flow:\n\n\n\n\n\nsequenceDiagram\n    participant U as User\n    participant AAL as animate_activity_log (The Director)\n    participant RFA as reshape_for_animations (Snapshot Prep)\n    participant GAD as generate_animation_df (Position Calc)\n    participant GA as generate_animation (Animation Builder)\n    participant PFig as Plotly Figure (The Movie)\n\n    U-&gt;&gt;AAL: Call with event_log, layout, options\n    AAL-&gt;&gt;RFA: Process event_log for snapshots\n    RFA--&gt;&gt;AAL: Return snapshot data\n    AAL-&gt;&gt;GAD: Calculate (x, y) positions using snapshot data & layout\n    GAD--&gt;&gt;AAL: Return data with positions\n    AAL-&gt;&gt;GA: Generate animation using positioned data & options\n    GA--&gt;&gt;AAL: Return Plotly animation object\n    AAL--&gt;&gt;U: Return Plotly Figure\n\n\n\n\n\n\nEssentially, animate_activity_log orchestrates calls to these more specialized functions, which you can explore in later chapters:\n\nSnapshot Preparation (reshape_for_animations & generate_animation_df)\nAnimation Generation (generate_animation)\n\nYou can call these functions individually if you need very fine-grained control, but for most uses, the animate_activity_log facade is the way to go!\n\n\n\nWhile we used basic options above, animate_activity_log has many parameters to customize your animation:\n\nevery_x_time_units: How often to take a snapshot (smaller numbers = smoother but potentially slower animation).\nicon_and_text_size: Controls the size of the patient icons and any labels.\nadd_background_image: You can overlay the animation on a floor plan or diagram!\ntime_display_units: Show time as simple numbers, or format it like ‘Days:Hours:Minutes’.\nframe_duration / frame_transition_duration: Control the speed of the animation playback.\nwrap_queues_at: How many patients to show in a line before starting a new row in a queue.\n\n…and many more! Check the function’s documentation for all the possibilities.\n\n\n\nYou’ve now met animate_activity_log, the main entry point and “easy button” for creating process animations with vidigi. It acts as a facade, hiding the complexity of data preparation and animation generation by coordinating specialized helper functions. You provide the raw event data and layout information, and it delivers the final animated visualization.\nBut how do we get that crucial event_log data in the first place? That’s exactly what we’ll cover in the next chapter!\nNext up: Chapter 2: Event Log\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "01_animation_facade_animate_activity_log_.html#the-easy-button-concept",
    "href": "01_animation_facade_animate_activity_log_.html#the-easy-button-concept",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "Imagine you’re directing a movie. You have actors (your data points, like patients), a script (the sequence of events), and a set (the layout on the screen). As the director, you don’t need to personally handle the camera, the lighting, and the sound – you coordinate specialists who do that.\nanimate_activity_log is like that director. It’s the main, high-level function you’ll usually interact with. You give it the raw information:\n\nWhat happened? The sequence of events (like patient arrivals, waiting, treatment). This is called the Event Log.\nWhere should things be? The layout or map showing where different activities (like the waiting room or treatment cubicle) appear on the screen. This is the Layout Configuration (event_position_df).\nOptional Details: Extra information, like how many nurses are available (we call this scenario info), and how you want the animation to look (speed, icons, background image, etc.).\n\nYou provide these inputs, and animate_activity_log coordinates all the underlying steps needed to produce the final, animated movie (a Plotly figure). It simplifies the whole process for you!",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "01_animation_facade_animate_activity_log_.html#how-to-use-animate_activity_log-a-simple-example",
    "href": "01_animation_facade_animate_activity_log_.html#how-to-use-animate_activity_log-a-simple-example",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "Let’s say you have your data ready in two tables (we’ll learn how to make these in later chapters!):\n\nmy_event_log: A table listing every time a patient arrived, started waiting, got treated, etc.\nmy_layout: A table defining the (x, y) coordinates on the screen for “Arrival”, “Waiting Area”, “Treatment Room”, and “Exit”.\n\nUsing animate_activity_log is straightforward:\n# Import the function first\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd # We'll use pandas DataFrames\n\n# --- Pretend we have these already ---\n# (Chapters 2 & 3 will show how to create these!)\nmy_event_log = pd.DataFrame({ # A simplified example log\n    'patient': [1, 1, 1, 1, 2, 2, 2, 2],\n    'event': ['arrival', 'start_wait', 'start_treat', 'depart',\n              'arrival', 'start_wait', 'start_treat', 'depart'],\n    'time': [0, 0, 5, 15, 2, 2, 8, 20],\n    # ... other columns needed like event_type, pathway, resource_id ...\n    'event_type': ['arrival_departure','queue','resource_use','arrival_departure',\n                   'arrival_departure','queue','resource_use','arrival_departure'],\n    'pathway': ['A','A','A','A', 'A','A','A','A'],\n    'resource_id': [None, None, 1, None, None, None, 2, None],\n    'run': [1,1,1,1, 1,1,1,1]\n})\n\nmy_layout = pd.DataFrame({ # A simplified example layout\n    'event': ['arrival', 'start_wait', 'start_treat', 'depart'],\n    'x': [10, 50, 100, 150],\n    'y': [50, 50, 50, 50],\n    'label': ['Arrival', 'Waiting', 'Treatment', 'Exit'], # Human-readable names\n    'resource': [None, None, 'treatment_rooms', None] # Link resource events to capacity\n})\n\n# --- A simple scenario object (optional) ---\nclass SimpleScenario:\n    treatment_rooms = 2 # Let's say we have 2 treatment rooms\nscenario_details = SimpleScenario()\n\n# --- Now, the magic happens! ---\n# Call the \"Easy Button\" function\nmy_animation = animate_activity_log(\n    event_log=my_event_log,          # What happened?\n    event_position_df=my_layout,     # Where should things be?\n    scenario=scenario_details,       # How many resources? (Optional)\n    time_display_units='dhm',        # Show time as days/hours/mins\n    icon_and_text_size=20,           # Make icons a bit smaller\n    every_x_time_units=1             # Take a snapshot every 1 time unit\n)\n\n# You can now display the animation (e.g., in a Jupyter Notebook)\n# my_animation.show() # This would pop up the interactive animation\nWhat happens when you run this?\nYou don’t get numbers or text back directly. Instead, my_animation holds an interactive Plotly animation object. If you were running this in a tool like a Jupyter Notebook and called my_animation.show(), you’d see an animation appear, showing little icons (representing patients) moving from the ‘Arrival’ location, possibly waiting at ‘Waiting’, moving to ‘Treatment’, and finally leaving via ‘Exit’, all synchronized with the times in my_event_log.",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "01_animation_facade_animate_activity_log_.html#whats-happening-under-the-hood",
    "href": "01_animation_facade_animate_activity_log_.html#whats-happening-under-the-hood",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "animate_activity_log acts like our movie director, but it relies on a crew of helper functions to do the actual work. Here’s a simplified view of the steps it takes internally when you call it:\n\nSnapshot Prep (Act 1): The raw event_log tells us when things change, but an animation needs to know where everyone is at regular intervals (like every minute, or every 10 minutes). animate_activity_log first calls helper functions (reshape_for_animations) to process the event log and figure out the status (location or activity) of every patient at each “snapshot” time.\nPosition Calculation (Act 2): Knowing a patient is “Waiting” isn’t enough for the animation; we need exact (x, y) screen coordinates. animate_activity_log uses another helper (generate_animation_df) along with your event_position_df (the layout) to calculate the precise (x, y) position for every patient in every snapshot, handling things like arranging patients neatly in queues or assigning them to specific resource slots (like Treatment Room 1 vs. Treatment Room 2).\nAnimation Generation (The Final Cut): With the fully prepared data frame containing patient IDs, icons, and precise (x, y) coordinates for every time snapshot, animate_activity_log calls the final specialist function (generate_animation). This function takes all that prepared data and uses the Plotly library to build the actual interactive animation figure, complete with a timeline slider, play/pause buttons, and tooltips.\n\nHere’s a diagram showing that flow:\n\n\n\n\n\nsequenceDiagram\n    participant U as User\n    participant AAL as animate_activity_log (The Director)\n    participant RFA as reshape_for_animations (Snapshot Prep)\n    participant GAD as generate_animation_df (Position Calc)\n    participant GA as generate_animation (Animation Builder)\n    participant PFig as Plotly Figure (The Movie)\n\n    U-&gt;&gt;AAL: Call with event_log, layout, options\n    AAL-&gt;&gt;RFA: Process event_log for snapshots\n    RFA--&gt;&gt;AAL: Return snapshot data\n    AAL-&gt;&gt;GAD: Calculate (x, y) positions using snapshot data & layout\n    GAD--&gt;&gt;AAL: Return data with positions\n    AAL-&gt;&gt;GA: Generate animation using positioned data & options\n    GA--&gt;&gt;AAL: Return Plotly animation object\n    AAL--&gt;&gt;U: Return Plotly Figure\n\n\n\n\n\n\nEssentially, animate_activity_log orchestrates calls to these more specialized functions, which you can explore in later chapters:\n\nSnapshot Preparation (reshape_for_animations & generate_animation_df)\nAnimation Generation (generate_animation)\n\nYou can call these functions individually if you need very fine-grained control, but for most uses, the animate_activity_log facade is the way to go!",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "01_animation_facade_animate_activity_log_.html#key-customization-options",
    "href": "01_animation_facade_animate_activity_log_.html#key-customization-options",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "While we used basic options above, animate_activity_log has many parameters to customize your animation:\n\nevery_x_time_units: How often to take a snapshot (smaller numbers = smoother but potentially slower animation).\nicon_and_text_size: Controls the size of the patient icons and any labels.\nadd_background_image: You can overlay the animation on a floor plan or diagram!\ntime_display_units: Show time as simple numbers, or format it like ‘Days:Hours:Minutes’.\nframe_duration / frame_transition_duration: Control the speed of the animation playback.\nwrap_queues_at: How many patients to show in a line before starting a new row in a queue.\n\n…and many more! Check the function’s documentation for all the possibilities.",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "01_animation_facade_animate_activity_log_.html#conclusion",
    "href": "01_animation_facade_animate_activity_log_.html#conclusion",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "You’ve now met animate_activity_log, the main entry point and “easy button” for creating process animations with vidigi. It acts as a facade, hiding the complexity of data preparation and animation generation by coordinating specialized helper functions. You provide the raw event data and layout information, and it delivers the final animated visualization.\nBut how do we get that crucial event_log data in the first place? That’s exactly what we’ll cover in the next chapter!\nNext up: Chapter 2: Event Log\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "02_event_log_.html",
    "href": "02_event_log_.html",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "In Chapter 1: Animation Facade (animate_activity_log), we learned about the “Easy Button” animate_activity_log function. We saw that it needs two main ingredients: the “What happened?” data and the “Where should things be?” layout.\nThis chapter focuses on the first ingredient: the Event Log. It’s the heart of your simulation data and tells vidigi exactly what happened, to whom, and when.\n\n\nImagine you’re trying to make a movie about a busy day at a small clinic. To show what happened accurately, you wouldn’t just film random moments. You’d need a detailed script or a logbook tracking each patient:\n\nWhen did Patient Alice arrive? (9:00 AM)\nWhen did she start waiting in the waiting room? (9:01 AM)\nWhen did Nurse Bob become free? (9:15 AM)\nWhen did Alice start her consultation with Nurse Bob? (9:15 AM)\nWhen did the consultation end? (9:30 AM)\nWhen did Alice leave the clinic? (9:31 AM)\n\nAnd you’d need this information for every patient (Alice, Charlie, David…).\nThat’s precisely what the Event Log provides for vidigi. It’s like a detailed diary or logbook for your simulated system (like the clinic, a factory line, a call center, etc.). It tracks every important step or “event” for each “patient” or “entity” as it moves through the process. Without this detailed sequence, vidigi wouldn’t know how to create the animation!\n\n\n\nThe Event Log is essentially a table, most commonly represented as a pandas DataFrame in Python. Think of it like a spreadsheet where each row represents a significant moment (an event) that occurred.\nTo work correctly with vidigi, this table must have specific columns:\n\npatient: This column identifies who the event happened to. It could be a patient ID number, a customer name, a product code – whatever uniquely identifies the entity moving through your system.\nevent_type: This tells vidigi the kind of event that occurred. It’s a broad category. The main types are:\n\narrival_departure: The entity entered or exited the system.\nqueue: The entity started waiting in a line or area.\nresource_use: The entity started using a specific resource (like a nurse, a machine, a checkout counter).\nresource_use_end: The entity finished using that specific resource.\n\nevent: This gives the specific name of the event. For arrivals and departures, this must be exactly 'arrival' or 'depart'. For queues and resource use, you can define custom names (like 'start_wait_room', 'begin_treatment', 'end_checkout').\ntime: This records when the event happened, usually as a number representing the simulation time (e.g., minutes or hours from the start).\n\nAnd one more, which is needed only for specific event_types:\n\nresource_id: When an entity starts or stops using a specific resource (like Treatment Room 1 vs Treatment Room 2), this column tells vidigi which one it was. This is only required for event_type 'resource_use' and 'resource_use_end'.\n\nYou might also see other helpful columns like:\n\npathway: If your system has different routes entities can take, this might label the specific path.\nrun: If you run your simulation multiple times, this identifies which run the event belongs to.\n\n\n\n\nLet’s look at a small, simplified Event Log DataFrame, similar to the one we saw in Chapter 1:\nimport pandas as pd\n\n# Create a simple Event Log as a pandas DataFrame\nevent_log_data = {\n    'patient': [1, 1, 1, 1, 2, 2, 2, 2],\n    'event_type': ['arrival_departure', 'queue', 'resource_use', 'arrival_departure',\n                   'arrival_departure', 'queue', 'resource_use', 'arrival_departure'],\n    'event': ['arrival', 'start_wait', 'start_treat', 'depart',\n              'arrival', 'start_wait', 'start_treat', 'depart'],\n    'time': [0, 0, 5, 15, 2, 2, 8, 20],\n    'resource_id': [None, None, 1, None, None, None, 2, None], # Note: Only filled for 'resource_use'\n    'pathway': ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A'], # Optional: All follow Pathway A\n    'run': [1, 1, 1, 1, 1, 1, 1, 1] # Optional: All from Run 1\n}\nmy_event_log = pd.DataFrame(event_log_data)\n\nprint(my_event_log)\nOutput:\n   patient       event_type        event  time  resource_id pathway  run\n0        1  arrival_departure      arrival     0          NaN       A    1\n1        1              queue   start_wait     0          NaN       A    1\n2        1       resource_use  start_treat     5          1.0       A    1  # Used resource 1\n3        1  arrival_departure       depart    15          NaN       A    1\n4        2  arrival_departure      arrival     2          NaN       A    1\n5        2              queue   start_wait     2          NaN       A    1\n6        2       resource_use  start_treat     8          2.0       A    1  # Used resource 2\n7        2  arrival_departure       depart    20          NaN       A    1\nLet’s break down what this log tells vidigi:\n\nRow 0: Patient 1 arrival occurred (event_type arrival_departure) at time 0.\nRow 1: Patient 1 started waiting (event start_wait, event_type queue) also at time 0.\nRow 2: Patient 1 started treatment (event start_treat, event_type resource_use) at time 5. Crucially, it used resource 1 (resource_id is 1.0).\nRow 3: Patient 1 left the system (event depart, event_type arrival_departure) at time 15.\nRow 4: Patient 2 arrival occurred at time 2.\n…and so on for Patient 2, who used resource 2.\n\nNotice how resource_id is only filled in when the event_type is resource_use. We’d also need it for resource_use_end events (which aren’t shown in this very simplified example, but are important in real logs!).\n\n\n\nThis log is the raw material. When you call animate_activity_log (or the helper functions it uses, like reshape_for_animations), vidigi reads this table.\nIt essentially “plays back” the log, figuring out: “At time 0, who was where? At time 1? At time 2?…” It uses the time column to order events and the event_type and event columns to understand what state each patient is in at any given moment. The resource_id helps it place patients at the correct resource spot in the animation.\nThink of vidigi as an animator reading the script (the Event Log) frame by frame to draw the movie. The more accurate and detailed your Event Log, the better your final animation will be!\n\n\n\nYou typically don’t create these logs by hand! They are usually generated automatically:\n\nSimulation Models: Software like SimPy (often used with vidigi) or Ciw can be programmed to record these events automatically as the simulation runs. You add small “logging” snippets to your simulation code at key points (like when a patient arrives, requests a resource, etc.).\n\nvidigi provides helpers to make this easier, like CustomResource and populate_store for SimPy.\nThere’s even a utility (utils.event_log_from_ciw_recs) to convert logs from the Ciw library.\nAn example of adding logging to a SimPy model can be found in the documentation (vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.qmd).\n\nReal-World Data: Sometimes, you might have data logs from real systems (like timestamped entries in a hospital database or factory sensor readings). You would need to process this data into the specific vidigi Event Log format (with the required columns).\n\n\n\n\nThe Event Log is the fundamental data input for vidigi. It’s a structured table (usually a pandas DataFrame) that acts like a detailed diary, recording every significant moment (event, event_type) for each entity (patient) at a specific time, sometimes involving a particular resource_id.\nvidigi reads this log to reconstruct the system’s dynamics and create the animation. Getting this log right is the first crucial step!\nNow that we understand what happened (the Event Log), how do we tell vidigi where these events should appear on the screen? That’s the job of the Layout Configuration, which we’ll explore next.\nNext up: Chapter 3: Layout Configuration (event_position_df)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "02_event_log_.html#the-story-of-your-process-why-we-need-an-event-log",
    "href": "02_event_log_.html#the-story-of-your-process-why-we-need-an-event-log",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "Imagine you’re trying to make a movie about a busy day at a small clinic. To show what happened accurately, you wouldn’t just film random moments. You’d need a detailed script or a logbook tracking each patient:\n\nWhen did Patient Alice arrive? (9:00 AM)\nWhen did she start waiting in the waiting room? (9:01 AM)\nWhen did Nurse Bob become free? (9:15 AM)\nWhen did Alice start her consultation with Nurse Bob? (9:15 AM)\nWhen did the consultation end? (9:30 AM)\nWhen did Alice leave the clinic? (9:31 AM)\n\nAnd you’d need this information for every patient (Alice, Charlie, David…).\nThat’s precisely what the Event Log provides for vidigi. It’s like a detailed diary or logbook for your simulated system (like the clinic, a factory line, a call center, etc.). It tracks every important step or “event” for each “patient” or “entity” as it moves through the process. Without this detailed sequence, vidigi wouldn’t know how to create the animation!",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "02_event_log_.html#what-does-an-event-log-look-like",
    "href": "02_event_log_.html#what-does-an-event-log-look-like",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "The Event Log is essentially a table, most commonly represented as a pandas DataFrame in Python. Think of it like a spreadsheet where each row represents a significant moment (an event) that occurred.\nTo work correctly with vidigi, this table must have specific columns:\n\npatient: This column identifies who the event happened to. It could be a patient ID number, a customer name, a product code – whatever uniquely identifies the entity moving through your system.\nevent_type: This tells vidigi the kind of event that occurred. It’s a broad category. The main types are:\n\narrival_departure: The entity entered or exited the system.\nqueue: The entity started waiting in a line or area.\nresource_use: The entity started using a specific resource (like a nurse, a machine, a checkout counter).\nresource_use_end: The entity finished using that specific resource.\n\nevent: This gives the specific name of the event. For arrivals and departures, this must be exactly 'arrival' or 'depart'. For queues and resource use, you can define custom names (like 'start_wait_room', 'begin_treatment', 'end_checkout').\ntime: This records when the event happened, usually as a number representing the simulation time (e.g., minutes or hours from the start).\n\nAnd one more, which is needed only for specific event_types:\n\nresource_id: When an entity starts or stops using a specific resource (like Treatment Room 1 vs Treatment Room 2), this column tells vidigi which one it was. This is only required for event_type 'resource_use' and 'resource_use_end'.\n\nYou might also see other helpful columns like:\n\npathway: If your system has different routes entities can take, this might label the specific path.\nrun: If you run your simulation multiple times, this identifies which run the event belongs to.",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "02_event_log_.html#a-simple-example",
    "href": "02_event_log_.html#a-simple-example",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "Let’s look at a small, simplified Event Log DataFrame, similar to the one we saw in Chapter 1:\nimport pandas as pd\n\n# Create a simple Event Log as a pandas DataFrame\nevent_log_data = {\n    'patient': [1, 1, 1, 1, 2, 2, 2, 2],\n    'event_type': ['arrival_departure', 'queue', 'resource_use', 'arrival_departure',\n                   'arrival_departure', 'queue', 'resource_use', 'arrival_departure'],\n    'event': ['arrival', 'start_wait', 'start_treat', 'depart',\n              'arrival', 'start_wait', 'start_treat', 'depart'],\n    'time': [0, 0, 5, 15, 2, 2, 8, 20],\n    'resource_id': [None, None, 1, None, None, None, 2, None], # Note: Only filled for 'resource_use'\n    'pathway': ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A'], # Optional: All follow Pathway A\n    'run': [1, 1, 1, 1, 1, 1, 1, 1] # Optional: All from Run 1\n}\nmy_event_log = pd.DataFrame(event_log_data)\n\nprint(my_event_log)\nOutput:\n   patient       event_type        event  time  resource_id pathway  run\n0        1  arrival_departure      arrival     0          NaN       A    1\n1        1              queue   start_wait     0          NaN       A    1\n2        1       resource_use  start_treat     5          1.0       A    1  # Used resource 1\n3        1  arrival_departure       depart    15          NaN       A    1\n4        2  arrival_departure      arrival     2          NaN       A    1\n5        2              queue   start_wait     2          NaN       A    1\n6        2       resource_use  start_treat     8          2.0       A    1  # Used resource 2\n7        2  arrival_departure       depart    20          NaN       A    1\nLet’s break down what this log tells vidigi:\n\nRow 0: Patient 1 arrival occurred (event_type arrival_departure) at time 0.\nRow 1: Patient 1 started waiting (event start_wait, event_type queue) also at time 0.\nRow 2: Patient 1 started treatment (event start_treat, event_type resource_use) at time 5. Crucially, it used resource 1 (resource_id is 1.0).\nRow 3: Patient 1 left the system (event depart, event_type arrival_departure) at time 15.\nRow 4: Patient 2 arrival occurred at time 2.\n…and so on for Patient 2, who used resource 2.\n\nNotice how resource_id is only filled in when the event_type is resource_use. We’d also need it for resource_use_end events (which aren’t shown in this very simplified example, but are important in real logs!).",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "02_event_log_.html#how-vidigi-uses-the-event-log",
    "href": "02_event_log_.html#how-vidigi-uses-the-event-log",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "This log is the raw material. When you call animate_activity_log (or the helper functions it uses, like reshape_for_animations), vidigi reads this table.\nIt essentially “plays back” the log, figuring out: “At time 0, who was where? At time 1? At time 2?…” It uses the time column to order events and the event_type and event columns to understand what state each patient is in at any given moment. The resource_id helps it place patients at the correct resource spot in the animation.\nThink of vidigi as an animator reading the script (the Event Log) frame by frame to draw the movie. The more accurate and detailed your Event Log, the better your final animation will be!",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "02_event_log_.html#where-do-event-logs-come-from",
    "href": "02_event_log_.html#where-do-event-logs-come-from",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "You typically don’t create these logs by hand! They are usually generated automatically:\n\nSimulation Models: Software like SimPy (often used with vidigi) or Ciw can be programmed to record these events automatically as the simulation runs. You add small “logging” snippets to your simulation code at key points (like when a patient arrives, requests a resource, etc.).\n\nvidigi provides helpers to make this easier, like CustomResource and populate_store for SimPy.\nThere’s even a utility (utils.event_log_from_ciw_recs) to convert logs from the Ciw library.\nAn example of adding logging to a SimPy model can be found in the documentation (vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.qmd).\n\nReal-World Data: Sometimes, you might have data logs from real systems (like timestamped entries in a hospital database or factory sensor readings). You would need to process this data into the specific vidigi Event Log format (with the required columns).",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "02_event_log_.html#conclusion",
    "href": "02_event_log_.html#conclusion",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "The Event Log is the fundamental data input for vidigi. It’s a structured table (usually a pandas DataFrame) that acts like a detailed diary, recording every significant moment (event, event_type) for each entity (patient) at a specific time, sometimes involving a particular resource_id.\nvidigi reads this log to reconstruct the system’s dynamics and create the animation. Getting this log right is the first crucial step!\nNow that we understand what happened (the Event Log), how do we tell vidigi where these events should appear on the screen? That’s the job of the Layout Configuration, which we’ll explore next.\nNext up: Chapter 3: Layout Configuration (event_position_df)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "04_simpy_resource_enhancement_customresource_store_populate_store_.html",
    "href": "04_simpy_resource_enhancement_customresource_store_populate_store_.html",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "In Chapter 3: Layout Configuration (event_position_df), we learned how to create a blueprint (event_position_df) that tells vidigi where to place entities on the screen for different events like waiting or using a resource. We saw that for resource steps (like “Treatment Bays”), vidigi needs to know how many resource slots are available.\nBut there’s a subtle challenge: how does vidigi know if Patient Alice is always using Treatment Bay 1 throughout her treatment, or if she magically swaps places with Patient Bob in Bay 2 halfway through? For a clear animation, we want to see Alice consistently stay in Bay 1.\nThis chapter explains how vidigi handles this using a special pattern when you build your simulation model with the popular library SimPy.\n\n\nImagine a small clinic with two identical treatment rooms (Room A and Room B). SimPy, a library often used to create the simulation data that vidigi visualizes, has a concept called simpy.Resource to represent things like these rooms.\nYou can tell SimPy “I have 2 treatment rooms”. When a patient needs a room, SimPy can tell you “Okay, a room is available”. But it doesn’t inherently tell you which room (A or B) the patient got.\nIf Patient Alice gets a room, and later Patient Bob gets a room, the simulation knows two rooms are busy. But the standard event log might just say:\n\nTime 5: Alice starts using a room.\nTime 8: Bob starts using a room.\n\nWhen vidigi reads this, it doesn’t know if Alice is in Room A and Bob in Room B, or vice-versa. In the animation, Alice might appear in the spot for Room A in one frame and Room B in the next, which looks confusing!\nWe need a way to give each individual resource (each room, each nurse, each machine) a unique ID, like giving each worker a specific ID badge.\n\n\n\nvidigi uses a clever workaround combined with helpers provided in its utils module:\n\nsimpy.Store: Instead of using simpy.Resource directly to represent the pool of treatment rooms, we use a simpy.Store. Think of a Store like a container or a shelf that can hold individual items. Our “shelf” will hold our individual, identifiable treatment rooms.\nvidigi.utils.CustomResource: We need items to put in the Store. We can’t just put standard simpy.Resource objects in there, because they still lack IDs. So, vidigi provides CustomResource. It’s almost identical to a simpy.Resource, but with one crucial addition: an id_attribute. This is our ID badge! Each CustomResource instance we create will represent one specific treatment room (like Room A or Room B) and will have its own unique ID.\nvidigi.utils.populate_store: Manually creating each CustomResource (each nurse, each room) and putting it into the Store can be repetitive. vidigi provides a helper function, populate_store, that does this for you. You tell it how many resources you need (e.g., 2 treatment rooms), which Store to put them in, and it automatically creates the right number of CustomResource objects, assigns them unique IDs (like 1, 2), and puts them into the Store.\n\nAnalogy:\n\nImagine you have 3 nurses (num_resources = 3).\nThe simpy.Store is the Nurses’ Station (simpy_store).\nCustomResource is a Nurse object that includes an ID badge (id_attribute).\npopulate_store is the supervisor who hires 3 nurses, gives them badges labelled “Nurse 1”, “Nurse 2”, “Nurse 3”, and tells them to wait at the Nurses’ Station (simpy_store).\n\n\n\n\nLet’s see how you’d modify a typical SimPy model setup.\n1. Before (Using simpy.Resource):\n# --- In your Model's __init__ or resource setup ---\nimport simpy\n\n# Assume 'self.env' is your simpy.Environment\n# Assume 'g.n_cubicles' holds the number of cubicles (e.g., 2)\n# self.treatment_cubicles = simpy.Resource(self.env, capacity=g.n_cubicles)\n\n# --- In your SimPy process function (e.g., attend_clinic) ---\n# def attend_clinic(self, patient):\n    # ... other code ...\n\n    # Request *a* cubicle\n    # with self.treatment_cubicles.request() as req:\n    #     yield req\n        # --- Log the start of treatment ---\n        # (Problem: No specific cubicle ID here!)\n        # self.event_log.append({\n        #     'patient': patient.identifier,\n        #     'event': 'treatment_begins',\n        #     'event_type': 'resource_use',\n        #     'time': self.env.now,\n        #     'resource_id': None # &lt;--- We don't know which one!\n        # })\n\n        # yield self.env.timeout(treatment_duration)\n        # --- Log the end of treatment ---\n        # (Still no specific ID)\n\n    # ... other code ...\nThis code works for SimPy, but it doesn’t log the specific resource_id needed by vidigi.\n2. After (Using Store, CustomResource, populate_store):\n# --- Add imports at the top of your file ---\nimport simpy\nfrom vidigi.utils import CustomResource, populate_store # Import helpers\n\n# --- In your Model's __init__ or resource setup ---\n# Assume 'self.env' is your simpy.Environment\n# Assume 'g.n_cubicles' holds the number of cubicles (e.g., 2)\n\n# 1. Create an empty Store instead of a Resource\nself.treatment_cubicles_store = simpy.Store(self.env)\n\n# 2. Use populate_store to fill it with ID'd CustomResources\npopulate_store(\n    num_resources=g.n_cubicles,             # How many cubicles?\n    simpy_store=self.treatment_cubicles_store, # Which store to fill?\n    sim_env=self.env                        # The SimPy environment\n)\n\n# --- In your SimPy process function (e.g., attend_clinic) ---\n# def attend_clinic(self, patient):\n    # ... other code ...\n\n    # Request a SPECIFIC cubicle FROM THE STORE\n    # Note: We use .get() on the store, not .request()\n    print(f\"Patient {patient.identifier} waiting for cubicle...\")\n    specific_cubicle = yield self.treatment_cubicles_store.get()\n    print(f\"Patient {patient.identifier} got cubicle {specific_cubicle.id_attribute}\")\n\n    # --- Log the start of treatment ---\n    # Now we can log the SPECIFIC ID!\n    self.event_log.append({\n        'patient': patient.identifier,\n        'event': 'treatment_begins',\n        'event_type': 'resource_use',\n        'time': self.env.now,\n        'resource_id': specific_cubicle.id_attribute # &lt;-- Success!\n    })\n\n    # Simulate treatment time\n    # yield self.env.timeout(treatment_duration)\n\n    # --- Log the end of treatment ---\n    # Also log the specific ID here\n    self.event_log.append({\n        'patient': patient.identifier,\n        'event': 'treatment_complete',\n        'event_type': 'resource_use_end',\n        'time': self.env.now,\n        'resource_id': specific_cubicle.id_attribute # &lt;-- Consistent ID!\n    })\n\n    # IMPORTANT: Put the specific cubicle BACK INTO THE STORE\n    print(f\"Patient {patient.identifier} releasing cubicle {specific_cubicle.id_attribute}\")\n    yield self.treatment_cubicles_store.put(specific_cubicle)\n\n    # ... other code ...\nKey Changes:\n\nWe replaced simpy.Resource with simpy.Store.\nWe used populate_store to fill the store initially.\nWe replaced resource.request() with store.get(). This yields the actual CustomResource object (our specific cubicle).\nWe accessed specific_cubicle.id_attribute to get the unique ID for logging in the Event Log.\nCrucially, after finishing, we used store.put(specific_cubicle) to return that specific cubicle back to the store, making it available for others.\n\nNow, when vidigi processes the event log, it sees entries like resource_id: 1 or resource_id: 2. When combined with the Layout Configuration (event_position_df) which defines the base position for “treatment_begins” and knows there are 2 cubicles, vidigi can calculate the exact position for “Cubicle 1” and “Cubicle 2”. If Patient Alice consistently logs resource_id: 1, she will always be shown in the animation at the spot calculated for Cubicle 1!\n\n\n\nConceptually, this pattern allows us to track individual resources:\n\n\n\n\n\nsequenceDiagram\n    participant P as Patient\n    participant S as Cubicle Store\n    participant C1 as Cubicle 1 (ID=1)\n    participant C2 as Cubicle 2 (ID=2)\n    participant Log as Event Log\n\n    Note over S,C1,C2: Store initially contains C1 and C2\n\n    P-&gt;&gt;S: Request cubicle (.get())\n    S--&gt;&gt;P: Provide C1\n    P-&gt;&gt;Log: Record treatment_begins, ID=1\n\n    Note over P: Uses Cubicle 1 for some time...\n\n    P-&gt;&gt;Log: Record treatment_complete, ID=1\n    P-&gt;&gt;S: Return C1 (.put(C1))\n\n    Note over S,C1,C2: Store now contains C1 and C2 again\n\n\n\n\n\n\n\nThe populate_store function itself is quite simple. Looking inside vidigi/utils.py, it essentially does this:\n# Simplified view of populate_store\ndef populate_store(num_resources, simpy_store, sim_env):\n    \"\"\"Fills a store with uniquely ID'd CustomResource objects.\"\"\"\n    for i in range(num_resources):\n        # Create a CustomResource, giving it an ID (1, 2, 3...)\n        resource_with_id = CustomResource(\n            sim_env,\n            capacity=1,         # Usually, each item has capacity 1\n            id_attribute = i+1  # Assign ID: 1, 2, 3,...\n        )\n        # Put this specific resource into the store\n        simpy_store.put(resource_with_id)\nAnd the CustomResource class in vidigi/utils.py is just a standard simpy.Resource with an extra attribute added during initialization:\n# Simplified view of CustomResource\nimport simpy\n\nclass CustomResource(simpy.Resource):\n    \"\"\"A simpy.Resource with an added id_attribute.\"\"\"\n    def __init__(self, env, capacity, id_attribute=None):\n        # Call the original SimPy Resource setup\n        super().__init__(env, capacity)\n        # Add our custom ID badge!\n        self.id_attribute = id_attribute\n    # (Request and release methods are inherited, no changes needed here)\nBy combining these simple pieces (Store, CustomResource, populate_store), we achieve the goal: logging specific resource IDs so vidigi can create clear and consistent animations.\n\n\n\nWe’ve learned that standard SimPy resources lack unique IDs, which poses a challenge for visualizing which specific resource an entity is using over time. vidigi overcomes this by using a pattern involving simpy.Store as a container, vidigi.utils.CustomResource as resources with ID badges (id_attribute), and vidigi.utils.populate_store to easily set them up.\nBy modifying your SimPy model to use .get() on the store, logging the resource.id_attribute, and using .put() to return the resource, you provide vidigi with the crucial resource_id information needed in the Event Log. This allows vidigi to track entity-resource interactions precisely and render them consistently in the final animation.\nWith the event log prepared (Chapter 2), the layout defined (Chapter 3), and our resources properly identified (this Chapter), we now have all the raw ingredients. The next step is to prepare this data for the animation frames. How does vidigi figure out exactly where everyone is at every single moment in time?\nNext up: Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#the-problem-simpy-resources-dont-have-names-ids",
    "href": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#the-problem-simpy-resources-dont-have-names-ids",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Imagine a small clinic with two identical treatment rooms (Room A and Room B). SimPy, a library often used to create the simulation data that vidigi visualizes, has a concept called simpy.Resource to represent things like these rooms.\nYou can tell SimPy “I have 2 treatment rooms”. When a patient needs a room, SimPy can tell you “Okay, a room is available”. But it doesn’t inherently tell you which room (A or B) the patient got.\nIf Patient Alice gets a room, and later Patient Bob gets a room, the simulation knows two rooms are busy. But the standard event log might just say:\n\nTime 5: Alice starts using a room.\nTime 8: Bob starts using a room.\n\nWhen vidigi reads this, it doesn’t know if Alice is in Room A and Bob in Room B, or vice-versa. In the animation, Alice might appear in the spot for Room A in one frame and Room B in the next, which looks confusing!\nWe need a way to give each individual resource (each room, each nurse, each machine) a unique ID, like giving each worker a specific ID badge.",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#the-solution-store-customresource-and-populate_store",
    "href": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#the-solution-store-customresource-and-populate_store",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "vidigi uses a clever workaround combined with helpers provided in its utils module:\n\nsimpy.Store: Instead of using simpy.Resource directly to represent the pool of treatment rooms, we use a simpy.Store. Think of a Store like a container or a shelf that can hold individual items. Our “shelf” will hold our individual, identifiable treatment rooms.\nvidigi.utils.CustomResource: We need items to put in the Store. We can’t just put standard simpy.Resource objects in there, because they still lack IDs. So, vidigi provides CustomResource. It’s almost identical to a simpy.Resource, but with one crucial addition: an id_attribute. This is our ID badge! Each CustomResource instance we create will represent one specific treatment room (like Room A or Room B) and will have its own unique ID.\nvidigi.utils.populate_store: Manually creating each CustomResource (each nurse, each room) and putting it into the Store can be repetitive. vidigi provides a helper function, populate_store, that does this for you. You tell it how many resources you need (e.g., 2 treatment rooms), which Store to put them in, and it automatically creates the right number of CustomResource objects, assigns them unique IDs (like 1, 2), and puts them into the Store.\n\nAnalogy:\n\nImagine you have 3 nurses (num_resources = 3).\nThe simpy.Store is the Nurses’ Station (simpy_store).\nCustomResource is a Nurse object that includes an ID badge (id_attribute).\npopulate_store is the supervisor who hires 3 nurses, gives them badges labelled “Nurse 1”, “Nurse 2”, “Nurse 3”, and tells them to wait at the Nurses’ Station (simpy_store).",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#how-to-use-this-pattern-in-your-simpy-model",
    "href": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#how-to-use-this-pattern-in-your-simpy-model",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Let’s see how you’d modify a typical SimPy model setup.\n1. Before (Using simpy.Resource):\n# --- In your Model's __init__ or resource setup ---\nimport simpy\n\n# Assume 'self.env' is your simpy.Environment\n# Assume 'g.n_cubicles' holds the number of cubicles (e.g., 2)\n# self.treatment_cubicles = simpy.Resource(self.env, capacity=g.n_cubicles)\n\n# --- In your SimPy process function (e.g., attend_clinic) ---\n# def attend_clinic(self, patient):\n    # ... other code ...\n\n    # Request *a* cubicle\n    # with self.treatment_cubicles.request() as req:\n    #     yield req\n        # --- Log the start of treatment ---\n        # (Problem: No specific cubicle ID here!)\n        # self.event_log.append({\n        #     'patient': patient.identifier,\n        #     'event': 'treatment_begins',\n        #     'event_type': 'resource_use',\n        #     'time': self.env.now,\n        #     'resource_id': None # &lt;--- We don't know which one!\n        # })\n\n        # yield self.env.timeout(treatment_duration)\n        # --- Log the end of treatment ---\n        # (Still no specific ID)\n\n    # ... other code ...\nThis code works for SimPy, but it doesn’t log the specific resource_id needed by vidigi.\n2. After (Using Store, CustomResource, populate_store):\n# --- Add imports at the top of your file ---\nimport simpy\nfrom vidigi.utils import CustomResource, populate_store # Import helpers\n\n# --- In your Model's __init__ or resource setup ---\n# Assume 'self.env' is your simpy.Environment\n# Assume 'g.n_cubicles' holds the number of cubicles (e.g., 2)\n\n# 1. Create an empty Store instead of a Resource\nself.treatment_cubicles_store = simpy.Store(self.env)\n\n# 2. Use populate_store to fill it with ID'd CustomResources\npopulate_store(\n    num_resources=g.n_cubicles,             # How many cubicles?\n    simpy_store=self.treatment_cubicles_store, # Which store to fill?\n    sim_env=self.env                        # The SimPy environment\n)\n\n# --- In your SimPy process function (e.g., attend_clinic) ---\n# def attend_clinic(self, patient):\n    # ... other code ...\n\n    # Request a SPECIFIC cubicle FROM THE STORE\n    # Note: We use .get() on the store, not .request()\n    print(f\"Patient {patient.identifier} waiting for cubicle...\")\n    specific_cubicle = yield self.treatment_cubicles_store.get()\n    print(f\"Patient {patient.identifier} got cubicle {specific_cubicle.id_attribute}\")\n\n    # --- Log the start of treatment ---\n    # Now we can log the SPECIFIC ID!\n    self.event_log.append({\n        'patient': patient.identifier,\n        'event': 'treatment_begins',\n        'event_type': 'resource_use',\n        'time': self.env.now,\n        'resource_id': specific_cubicle.id_attribute # &lt;-- Success!\n    })\n\n    # Simulate treatment time\n    # yield self.env.timeout(treatment_duration)\n\n    # --- Log the end of treatment ---\n    # Also log the specific ID here\n    self.event_log.append({\n        'patient': patient.identifier,\n        'event': 'treatment_complete',\n        'event_type': 'resource_use_end',\n        'time': self.env.now,\n        'resource_id': specific_cubicle.id_attribute # &lt;-- Consistent ID!\n    })\n\n    # IMPORTANT: Put the specific cubicle BACK INTO THE STORE\n    print(f\"Patient {patient.identifier} releasing cubicle {specific_cubicle.id_attribute}\")\n    yield self.treatment_cubicles_store.put(specific_cubicle)\n\n    # ... other code ...\nKey Changes:\n\nWe replaced simpy.Resource with simpy.Store.\nWe used populate_store to fill the store initially.\nWe replaced resource.request() with store.get(). This yields the actual CustomResource object (our specific cubicle).\nWe accessed specific_cubicle.id_attribute to get the unique ID for logging in the Event Log.\nCrucially, after finishing, we used store.put(specific_cubicle) to return that specific cubicle back to the store, making it available for others.\n\nNow, when vidigi processes the event log, it sees entries like resource_id: 1 or resource_id: 2. When combined with the Layout Configuration (event_position_df) which defines the base position for “treatment_begins” and knows there are 2 cubicles, vidigi can calculate the exact position for “Cubicle 1” and “Cubicle 2”. If Patient Alice consistently logs resource_id: 1, she will always be shown in the animation at the spot calculated for Cubicle 1!",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#whats-happening-under-the-hood",
    "href": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#whats-happening-under-the-hood",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Conceptually, this pattern allows us to track individual resources:\n\n\n\n\n\nsequenceDiagram\n    participant P as Patient\n    participant S as Cubicle Store\n    participant C1 as Cubicle 1 (ID=1)\n    participant C2 as Cubicle 2 (ID=2)\n    participant Log as Event Log\n\n    Note over S,C1,C2: Store initially contains C1 and C2\n\n    P-&gt;&gt;S: Request cubicle (.get())\n    S--&gt;&gt;P: Provide C1\n    P-&gt;&gt;Log: Record treatment_begins, ID=1\n\n    Note over P: Uses Cubicle 1 for some time...\n\n    P-&gt;&gt;Log: Record treatment_complete, ID=1\n    P-&gt;&gt;S: Return C1 (.put(C1))\n\n    Note over S,C1,C2: Store now contains C1 and C2 again\n\n\n\n\n\n\n\nThe populate_store function itself is quite simple. Looking inside vidigi/utils.py, it essentially does this:\n# Simplified view of populate_store\ndef populate_store(num_resources, simpy_store, sim_env):\n    \"\"\"Fills a store with uniquely ID'd CustomResource objects.\"\"\"\n    for i in range(num_resources):\n        # Create a CustomResource, giving it an ID (1, 2, 3...)\n        resource_with_id = CustomResource(\n            sim_env,\n            capacity=1,         # Usually, each item has capacity 1\n            id_attribute = i+1  # Assign ID: 1, 2, 3,...\n        )\n        # Put this specific resource into the store\n        simpy_store.put(resource_with_id)\nAnd the CustomResource class in vidigi/utils.py is just a standard simpy.Resource with an extra attribute added during initialization:\n# Simplified view of CustomResource\nimport simpy\n\nclass CustomResource(simpy.Resource):\n    \"\"\"A simpy.Resource with an added id_attribute.\"\"\"\n    def __init__(self, env, capacity, id_attribute=None):\n        # Call the original SimPy Resource setup\n        super().__init__(env, capacity)\n        # Add our custom ID badge!\n        self.id_attribute = id_attribute\n    # (Request and release methods are inherited, no changes needed here)\nBy combining these simple pieces (Store, CustomResource, populate_store), we achieve the goal: logging specific resource IDs so vidigi can create clear and consistent animations.",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#conclusion",
    "href": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#conclusion",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "We’ve learned that standard SimPy resources lack unique IDs, which poses a challenge for visualizing which specific resource an entity is using over time. vidigi overcomes this by using a pattern involving simpy.Store as a container, vidigi.utils.CustomResource as resources with ID badges (id_attribute), and vidigi.utils.populate_store to easily set them up.\nBy modifying your SimPy model to use .get() on the store, logging the resource.id_attribute, and using .put() to return the resource, you provide vidigi with the crucial resource_id information needed in the Event Log. This allows vidigi to track entity-resource interactions precisely and render them consistently in the final animation.\nWith the event log prepared (Chapter 2), the layout defined (Chapter 3), and our resources properly identified (this Chapter), we now have all the raw ingredients. The next step is to prepare this data for the animation frames. How does vidigi figure out exactly where everyone is at every single moment in time?\nNext up: Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "06_animation_generation_generate_animation_.html",
    "href": "06_animation_generation_generate_animation_.html",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "Welcome to the final chapter in our vidigi tutorial! In Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df), we saw how vidigi transforms our raw Event Log and Layout Configuration (event_position_df) into a detailed, frame-by-frame dataset. This dataset tells us exactly where each entity (like a patient) should be on the screen, with its specific icon, at every single snapshot in time.\nThink of the output from Chapter 5 as a perfectly prepared film reel for a movie. Each frame on the reel shows the precise position of all actors. Now, we need the movie projector to actually display this film reel as a moving picture. That’s the job of the generate_animation function!\n\n\ngenerate_animation is the core rendering engine of vidigi. It takes the “animation-ready” DataFrame prepared in the previous step (the one with minute, patient, icon, x_final, y_final, etc.) and uses a powerful plotting library called Plotly Express to create the actual interactive animation.\nIts main job is to:\n\nDraw Each Frame: For each time snapshot (minute), it plots each entity’s icon at its calculated x_final and y_final position.\nCreate Motion: It tells Plotly how to smoothly transition the icons from their positions in one frame to their positions in the next frame. This is what makes the entities appear to move through the different stages (queues, resources).\nAdd Controls & Polish: It adds features like a timeline slider, play/pause buttons, tooltips (text that appears when you hover over an icon), stage labels, and optional background images.\n\nEssentially, generate_animation is the final artist that takes the detailed blueprint and brings it to life as an interactive animation.\n\n\n\nMost of the time, you won’t call generate_animation directly. Remember the “Easy Button” from Chapter 1: Animation Facade (animate_activity_log)? That main animate_activity_log function calls generate_animation internally as its final step.\nHowever, if you wanted very fine-grained control or were building the animation step-by-step yourself, you could call it directly. You would first need to run the preparation steps from Chapter 5 to get the required input DataFrame.\nLet’s imagine we have the final DataFrame from Chapter 5, called animation_ready_df:\n# --- Assume we have this from Chapter 5 ---\n# animation_ready_df looks like this (simplified):\n#    minute  patient icon  x_final  y_final             label  ...\n# 0       0        1  '🧔🏼'     50.0    200.0          Entrance  ...\n# 1       0        1  '🧔🏼'    200.0    250.0      Waiting Area  ...\n# 2       5        1  '🧔🏼'    190.0    150.0    Treatment Bays  ...\n# 3       5        2  '👨🏿‍🦯'    200.0    250.0      Waiting Area  ...\n# ...\n\n# --- Assume we also have these from previous chapters ---\n# my_layout = pd.DataFrame(...) # From Chapter 3\n# class SimpleScenario: n_cubicles = 2\n# scenario_details = SimpleScenario() # From Chapter 1/3\n\n# --- Import the function ---\nfrom vidigi.animation import generate_animation\nimport pandas as pd # We'll use pandas DataFrames\n\n# --- Call generate_animation directly ---\n# (Normally done inside animate_activity_log)\nfinal_animation = generate_animation(\n    full_patient_df_plus_pos=animation_ready_df, # The prepared data!\n    event_position_df=my_layout,             # Needed for stage labels, resources\n    scenario=scenario_details,               # Needed for drawing resource markers\n    plotly_height=600,                       # Set the height of the animation\n    icon_and_text_size=20,                   # Make icons smaller\n    time_display_units='dhm',                # Show time nicely\n    frame_duration=500,                      # Slow down playback slightly\n    add_background_image='floorplan.png'     # Optional: Add a background\n)\n\n# You can now display the animation (e.g., in a Jupyter Notebook)\n# final_animation.show()\nWhat happens when you run this?\nThe variable final_animation now holds a Plotly Figure object. If you displayed it (e.g., using final_animation.show() in a Jupyter notebook), you would see the complete, interactive animation:\n\nIcons (like ‘🧔🏼’ and ‘👨🏿‍🦯’) representing patients moving between locations defined in my_layout.\nSmooth transitions between the time steps recorded in animation_ready_df.\nA slider at the bottom showing the time (formatted as Days/Hours/Minutes).\nPlay/Pause buttons.\nStage labels (“Entrance”, “Waiting Area”, etc.) displayed on the chart.\nStatic markers showing the available treatment bays (based on scenario_details).\nOptionally, the ‘floorplan.png’ image in the background.\n\n\n\n\ngenerate_animation relies heavily on the plotly.express.scatter function. Here’s a simplified breakdown of how it works:\n\nCore Scatter Plot: It calls px.scatter, telling it:\n\nUse animation_ready_df as the data source.\nPlot points at x=\"x_final\" and y=\"y_final\".\nUse the icon column as the text marker for each point (text=\"icon\"). This is how the emojis appear.\nSet the animation_frame based on the time column (minute_display). This tells Plotly which rows belong to which frame of the animation.\nSet the animation_group based on the patient column. This tells Plotly that all rows with the same patient ID represent the same object moving across frames, allowing for smooth transitions.\nDefine hover text (hover_name, hover_data) so useful information appears when you mouse over an icon.\nSet the plot boundaries (range_x, range_y) and size (height, width).\n\nAdding Static Layers: After creating the basic animated scatter plot, generate_animation adds extra, non-moving layers:\n\nStage Labels: If display_stage_labels=True, it adds another go.Scatter trace (this time non-animated) to display the text labels from the event_position_df at their respective (x, y) coordinates.\nResource Markers: If a scenario object is provided, it calculates the positions for each individual resource slot (like each treatment bay) based on the event_position_df and the resource counts in scenario. It then adds another static go.Scatter trace to draw markers (like light blue circles or custom icons) at these positions.\nBackground Image: If add_background_image is specified, it uses fig.add_layout_image to place the image underneath the animation layers.\n\nStyling and Controls: Finally, it adjusts the appearance:\n\nSets the size of the icon/text markers (icon_and_text_size).\nHides axes and gridlines (unless setup_mode=True).\nConfigures the animation player (play button, slider speed using frame_duration and frame_transition_duration).\nReturns the complete Plotly Figure object.\n\n\nHere’s a simplified view of the process:\n\n\n\n\n\nsequenceDiagram\n    participant AAL as animate_activity_log (Optional Caller)\n    participant GA as generate_animation (The Projector)\n    participant Data as animation_ready_df (The Film Reel)\n    participant Layout as event_position_df (Stage Map)\n    participant Scenario as scenario object (Resource Info)\n    participant PX as Plotly Express\n    participant PlotlyFig as Plotly Figure (The Movie)\n\n    AAL-&gt;&gt;GA: Call with Data, Layout, Scenario, Options\n    GA-&gt;&gt;PX: px.scatter(data=Data, x='x_final', y='y_final', text='icon', animation_frame='minute_display', animation_group='patient', ...)\n    PX--&gt;&gt;GA: Return basic animated figure (fig)\n    GA-&gt;&gt;Layout: Get stage label positions\n    GA-&gt;&gt;PlotlyFig: fig.add_trace(go.Scatter(...)) # Add stage labels\n    alt Scenario provided\n        GA-&gt;&gt;Layout: Get resource base positions & names\n        GA-&gt;&gt;Scenario: Get resource counts\n        GA-&gt;&gt;PlotlyFig: fig.add_trace(go.Scatter(...)) # Add resource markers\n    end\n    opt Background image provided\n        GA-&gt;&gt;PlotlyFig: fig.add_layout_image(...) # Add background\n    end\n    GA-&gt;&gt;PlotlyFig: Update layout, styles, animation speed\n    GA--&gt;&gt;AAL: Return final Plotly Figure\n\n\n\n\n\n\nCode Dive (Simplified):\nLooking inside the vidigi/animation.py file, the heart of generate_animation is the plotly.express.scatter call:\n# Simplified from vidigi/animation.py\n\nimport plotly.express as px\nimport plotly.graph_objects as go\n# ... other imports\n\ndef generate_animation(full_patient_df_plus_pos, event_position_df, scenario=None, ...):\n    # ... (setup code for time display, plot boundaries) ...\n\n    # === Core Animation Creation ===\n    fig = px.scatter(\n            full_patient_df_plus_pos.sort_values('minute'), # Use the prepared data\n            x=\"x_final\",            # Horizontal position from data\n            y=\"y_final\",            # Vertical position from data\n            animation_frame=\"minute_display\", # Column defining animation time steps\n            animation_group=\"patient\",  # Column identifying entities across frames\n            text=\"icon\",            # Column with the emoji/text to display\n            hover_name=\"event\",     # Show event name on hover\n            hover_data=[\"patient\", \"time\", \"resource_id\"], # Show other details\n            # ... (ranges, height, width) ...\n            opacity=0 # Make the actual scatter points invisible (we only see the text)\n            )\n\n    # === Add Stage Labels (if requested) ===\n    if display_stage_labels:\n        fig.add_trace(go.Scatter(\n            x=event_position_df['x'] + 10, # Offset slightly\n            y=event_position_df['y'],\n            mode=\"text\", # Display text, not points\n            text=event_position_df['label'], # Get labels from layout\n            # ... (styling) ...\n            hoverinfo='none' # Don't show hover info for labels\n        ))\n\n    # === Add Resource Markers (if scenario provided) ===\n    if scenario is not None:\n        # ... (code to calculate positions for each resource instance) ...\n        # events_with_resources = calculate_resource_positions(...)\n\n        fig.add_trace(go.Scatter(\n            x=events_with_resources['x_final'], # Calculated X for each resource spot\n            y=events_with_resources['y_final'] - 10, # Place slightly below entity Y\n            mode=\"markers\", # Draw markers (e.g., circles)\n            marker=dict(color='LightSkyBlue', size=15),\n            opacity=resource_opacity,\n            hoverinfo='none'\n        ))\n        # (Or use 'mode=\"markers+text\"' if using custom_resource_icon)\n\n    # === Add Background Image (if requested) ===\n    if add_background_image is not None:\n        fig.add_layout_image(\n            # ... (configuration for image source, position, opacity) ...\n        )\n\n    # === Final Styling and Controls ===\n    fig.update_traces(textfont_size=icon_and_text_size) # Set icon size\n    fig.update_xaxes(showticklabels=False, showgrid=False) # Clean up axes\n    fig.update_yaxes(showticklabels=False, showgrid=False)\n    # ... (configure animation speed, play button etc.) ...\n\n    return fig\nThis simplified view shows how generate_animation layers the different visual elements (animated entities, static labels, static resource markers, background) using Plotly’s capabilities to produce the final interactive figure.\n\n\n\nYou’ve reached the end of the vidigi core concepts tutorial! We’ve seen how generate_animation acts as the final “movie projector”. It takes the meticulously prepared frame-by-frame data (the output of generate_animation_df from Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)) and uses Plotly Express to render the interactive animation. It plots entities, handles smooth transitions, adds labels, resource markers, and controls, bringing your process simulation to life visually.\nWhile often called behind the scenes by the main animate_activity_log function, understanding generate_animation shows you how the final visualization is constructed.\nYou now have a complete picture of the vidigi pipeline:\n\nStarting with an Event Log (the script) and a Layout Configuration (event_position_df) (the map).\nEnsuring resources are uniquely identified using the pattern from Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store).\nPreparing frame-by-frame snapshot data using the functions covered in Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df).\nFinally, rendering the animation with generate_animation (this chapter), often orchestrated by the main animate_activity_log facade.\n\nCongratulations! You’re now equipped with the knowledge to understand and use vidigi to create insightful animations of your own processes. Happy visualizing!\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "06_animation_generation_generate_animation_.html#the-movie-projector-turning-data-into-visuals",
    "href": "06_animation_generation_generate_animation_.html#the-movie-projector-turning-data-into-visuals",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "generate_animation is the core rendering engine of vidigi. It takes the “animation-ready” DataFrame prepared in the previous step (the one with minute, patient, icon, x_final, y_final, etc.) and uses a powerful plotting library called Plotly Express to create the actual interactive animation.\nIts main job is to:\n\nDraw Each Frame: For each time snapshot (minute), it plots each entity’s icon at its calculated x_final and y_final position.\nCreate Motion: It tells Plotly how to smoothly transition the icons from their positions in one frame to their positions in the next frame. This is what makes the entities appear to move through the different stages (queues, resources).\nAdd Controls & Polish: It adds features like a timeline slider, play/pause buttons, tooltips (text that appears when you hover over an icon), stage labels, and optional background images.\n\nEssentially, generate_animation is the final artist that takes the detailed blueprint and brings it to life as an interactive animation.",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "06_animation_generation_generate_animation_.html#how-to-use-generate_animation-usually-indirectly",
    "href": "06_animation_generation_generate_animation_.html#how-to-use-generate_animation-usually-indirectly",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "Most of the time, you won’t call generate_animation directly. Remember the “Easy Button” from Chapter 1: Animation Facade (animate_activity_log)? That main animate_activity_log function calls generate_animation internally as its final step.\nHowever, if you wanted very fine-grained control or were building the animation step-by-step yourself, you could call it directly. You would first need to run the preparation steps from Chapter 5 to get the required input DataFrame.\nLet’s imagine we have the final DataFrame from Chapter 5, called animation_ready_df:\n# --- Assume we have this from Chapter 5 ---\n# animation_ready_df looks like this (simplified):\n#    minute  patient icon  x_final  y_final             label  ...\n# 0       0        1  '🧔🏼'     50.0    200.0          Entrance  ...\n# 1       0        1  '🧔🏼'    200.0    250.0      Waiting Area  ...\n# 2       5        1  '🧔🏼'    190.0    150.0    Treatment Bays  ...\n# 3       5        2  '👨🏿‍🦯'    200.0    250.0      Waiting Area  ...\n# ...\n\n# --- Assume we also have these from previous chapters ---\n# my_layout = pd.DataFrame(...) # From Chapter 3\n# class SimpleScenario: n_cubicles = 2\n# scenario_details = SimpleScenario() # From Chapter 1/3\n\n# --- Import the function ---\nfrom vidigi.animation import generate_animation\nimport pandas as pd # We'll use pandas DataFrames\n\n# --- Call generate_animation directly ---\n# (Normally done inside animate_activity_log)\nfinal_animation = generate_animation(\n    full_patient_df_plus_pos=animation_ready_df, # The prepared data!\n    event_position_df=my_layout,             # Needed for stage labels, resources\n    scenario=scenario_details,               # Needed for drawing resource markers\n    plotly_height=600,                       # Set the height of the animation\n    icon_and_text_size=20,                   # Make icons smaller\n    time_display_units='dhm',                # Show time nicely\n    frame_duration=500,                      # Slow down playback slightly\n    add_background_image='floorplan.png'     # Optional: Add a background\n)\n\n# You can now display the animation (e.g., in a Jupyter Notebook)\n# final_animation.show()\nWhat happens when you run this?\nThe variable final_animation now holds a Plotly Figure object. If you displayed it (e.g., using final_animation.show() in a Jupyter notebook), you would see the complete, interactive animation:\n\nIcons (like ‘🧔🏼’ and ‘👨🏿‍🦯’) representing patients moving between locations defined in my_layout.\nSmooth transitions between the time steps recorded in animation_ready_df.\nA slider at the bottom showing the time (formatted as Days/Hours/Minutes).\nPlay/Pause buttons.\nStage labels (“Entrance”, “Waiting Area”, etc.) displayed on the chart.\nStatic markers showing the available treatment bays (based on scenario_details).\nOptionally, the ‘floorplan.png’ image in the background.",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "06_animation_generation_generate_animation_.html#whats-happening-under-the-hood",
    "href": "06_animation_generation_generate_animation_.html#whats-happening-under-the-hood",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "generate_animation relies heavily on the plotly.express.scatter function. Here’s a simplified breakdown of how it works:\n\nCore Scatter Plot: It calls px.scatter, telling it:\n\nUse animation_ready_df as the data source.\nPlot points at x=\"x_final\" and y=\"y_final\".\nUse the icon column as the text marker for each point (text=\"icon\"). This is how the emojis appear.\nSet the animation_frame based on the time column (minute_display). This tells Plotly which rows belong to which frame of the animation.\nSet the animation_group based on the patient column. This tells Plotly that all rows with the same patient ID represent the same object moving across frames, allowing for smooth transitions.\nDefine hover text (hover_name, hover_data) so useful information appears when you mouse over an icon.\nSet the plot boundaries (range_x, range_y) and size (height, width).\n\nAdding Static Layers: After creating the basic animated scatter plot, generate_animation adds extra, non-moving layers:\n\nStage Labels: If display_stage_labels=True, it adds another go.Scatter trace (this time non-animated) to display the text labels from the event_position_df at their respective (x, y) coordinates.\nResource Markers: If a scenario object is provided, it calculates the positions for each individual resource slot (like each treatment bay) based on the event_position_df and the resource counts in scenario. It then adds another static go.Scatter trace to draw markers (like light blue circles or custom icons) at these positions.\nBackground Image: If add_background_image is specified, it uses fig.add_layout_image to place the image underneath the animation layers.\n\nStyling and Controls: Finally, it adjusts the appearance:\n\nSets the size of the icon/text markers (icon_and_text_size).\nHides axes and gridlines (unless setup_mode=True).\nConfigures the animation player (play button, slider speed using frame_duration and frame_transition_duration).\nReturns the complete Plotly Figure object.\n\n\nHere’s a simplified view of the process:\n\n\n\n\n\nsequenceDiagram\n    participant AAL as animate_activity_log (Optional Caller)\n    participant GA as generate_animation (The Projector)\n    participant Data as animation_ready_df (The Film Reel)\n    participant Layout as event_position_df (Stage Map)\n    participant Scenario as scenario object (Resource Info)\n    participant PX as Plotly Express\n    participant PlotlyFig as Plotly Figure (The Movie)\n\n    AAL-&gt;&gt;GA: Call with Data, Layout, Scenario, Options\n    GA-&gt;&gt;PX: px.scatter(data=Data, x='x_final', y='y_final', text='icon', animation_frame='minute_display', animation_group='patient', ...)\n    PX--&gt;&gt;GA: Return basic animated figure (fig)\n    GA-&gt;&gt;Layout: Get stage label positions\n    GA-&gt;&gt;PlotlyFig: fig.add_trace(go.Scatter(...)) # Add stage labels\n    alt Scenario provided\n        GA-&gt;&gt;Layout: Get resource base positions & names\n        GA-&gt;&gt;Scenario: Get resource counts\n        GA-&gt;&gt;PlotlyFig: fig.add_trace(go.Scatter(...)) # Add resource markers\n    end\n    opt Background image provided\n        GA-&gt;&gt;PlotlyFig: fig.add_layout_image(...) # Add background\n    end\n    GA-&gt;&gt;PlotlyFig: Update layout, styles, animation speed\n    GA--&gt;&gt;AAL: Return final Plotly Figure\n\n\n\n\n\n\nCode Dive (Simplified):\nLooking inside the vidigi/animation.py file, the heart of generate_animation is the plotly.express.scatter call:\n# Simplified from vidigi/animation.py\n\nimport plotly.express as px\nimport plotly.graph_objects as go\n# ... other imports\n\ndef generate_animation(full_patient_df_plus_pos, event_position_df, scenario=None, ...):\n    # ... (setup code for time display, plot boundaries) ...\n\n    # === Core Animation Creation ===\n    fig = px.scatter(\n            full_patient_df_plus_pos.sort_values('minute'), # Use the prepared data\n            x=\"x_final\",            # Horizontal position from data\n            y=\"y_final\",            # Vertical position from data\n            animation_frame=\"minute_display\", # Column defining animation time steps\n            animation_group=\"patient\",  # Column identifying entities across frames\n            text=\"icon\",            # Column with the emoji/text to display\n            hover_name=\"event\",     # Show event name on hover\n            hover_data=[\"patient\", \"time\", \"resource_id\"], # Show other details\n            # ... (ranges, height, width) ...\n            opacity=0 # Make the actual scatter points invisible (we only see the text)\n            )\n\n    # === Add Stage Labels (if requested) ===\n    if display_stage_labels:\n        fig.add_trace(go.Scatter(\n            x=event_position_df['x'] + 10, # Offset slightly\n            y=event_position_df['y'],\n            mode=\"text\", # Display text, not points\n            text=event_position_df['label'], # Get labels from layout\n            # ... (styling) ...\n            hoverinfo='none' # Don't show hover info for labels\n        ))\n\n    # === Add Resource Markers (if scenario provided) ===\n    if scenario is not None:\n        # ... (code to calculate positions for each resource instance) ...\n        # events_with_resources = calculate_resource_positions(...)\n\n        fig.add_trace(go.Scatter(\n            x=events_with_resources['x_final'], # Calculated X for each resource spot\n            y=events_with_resources['y_final'] - 10, # Place slightly below entity Y\n            mode=\"markers\", # Draw markers (e.g., circles)\n            marker=dict(color='LightSkyBlue', size=15),\n            opacity=resource_opacity,\n            hoverinfo='none'\n        ))\n        # (Or use 'mode=\"markers+text\"' if using custom_resource_icon)\n\n    # === Add Background Image (if requested) ===\n    if add_background_image is not None:\n        fig.add_layout_image(\n            # ... (configuration for image source, position, opacity) ...\n        )\n\n    # === Final Styling and Controls ===\n    fig.update_traces(textfont_size=icon_and_text_size) # Set icon size\n    fig.update_xaxes(showticklabels=False, showgrid=False) # Clean up axes\n    fig.update_yaxes(showticklabels=False, showgrid=False)\n    # ... (configure animation speed, play button etc.) ...\n\n    return fig\nThis simplified view shows how generate_animation layers the different visual elements (animated entities, static labels, static resource markers, background) using Plotly’s capabilities to produce the final interactive figure.",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "06_animation_generation_generate_animation_.html#conclusion",
    "href": "06_animation_generation_generate_animation_.html#conclusion",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "You’ve reached the end of the vidigi core concepts tutorial! We’ve seen how generate_animation acts as the final “movie projector”. It takes the meticulously prepared frame-by-frame data (the output of generate_animation_df from Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)) and uses Plotly Express to render the interactive animation. It plots entities, handles smooth transitions, adds labels, resource markers, and controls, bringing your process simulation to life visually.\nWhile often called behind the scenes by the main animate_activity_log function, understanding generate_animation shows you how the final visualization is constructed.\nYou now have a complete picture of the vidigi pipeline:\n\nStarting with an Event Log (the script) and a Layout Configuration (event_position_df) (the map).\nEnsuring resources are uniquely identified using the pattern from Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store).\nPreparing frame-by-frame snapshot data using the functions covered in Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df).\nFinally, rendering the animation with generate_animation (this chapter), often orchestrated by the main animate_activity_log facade.\n\nCongratulations! You’re now equipped with the knowledge to understand and use vidigi to create insightful animations of your own processes. Happy visualizing!\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 1 - Beginner-Friendly",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "autodoc_v2/02_event_log_.html",
    "href": "autodoc_v2/02_event_log_.html",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "In Chapter 1: Animation Facade (animate_activity_log), we introduced the main animate_activity_log function as the “easy button” for creating vidigi animations. We saw that it takes your simulation data and layout information to produce the final visualisation. Now, let’s delve into the most crucial piece of input data: the event_log.\n\n\nImagine you’ve simulated our simple clinic again. Patients arrive, perhaps wait for a nurse, get treated, and then leave. To create an animation, vidigi needs to know precisely when each of these significant moments occurred for every single patient. It needs a detailed, step-by-step account, much like a diary or a ship’s log, tracking each entity’s journey through the system.\nWithout this structured record, vidigi wouldn’t know when Patient 5 started waiting, when they began treatment with Nurse 2, or when they finally departed. The event_log provides this essential sequential information.\n\n\n\nAt its heart, the event_log is a pandas DataFrame. Each row in this DataFrame represents a single, significant event occurring for a specific entity (which we often call ‘patient’ by convention, but it could be anything – a customer, a document, a widget) at a particular point in simulation time.\nThink of it as a table with columns answering: * Who? (patient column) * What happened? (event column) * What kind of thing happened? (event_type column) * When did it happen? (time column) * (Sometimes) Which specific resource was involved? (resource_id column)\n\n\nFor vidigi to work correctly, your event_log DataFrame must contain the following columns:\n\npatient: An identifier for the entity moving through the system. This should be unique for each entity within a single simulation run. It can be an integer, string, or any unique label.\nevent_type: A specific category defining the type of event. This tells vidigi how to interpret the event for positioning and animation. The valid event_type strings are:\n\n'arrival_departure': Marks the entity entering or leaving the simulation scope.\n'queue': Indicates the entity has started waiting for something (e.g., a resource, a process step).\n'resource_use': Signifies the entity has begun actively using a specific instance of a resource (like a nurse, a machine, a room).\n'resource_use_end': Marks the moment the entity finishes using that specific resource instance.\n\nevent: A string describing the specific event that occurred. While you can often choose custom names here (like 'wait_for_nurse', 'start_treatment'), there are two mandatory event names required within the 'arrival_departure' event type:\n\n'arrival': Must be used for the very first event when an entity enters the system being visualised.\n'depart': Must be used for the very last event when an entity leaves the system being visualised. Using these specific names is crucial for vidigi to know the entity’s lifespan within the animation.\n\ntime: A numerical value representing the simulation time at which the event occurred. This must be consistently measured in the same units throughout your log (e.g., minutes, hours, days).\n\n\n\n\nThere’s one more column that’s essential if you’re logging resource usage:\n\nresource_id: This identifier links an entity to a specific instance of a resource. It’s required for rows where event_type is 'resource_use' or 'resource_use_end'. For example, if you have 3 nurses, the resource_id might be 1, 2, or 3, indicating which specific nurse the patient is interacting with. This allows vidigi to show the patient consistently occupying Nurse 2’s ‘slot’ in the animation, rather than just appearing generically in the ‘treatment’ area. This column should be None or NaN for event types like 'arrival_departure' or 'queue'.\n\n\n\n\nYou can include other columns in your event_log for your own analysis or potentially for future vidigi features. A common one used in examples is:\n\npathway: A string indicating a particular process path or category the entity belongs to (e.g., ‘Routine’, ‘Urgent’). While vidigi’s core animation logic doesn’t strictly depend on this column currently, it can be useful for filtering or analysis alongside the visualisation.\n\n\n\n\n\nvidigi primarily consumes the event_log; it expects you to generate it from your simulation model. Typically, you’ll add logging statements within your simulation code at the points where these key events occur.\nIf you’re using simpy, a common pattern is to maintain a list within your simulation model class. Whenever a significant event happens to an entity, you append a dictionary containing the event details to this list. After the simulation run completes, you convert this list of dictionaries into the required pandas DataFrame.\nLet’s look at how you might log the different event types within a simpy model (drawing inspiration from the HSMA structure shown in vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.qmd). Assume self.event_log is an initially empty list in your model class, patient is the entity object with an identifier attribute, and self.env.now gives the current simulation time.\n1. Logging Arrival: (Must use event_type='arrival_departure' and event='arrival')\n# Inside your simpy process function, when a patient enters\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine', # Optional pathway info\n    'event_type': 'arrival_departure',\n    'event': 'arrival',\n    'time': self.env.now,\n    'resource_id': None # No specific resource involved\n})\n2. Logging Start of Queueing: (Uses event_type='queue'; event name is user-defined)\n# Just before requesting a resource the patient needs to wait for\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine',\n    'event_type': 'queue',\n    'event': 'wait_nurse', # Custom event name\n    'time': self.env.now,\n    'resource_id': None # No specific resource involved yet\n})\n# Now, the patient starts waiting (e.g., yield self.nurse_resource.get())\n3. Logging Start of Resource Use: (Uses event_type='resource_use'; event name is user-defined; requires resource_id)\n# After successfully acquiring a specific resource instance (e.g., a nurse)\n# Assume 'nurse' is a CustomResource object obtained from a Store,\n# which has an 'id_attribute'. See Chapter 4 for details.\nnurse = yield self.nurses_store.get() # Acquire a specific nurse\n\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine',\n    'event_type': 'resource_use',\n    'event': 'use_nurse', # Custom event name\n    'time': self.env.now,\n    'resource_id': nurse.id_attribute # Crucial: Log which nurse\n})\n# Now, the patient uses the nurse (e.g., yield self.env.timeout(treatment_time))\n4. Logging End of Resource Use: (Uses event_type='resource_use_end'; event name is user-defined; requires resource_id)\n# Just before releasing the resource\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine',\n    'event_type': 'resource_use_end',\n    'event': 'finish_nurse', # Custom event name\n    'time': self.env.now,\n    'resource_id': nurse.id_attribute # Crucial: Log which nurse was finished with\n})\n# Now, release the nurse\nself.nurses_store.put(nurse)\n5. Logging Departure: (Must use event_type='arrival_departure' and event='depart')\n# When the patient leaves the system\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine',\n    'event_type': 'arrival_departure',\n    'event': 'depart',\n    'time': self.env.now,\n    'resource_id': None # No specific resource involved\n})\nAfter the simulation finishes, you’d convert the list:\nimport pandas as pd\n\n# Assuming self.event_log is the list populated during the simulation run\nevent_log_df = pd.DataFrame(self.event_log)\n\n# Now event_log_df is ready to be passed to vidigi.animate_activity_log\nFor users of the ciw simulation library, vidigi provides a helper function vidigi.utils.event_log_from_ciw_recs that can convert ciw’s standard record output into the required event_log DataFrame format, saving you from adding manual logging.\n\n\n\nHere’s how a small section of a finished event_log DataFrame might look:\nimport pandas as pd\nimport numpy as np # Often needed for NaN/None\n\n# Example Data\ndata = [\n    {'patient': 1, 'pathway': 'Routine', 'event_type': 'arrival_departure', 'event': 'arrival', 'time': 0, 'resource_id': np.nan},\n    {'patient': 2, 'pathway': 'Urgent', 'event_type': 'arrival_departure', 'event': 'arrival', 'time': 5, 'resource_id': np.nan},\n    {'patient': 1, 'pathway': 'Routine', 'event_type': 'queue', 'event': 'wait_nurse', 'time': 10, 'resource_id': np.nan},\n    {'patient': 2, 'pathway': 'Urgent', 'event_type': 'queue', 'event': 'wait_nurse', 'time': 12, 'resource_id': np.nan},\n    {'patient': 1, 'pathway': 'Routine', 'event_type': 'resource_use', 'event': 'use_nurse', 'time': 15, 'resource_id': 1},\n    {'patient': 2, 'pathway': 'Urgent', 'event_type': 'resource_use', 'event': 'use_nurse', 'time': 20, 'resource_id': 2},\n    {'patient': 1, 'pathway': 'Routine', 'event_type': 'resource_use_end', 'event': 'finish_nurse', 'time': 35, 'resource_id': 1},\n    {'patient': 1, 'pathway': 'Routine', 'event_type': 'arrival_departure', 'event': 'depart', 'time': 35, 'resource_id': np.nan},\n    {'patient': 2, 'pathway': 'Urgent', 'event_type': 'resource_use_end', 'event': 'finish_nurse', 'time': 40, 'resource_id': 2},\n    {'patient': 2, 'pathway': 'Urgent', 'event_type': 'arrival_departure', 'event': 'depart', 'time': 40, 'resource_id': np.nan}\n]\nevent_log_df = pd.DataFrame(data)\n\nprint(event_log_df)\nOutput:\n   patient  pathway         event_type         event  time  resource_id\n0        1  Routine  arrival_departure       arrival     0          NaN\n1        2   Urgent  arrival_departure       arrival     5          NaN\n2        1  Routine              queue    wait_nurse    10          NaN\n3        2   Urgent              queue    wait_nurse    12          NaN\n4        1  Routine       resource_use     use_nurse    15          1.0\n5        2   Urgent       resource_use     use_nurse    20          2.0\n6        1  Routine   resource_use_end  finish_nurse    35          1.0\n7        1  Routine  arrival_departure        depart    35          NaN\n8        2   Urgent   resource_use_end  finish_nurse    40          2.0\n9        2   Urgent  arrival_departure        depart    40          NaN\nThis table provides the raw data vidigi needs. The internal functions, primarily Snapshot Preparation (reshape_for_animations & generate_animation_df), will process this log to determine the state (location and activity) of each patient at every time step required for the animation frames.\n\n\n\nThe event_log DataFrame is the fundamental input that fuels vidigi animations. It’s a structured record detailing the “who, what, when, and where” of each entity’s journey through your simulated system. By ensuring your simulation produces a log with the correct columns (patient, event_type, event, time, and resource_id where applicable) and adheres to the specific requirements for arrival and depart events, you provide vidigi with the necessary information to visualise the dynamics.\nNow that we understand how to record what happens and when, we need to tell vidigi where these events should be displayed on the animation canvas. That’s the role of the layout configuration.\nNext: Chapter 3: Layout Configuration (event_position_df)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "autodoc_v2/02_event_log_.html#motivation-recording-the-journey",
    "href": "autodoc_v2/02_event_log_.html#motivation-recording-the-journey",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "Imagine you’ve simulated our simple clinic again. Patients arrive, perhaps wait for a nurse, get treated, and then leave. To create an animation, vidigi needs to know precisely when each of these significant moments occurred for every single patient. It needs a detailed, step-by-step account, much like a diary or a ship’s log, tracking each entity’s journey through the system.\nWithout this structured record, vidigi wouldn’t know when Patient 5 started waiting, when they began treatment with Nurse 2, or when they finally departed. The event_log provides this essential sequential information.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "autodoc_v2/02_event_log_.html#the-core-concept-an-event-log-dataframe",
    "href": "autodoc_v2/02_event_log_.html#the-core-concept-an-event-log-dataframe",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "At its heart, the event_log is a pandas DataFrame. Each row in this DataFrame represents a single, significant event occurring for a specific entity (which we often call ‘patient’ by convention, but it could be anything – a customer, a document, a widget) at a particular point in simulation time.\nThink of it as a table with columns answering: * Who? (patient column) * What happened? (event column) * What kind of thing happened? (event_type column) * When did it happen? (time column) * (Sometimes) Which specific resource was involved? (resource_id column)\n\n\nFor vidigi to work correctly, your event_log DataFrame must contain the following columns:\n\npatient: An identifier for the entity moving through the system. This should be unique for each entity within a single simulation run. It can be an integer, string, or any unique label.\nevent_type: A specific category defining the type of event. This tells vidigi how to interpret the event for positioning and animation. The valid event_type strings are:\n\n'arrival_departure': Marks the entity entering or leaving the simulation scope.\n'queue': Indicates the entity has started waiting for something (e.g., a resource, a process step).\n'resource_use': Signifies the entity has begun actively using a specific instance of a resource (like a nurse, a machine, a room).\n'resource_use_end': Marks the moment the entity finishes using that specific resource instance.\n\nevent: A string describing the specific event that occurred. While you can often choose custom names here (like 'wait_for_nurse', 'start_treatment'), there are two mandatory event names required within the 'arrival_departure' event type:\n\n'arrival': Must be used for the very first event when an entity enters the system being visualised.\n'depart': Must be used for the very last event when an entity leaves the system being visualised. Using these specific names is crucial for vidigi to know the entity’s lifespan within the animation.\n\ntime: A numerical value representing the simulation time at which the event occurred. This must be consistently measured in the same units throughout your log (e.g., minutes, hours, days).\n\n\n\n\nThere’s one more column that’s essential if you’re logging resource usage:\n\nresource_id: This identifier links an entity to a specific instance of a resource. It’s required for rows where event_type is 'resource_use' or 'resource_use_end'. For example, if you have 3 nurses, the resource_id might be 1, 2, or 3, indicating which specific nurse the patient is interacting with. This allows vidigi to show the patient consistently occupying Nurse 2’s ‘slot’ in the animation, rather than just appearing generically in the ‘treatment’ area. This column should be None or NaN for event types like 'arrival_departure' or 'queue'.\n\n\n\n\nYou can include other columns in your event_log for your own analysis or potentially for future vidigi features. A common one used in examples is:\n\npathway: A string indicating a particular process path or category the entity belongs to (e.g., ‘Routine’, ‘Urgent’). While vidigi’s core animation logic doesn’t strictly depend on this column currently, it can be useful for filtering or analysis alongside the visualisation.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "autodoc_v2/02_event_log_.html#generating-the-event-log-in-your-simulation",
    "href": "autodoc_v2/02_event_log_.html#generating-the-event-log-in-your-simulation",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "vidigi primarily consumes the event_log; it expects you to generate it from your simulation model. Typically, you’ll add logging statements within your simulation code at the points where these key events occur.\nIf you’re using simpy, a common pattern is to maintain a list within your simulation model class. Whenever a significant event happens to an entity, you append a dictionary containing the event details to this list. After the simulation run completes, you convert this list of dictionaries into the required pandas DataFrame.\nLet’s look at how you might log the different event types within a simpy model (drawing inspiration from the HSMA structure shown in vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.qmd). Assume self.event_log is an initially empty list in your model class, patient is the entity object with an identifier attribute, and self.env.now gives the current simulation time.\n1. Logging Arrival: (Must use event_type='arrival_departure' and event='arrival')\n# Inside your simpy process function, when a patient enters\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine', # Optional pathway info\n    'event_type': 'arrival_departure',\n    'event': 'arrival',\n    'time': self.env.now,\n    'resource_id': None # No specific resource involved\n})\n2. Logging Start of Queueing: (Uses event_type='queue'; event name is user-defined)\n# Just before requesting a resource the patient needs to wait for\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine',\n    'event_type': 'queue',\n    'event': 'wait_nurse', # Custom event name\n    'time': self.env.now,\n    'resource_id': None # No specific resource involved yet\n})\n# Now, the patient starts waiting (e.g., yield self.nurse_resource.get())\n3. Logging Start of Resource Use: (Uses event_type='resource_use'; event name is user-defined; requires resource_id)\n# After successfully acquiring a specific resource instance (e.g., a nurse)\n# Assume 'nurse' is a CustomResource object obtained from a Store,\n# which has an 'id_attribute'. See Chapter 4 for details.\nnurse = yield self.nurses_store.get() # Acquire a specific nurse\n\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine',\n    'event_type': 'resource_use',\n    'event': 'use_nurse', # Custom event name\n    'time': self.env.now,\n    'resource_id': nurse.id_attribute # Crucial: Log which nurse\n})\n# Now, the patient uses the nurse (e.g., yield self.env.timeout(treatment_time))\n4. Logging End of Resource Use: (Uses event_type='resource_use_end'; event name is user-defined; requires resource_id)\n# Just before releasing the resource\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine',\n    'event_type': 'resource_use_end',\n    'event': 'finish_nurse', # Custom event name\n    'time': self.env.now,\n    'resource_id': nurse.id_attribute # Crucial: Log which nurse was finished with\n})\n# Now, release the nurse\nself.nurses_store.put(nurse)\n5. Logging Departure: (Must use event_type='arrival_departure' and event='depart')\n# When the patient leaves the system\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine',\n    'event_type': 'arrival_departure',\n    'event': 'depart',\n    'time': self.env.now,\n    'resource_id': None # No specific resource involved\n})\nAfter the simulation finishes, you’d convert the list:\nimport pandas as pd\n\n# Assuming self.event_log is the list populated during the simulation run\nevent_log_df = pd.DataFrame(self.event_log)\n\n# Now event_log_df is ready to be passed to vidigi.animate_activity_log\nFor users of the ciw simulation library, vidigi provides a helper function vidigi.utils.event_log_from_ciw_recs that can convert ciw’s standard record output into the required event_log DataFrame format, saving you from adding manual logging.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "autodoc_v2/02_event_log_.html#example-event-log-dataframe",
    "href": "autodoc_v2/02_event_log_.html#example-event-log-dataframe",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "Here’s how a small section of a finished event_log DataFrame might look:\nimport pandas as pd\nimport numpy as np # Often needed for NaN/None\n\n# Example Data\ndata = [\n    {'patient': 1, 'pathway': 'Routine', 'event_type': 'arrival_departure', 'event': 'arrival', 'time': 0, 'resource_id': np.nan},\n    {'patient': 2, 'pathway': 'Urgent', 'event_type': 'arrival_departure', 'event': 'arrival', 'time': 5, 'resource_id': np.nan},\n    {'patient': 1, 'pathway': 'Routine', 'event_type': 'queue', 'event': 'wait_nurse', 'time': 10, 'resource_id': np.nan},\n    {'patient': 2, 'pathway': 'Urgent', 'event_type': 'queue', 'event': 'wait_nurse', 'time': 12, 'resource_id': np.nan},\n    {'patient': 1, 'pathway': 'Routine', 'event_type': 'resource_use', 'event': 'use_nurse', 'time': 15, 'resource_id': 1},\n    {'patient': 2, 'pathway': 'Urgent', 'event_type': 'resource_use', 'event': 'use_nurse', 'time': 20, 'resource_id': 2},\n    {'patient': 1, 'pathway': 'Routine', 'event_type': 'resource_use_end', 'event': 'finish_nurse', 'time': 35, 'resource_id': 1},\n    {'patient': 1, 'pathway': 'Routine', 'event_type': 'arrival_departure', 'event': 'depart', 'time': 35, 'resource_id': np.nan},\n    {'patient': 2, 'pathway': 'Urgent', 'event_type': 'resource_use_end', 'event': 'finish_nurse', 'time': 40, 'resource_id': 2},\n    {'patient': 2, 'pathway': 'Urgent', 'event_type': 'arrival_departure', 'event': 'depart', 'time': 40, 'resource_id': np.nan}\n]\nevent_log_df = pd.DataFrame(data)\n\nprint(event_log_df)\nOutput:\n   patient  pathway         event_type         event  time  resource_id\n0        1  Routine  arrival_departure       arrival     0          NaN\n1        2   Urgent  arrival_departure       arrival     5          NaN\n2        1  Routine              queue    wait_nurse    10          NaN\n3        2   Urgent              queue    wait_nurse    12          NaN\n4        1  Routine       resource_use     use_nurse    15          1.0\n5        2   Urgent       resource_use     use_nurse    20          2.0\n6        1  Routine   resource_use_end  finish_nurse    35          1.0\n7        1  Routine  arrival_departure        depart    35          NaN\n8        2   Urgent   resource_use_end  finish_nurse    40          2.0\n9        2   Urgent  arrival_departure        depart    40          NaN\nThis table provides the raw data vidigi needs. The internal functions, primarily Snapshot Preparation (reshape_for_animations & generate_animation_df), will process this log to determine the state (location and activity) of each patient at every time step required for the animation frames.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "autodoc_v2/02_event_log_.html#conclusion",
    "href": "autodoc_v2/02_event_log_.html#conclusion",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "The event_log DataFrame is the fundamental input that fuels vidigi animations. It’s a structured record detailing the “who, what, when, and where” of each entity’s journey through your simulated system. By ensuring your simulation produces a log with the correct columns (patient, event_type, event, time, and resource_id where applicable) and adheres to the specific requirements for arrival and depart events, you provide vidigi with the necessary information to visualise the dynamics.\nNow that we understand how to record what happens and when, we need to tell vidigi where these events should be displayed on the animation canvas. That’s the role of the layout configuration.\nNext: Chapter 3: Layout Configuration (event_position_df)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html",
    "href": "autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "In Chapter 3: Layout Configuration (event_position_df), we learned how to map simulation events to visual locations on the animation canvas, including defining base positions for resource areas and linking them to resource capacities via a scenario object. However, to make the animation truly informative, we often need to see which specific instance of a resource an entity is using. Is Patient A being seen by Nurse 1 or Nurse 2? Standard simpy resources don’t make this easy to track. This chapter explores how vidigi overcomes this limitation.\n\n\nImagine our clinic simulation again. We have three nurses, represented by a simpy.Resource with a capacity of 3. When a patient seizes a nurse, simpy simply decrements the available count. It doesn’t inherently track which of the three available “slots” the patient occupies. From simpy’s perspective, they are fungible.\nHowever, for visualisation with vidigi, this poses a problem. If we want to show Patient A consistently occupying, say, the leftmost treatment bay icon throughout their service time, we need a way to uniquely identify that bay (or the nurse assigned to it). If Patient A uses a resource, then later Patient B uses one, we need to know if Patient B got the same resource instance or a different one, so vidigi can place their icon correctly.\nStandard simpy.Resource objects don’t have a built-in, persistent ID for each unit of capacity. vidigi employs a common workaround pattern using standard simpy components combined with a custom class to address this. The core idea is to replace the single simpy.Resource with a simpy.Store containing multiple, individually identifiable resource objects.\n\n\n\nThis enhancement relies on three components working together:\n\nsimpy.Store: This is a standard Simpy class representing a buffered store of Python objects. Think of it like a shelf or a container. You can put items onto the shelf and get items off it. Crucially, when you get an item, you get that specific object back, which you can later put back onto the shelf. This ability to handle distinct objects is key.\nvidigi.utils.CustomResource: This is a very simple class provided by vidigi. It inherits directly from simpy.Resource but adds one crucial attribute: id_attribute. We use this to give each individual resource instance (like a single nurse or a specific bed) a unique identifier (e.g., 1, 2, 3, or “Nurse_A”, “Nurse_B”).\nvidigi.utils.populate_store: This is a helper function provided by vidigi that simplifies the process of creating multiple CustomResource instances and putting them into a simpy.Store at the beginning of your simulation.\n\nThe pattern is: instead of creating one simpy.Resource(env, capacity=3) for our nurses, we create a simpy.Store(env) and then use populate_store to fill that store with three separate CustomResource(env, capacity=1) objects, each having a unique id_attribute (e.g., 1, 2, and 3).\n\n\n\nLet’s see how you’d modify a typical simpy model (following the HSMA structure mentioned in the context) to use this pattern.\n1. Initial Resource Setup (The Old Way)\nPreviously, you might initialise your nurses resource like this in your Model class’s init_resources method:\n# --- Inside your Model class ---\nimport simpy\n# Assume 'g' is your parameter class, e.g., g.n_nurses = 3\n\n# def init_resources(self):\n#     '''\n#     Init the number of resources (OLD WAY)\n#     '''\n#     self.nurses = simpy.Resource(self.env, capacity=g.n_nurses)\n2. Modified Resource Setup (The vidigi Way)\nUsing the vidigi pattern, you replace the above with:\n# --- Inside your Model class ---\nimport simpy\nfrom vidigi.utils import populate_store, CustomResource\n# Assume 'g' is your parameter class, e.g., g.n_nurses = 3\n\ndef init_resources(self):\n    '''\n    Init the number of resources (VIDIGI WAY)\n    '''\n    # 1. Create a Simpy Store instead of a Resource\n    self.nurses_store = simpy.Store(self.env)\n\n    # 2. Use populate_store to fill it with CustomResource instances\n    populate_store(\n        num_resources=g.n_nurses,      # How many nurses?\n        simpy_store=self.nurses_store, # Which store to fill?\n        sim_env=self.env               # The simpy environment\n    )\n    # Now, self.nurses_store contains g.n_nurses CustomResource objects,\n    # each with capacity=1 and a unique id_attribute (1, 2, 3, ...)\n3. Requesting a Resource\nIn your simpy process function (e.g., attend_clinic), instead of using with self.nurses.request() as req:, you now need to get an item from the store:\n# --- Inside your Simpy process function (e.g., attend_clinic) ---\n\n# Old way:\n# with self.nurses.request() as req:\n#     yield req\n#     # ... process using the resource ...\n\n# New way:\n# 1. Get a specific CustomResource instance from the store\nnurse_resource = yield self.nurses_store.get()\n# nurse_resource is now one of the CustomResource objects we created,\n# e.g., the one with nurse_resource.id_attribute == 2\n\n# ... process using the resource (e.g., yield self.env.timeout(treatment_time)) ...\n4. Logging the Resource ID\nThis is the crucial step for vidigi. Now that you have the specific nurse_resource object, you can access its unique id_attribute when logging the start and end of resource use, as required by the Chapter 2: Event Log format:\n# --- Inside your Simpy process function ---\n# Just after getting the nurse_resource (yield self.nurses_store.get())\n\n# Log the start of resource use, including the ID\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine',\n    'event_type': 'resource_use',\n    'event': 'use_nurse', # Your event name\n    'time': self.env.now,\n    'resource_id': nurse_resource.id_attribute # &lt;-- The unique ID!\n})\n\n# ... yield self.env.timeout(treatment_time) ...\n\n# Just before releasing the nurse_resource\n# Log the end of resource use, including the ID\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine',\n    'event_type': 'resource_use_end',\n    'event': 'finish_nurse', # Your event name\n    'time': self.env.now,\n    'resource_id': nurse_resource.id_attribute # &lt;-- The same unique ID!\n})\n5. Releasing the Resource\nBecause you explicitly .get() the resource object from the store, you must explicitly .put() it back when you’re finished, so other entities can use it. The with statement doesn’t automatically handle this for simpy.Store.\n# --- Inside your Simpy process function ---\n# After logging the resource_use_end event\n\n# Put the specific nurse_resource object back into the store\nself.nurses_store.put(nurse_resource)\nBy making these changes, your event_log will now contain the specific resource_id for each resource interaction. vidigi’s downstream functions (Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)) can then use this ID to consistently place the patient’s icon at the correct resource slot in the animation.\n\n\n\nLet’s peek at the code for CustomResource and populate_store to see how simple they are.\nvidigi.utils.CustomResource\nAs mentioned, this is just simpy.Resource with an added id_attribute.\n# From: vidigi/utils.py\n\nimport simpy\n\nclass CustomResource(simpy.Resource):\n    \"\"\"\n    A custom resource class that extends simpy.Resource with an additional ID attribute.\n    (Docstring truncated for brevity - see source/docs for full details)\n    \"\"\"\n    def __init__(self, env, capacity, id_attribute=None):\n        # Call the parent simpy.Resource constructor\n        super().__init__(env, capacity)\n        # Store the provided ID\n        self.id_attribute = id_attribute\n\n    # The request and release methods are inherited directly from simpy.Resource\n    # We override them here mainly for documentation/potential extension,\n    # but they currently just call the parent methods.\n    def request(self, *args, **kwargs):\n        \"\"\" Request the resource. \"\"\"\n        return super().request(*args, **kwargs)\n\n    def release(self, *args, **kwargs):\n        \"\"\" Release the resource. \"\"\"\n        return super().release(*args, **kwargs)\nIt primarily serves as a way to attach the id_attribute to a standard simpy resource mechanism.\nvidigi.utils.populate_store\nThis function automates the creation and storing of CustomResource instances.\n# From: vidigi/utils.py\n\ndef populate_store(num_resources, simpy_store, sim_env):\n    \"\"\"\n    Populate a SimPy Store [...] with CustomResource objects.\n    (Docstring truncated for brevity - see source/docs for full details)\n\n    Parameters\n    ----------\n    num_resources : int\n        The number of CustomResource objects to create and add to the store.\n    simpy_store : simpy.Store or vidigi.utils.VidigiPriorityStore\n        The SimPy Store object to populate with resources.\n    sim_env : simpy.Environment\n        The SimPy environment in which the resources and store exist.\n    \"\"\"\n    # Loop from 0 up to (but not including) num_resources\n    for i in range(num_resources):\n        # Create a CustomResource instance\n        resource_instance = CustomResource(\n            env=sim_env,\n            capacity=1, # Each individual resource instance has capacity 1\n            id_attribute = i + 1 # Assign a unique ID, starting from 1\n        )\n        # Put the created resource into the provided store\n        simpy_store.put(resource_instance)\nIt simply loops num_resources times, creating a CustomResource with capacity=1 and an ID from 1 up to num_resources, and puts each one into the specified simpy_store.\nConceptual Flow\nWe can visualise the setup and usage flow like this:\n\n\n\n\n\ngraph TD\n    A[Start Simulation Setup] --&gt; B(Create `simpy.Store`);\n    B --&gt; C{Call `populate_store`};\n    C --&gt; D[Loop `num_resources` times];\n    D -- Create --&gt; E[`CustomResource(id=i+1)`];\n    E -- Put into --&gt; B;\n    D -- Loop finished --&gt; F[Store is populated];\n\n    subgraph Simulation Run\n        G[Entity needs resource] --&gt; H{`yield store.get()`};\n        H -- Returns --&gt; I[`CustomResource` instance];\n        I -- Access ID --&gt; J(Log `resource_id = instance.id_attribute`);\n        J --&gt; K[Use resource, e.g., `yield timeout`];\n        K --&gt; L(Log `resource_use_end`);\n        L --&gt; M{`store.put(instance)`};\n        M --&gt; N[Resource available again];\n    end\n\n    F --&gt; G;\n\n\n\n\n\n\nThis pattern leverages standard simpy building blocks (Store, Resource) with minimal additions (CustomResource, populate_store) to achieve the necessary tracking for detailed visualisation in vidigi.\n(Note: vidigi also provides VidigiPriorityStore and PriorityGet for scenarios requiring priority queueing with stores, based on standard Simpy patterns. These work similarly but allow specifying priorities when getting items from the store.)\n\n\n\nWe’ve seen why standard simpy.Resource objects aren’t quite sufficient for vidigi’s need to track individual resource instances. By using a simpy.Store filled with vidigi.utils.CustomResource objects (conveniently set up using vidigi.utils.populate_store), we can give each resource instance a unique id_attribute. This ID is then logged in the event_log whenever an entity starts or stops using that specific resource instance.\nThis simple enhancement to your simpy model unlocks the ability for vidigi to create much clearer and more accurate animations, showing entities consistently occupying specific resource slots. This resource_id information, along with the event timings and layout coordinates, is crucial for the next stage: preparing the per-frame snapshot data.\nNext: Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html#motivation-giving-resources-an-identity-badge",
    "href": "autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html#motivation-giving-resources-an-identity-badge",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Imagine our clinic simulation again. We have three nurses, represented by a simpy.Resource with a capacity of 3. When a patient seizes a nurse, simpy simply decrements the available count. It doesn’t inherently track which of the three available “slots” the patient occupies. From simpy’s perspective, they are fungible.\nHowever, for visualisation with vidigi, this poses a problem. If we want to show Patient A consistently occupying, say, the leftmost treatment bay icon throughout their service time, we need a way to uniquely identify that bay (or the nurse assigned to it). If Patient A uses a resource, then later Patient B uses one, we need to know if Patient B got the same resource instance or a different one, so vidigi can place their icon correctly.\nStandard simpy.Resource objects don’t have a built-in, persistent ID for each unit of capacity. vidigi employs a common workaround pattern using standard simpy components combined with a custom class to address this. The core idea is to replace the single simpy.Resource with a simpy.Store containing multiple, individually identifiable resource objects.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html#key-concepts-the-store-the-customresource-and-the-helper",
    "href": "autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html#key-concepts-the-store-the-customresource-and-the-helper",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "This enhancement relies on three components working together:\n\nsimpy.Store: This is a standard Simpy class representing a buffered store of Python objects. Think of it like a shelf or a container. You can put items onto the shelf and get items off it. Crucially, when you get an item, you get that specific object back, which you can later put back onto the shelf. This ability to handle distinct objects is key.\nvidigi.utils.CustomResource: This is a very simple class provided by vidigi. It inherits directly from simpy.Resource but adds one crucial attribute: id_attribute. We use this to give each individual resource instance (like a single nurse or a specific bed) a unique identifier (e.g., 1, 2, 3, or “Nurse_A”, “Nurse_B”).\nvidigi.utils.populate_store: This is a helper function provided by vidigi that simplifies the process of creating multiple CustomResource instances and putting them into a simpy.Store at the beginning of your simulation.\n\nThe pattern is: instead of creating one simpy.Resource(env, capacity=3) for our nurses, we create a simpy.Store(env) and then use populate_store to fill that store with three separate CustomResource(env, capacity=1) objects, each having a unique id_attribute (e.g., 1, 2, and 3).",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html#how-to-use-this-pattern-in-your-simpy-model",
    "href": "autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html#how-to-use-this-pattern-in-your-simpy-model",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Let’s see how you’d modify a typical simpy model (following the HSMA structure mentioned in the context) to use this pattern.\n1. Initial Resource Setup (The Old Way)\nPreviously, you might initialise your nurses resource like this in your Model class’s init_resources method:\n# --- Inside your Model class ---\nimport simpy\n# Assume 'g' is your parameter class, e.g., g.n_nurses = 3\n\n# def init_resources(self):\n#     '''\n#     Init the number of resources (OLD WAY)\n#     '''\n#     self.nurses = simpy.Resource(self.env, capacity=g.n_nurses)\n2. Modified Resource Setup (The vidigi Way)\nUsing the vidigi pattern, you replace the above with:\n# --- Inside your Model class ---\nimport simpy\nfrom vidigi.utils import populate_store, CustomResource\n# Assume 'g' is your parameter class, e.g., g.n_nurses = 3\n\ndef init_resources(self):\n    '''\n    Init the number of resources (VIDIGI WAY)\n    '''\n    # 1. Create a Simpy Store instead of a Resource\n    self.nurses_store = simpy.Store(self.env)\n\n    # 2. Use populate_store to fill it with CustomResource instances\n    populate_store(\n        num_resources=g.n_nurses,      # How many nurses?\n        simpy_store=self.nurses_store, # Which store to fill?\n        sim_env=self.env               # The simpy environment\n    )\n    # Now, self.nurses_store contains g.n_nurses CustomResource objects,\n    # each with capacity=1 and a unique id_attribute (1, 2, 3, ...)\n3. Requesting a Resource\nIn your simpy process function (e.g., attend_clinic), instead of using with self.nurses.request() as req:, you now need to get an item from the store:\n# --- Inside your Simpy process function (e.g., attend_clinic) ---\n\n# Old way:\n# with self.nurses.request() as req:\n#     yield req\n#     # ... process using the resource ...\n\n# New way:\n# 1. Get a specific CustomResource instance from the store\nnurse_resource = yield self.nurses_store.get()\n# nurse_resource is now one of the CustomResource objects we created,\n# e.g., the one with nurse_resource.id_attribute == 2\n\n# ... process using the resource (e.g., yield self.env.timeout(treatment_time)) ...\n4. Logging the Resource ID\nThis is the crucial step for vidigi. Now that you have the specific nurse_resource object, you can access its unique id_attribute when logging the start and end of resource use, as required by the Chapter 2: Event Log format:\n# --- Inside your Simpy process function ---\n# Just after getting the nurse_resource (yield self.nurses_store.get())\n\n# Log the start of resource use, including the ID\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine',\n    'event_type': 'resource_use',\n    'event': 'use_nurse', # Your event name\n    'time': self.env.now,\n    'resource_id': nurse_resource.id_attribute # &lt;-- The unique ID!\n})\n\n# ... yield self.env.timeout(treatment_time) ...\n\n# Just before releasing the nurse_resource\n# Log the end of resource use, including the ID\nself.event_log.append({\n    'patient': patient.identifier,\n    'pathway': 'Routine',\n    'event_type': 'resource_use_end',\n    'event': 'finish_nurse', # Your event name\n    'time': self.env.now,\n    'resource_id': nurse_resource.id_attribute # &lt;-- The same unique ID!\n})\n5. Releasing the Resource\nBecause you explicitly .get() the resource object from the store, you must explicitly .put() it back when you’re finished, so other entities can use it. The with statement doesn’t automatically handle this for simpy.Store.\n# --- Inside your Simpy process function ---\n# After logging the resource_use_end event\n\n# Put the specific nurse_resource object back into the store\nself.nurses_store.put(nurse_resource)\nBy making these changes, your event_log will now contain the specific resource_id for each resource interaction. vidigi’s downstream functions (Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)) can then use this ID to consistently place the patient’s icon at the correct resource slot in the animation.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html#under-the-bonnet-implementation-details",
    "href": "autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html#under-the-bonnet-implementation-details",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Let’s peek at the code for CustomResource and populate_store to see how simple they are.\nvidigi.utils.CustomResource\nAs mentioned, this is just simpy.Resource with an added id_attribute.\n# From: vidigi/utils.py\n\nimport simpy\n\nclass CustomResource(simpy.Resource):\n    \"\"\"\n    A custom resource class that extends simpy.Resource with an additional ID attribute.\n    (Docstring truncated for brevity - see source/docs for full details)\n    \"\"\"\n    def __init__(self, env, capacity, id_attribute=None):\n        # Call the parent simpy.Resource constructor\n        super().__init__(env, capacity)\n        # Store the provided ID\n        self.id_attribute = id_attribute\n\n    # The request and release methods are inherited directly from simpy.Resource\n    # We override them here mainly for documentation/potential extension,\n    # but they currently just call the parent methods.\n    def request(self, *args, **kwargs):\n        \"\"\" Request the resource. \"\"\"\n        return super().request(*args, **kwargs)\n\n    def release(self, *args, **kwargs):\n        \"\"\" Release the resource. \"\"\"\n        return super().release(*args, **kwargs)\nIt primarily serves as a way to attach the id_attribute to a standard simpy resource mechanism.\nvidigi.utils.populate_store\nThis function automates the creation and storing of CustomResource instances.\n# From: vidigi/utils.py\n\ndef populate_store(num_resources, simpy_store, sim_env):\n    \"\"\"\n    Populate a SimPy Store [...] with CustomResource objects.\n    (Docstring truncated for brevity - see source/docs for full details)\n\n    Parameters\n    ----------\n    num_resources : int\n        The number of CustomResource objects to create and add to the store.\n    simpy_store : simpy.Store or vidigi.utils.VidigiPriorityStore\n        The SimPy Store object to populate with resources.\n    sim_env : simpy.Environment\n        The SimPy environment in which the resources and store exist.\n    \"\"\"\n    # Loop from 0 up to (but not including) num_resources\n    for i in range(num_resources):\n        # Create a CustomResource instance\n        resource_instance = CustomResource(\n            env=sim_env,\n            capacity=1, # Each individual resource instance has capacity 1\n            id_attribute = i + 1 # Assign a unique ID, starting from 1\n        )\n        # Put the created resource into the provided store\n        simpy_store.put(resource_instance)\nIt simply loops num_resources times, creating a CustomResource with capacity=1 and an ID from 1 up to num_resources, and puts each one into the specified simpy_store.\nConceptual Flow\nWe can visualise the setup and usage flow like this:\n\n\n\n\n\ngraph TD\n    A[Start Simulation Setup] --&gt; B(Create `simpy.Store`);\n    B --&gt; C{Call `populate_store`};\n    C --&gt; D[Loop `num_resources` times];\n    D -- Create --&gt; E[`CustomResource(id=i+1)`];\n    E -- Put into --&gt; B;\n    D -- Loop finished --&gt; F[Store is populated];\n\n    subgraph Simulation Run\n        G[Entity needs resource] --&gt; H{`yield store.get()`};\n        H -- Returns --&gt; I[`CustomResource` instance];\n        I -- Access ID --&gt; J(Log `resource_id = instance.id_attribute`);\n        J --&gt; K[Use resource, e.g., `yield timeout`];\n        K --&gt; L(Log `resource_use_end`);\n        L --&gt; M{`store.put(instance)`};\n        M --&gt; N[Resource available again];\n    end\n\n    F --&gt; G;\n\n\n\n\n\n\nThis pattern leverages standard simpy building blocks (Store, Resource) with minimal additions (CustomResource, populate_store) to achieve the necessary tracking for detailed visualisation in vidigi.\n(Note: vidigi also provides VidigiPriorityStore and PriorityGet for scenarios requiring priority queueing with stores, based on standard Simpy patterns. These work similarly but allow specifying priorities when getting items from the store.)",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html#conclusion",
    "href": "autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html#conclusion",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "We’ve seen why standard simpy.Resource objects aren’t quite sufficient for vidigi’s need to track individual resource instances. By using a simpy.Store filled with vidigi.utils.CustomResource objects (conveniently set up using vidigi.utils.populate_store), we can give each resource instance a unique id_attribute. This ID is then logged in the event_log whenever an entity starts or stops using that specific resource instance.\nThis simple enhancement to your simpy model unlocks the ability for vidigi to create much clearer and more accurate animations, showing entities consistently occupying specific resource slots. This resource_id information, along with the event timings and layout coordinates, is crucial for the next stage: preparing the per-frame snapshot data.\nNext: Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "autodoc_v2/06_animation_generation_generate_animation_.html",
    "href": "autodoc_v2/06_animation_generation_generate_animation_.html",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "In Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df), we saw how vidigi transforms the raw event_log into a detailed, frame-by-frame blueprint, the full_patient_df_plus_pos DataFrame. This blueprint tells us precisely where each entity (with its assigned icon) should be at every time snapshot (minute). Now, we need to turn this meticulously prepared data into an actual moving picture.\nThis final step is handled by the generate_animation function. Think of the previous steps as preparing the film reel, frame by frame. generate_animation is the projector that takes this reel and displays the movie.\n\n\nWe have the data: entity IDs, time steps, icons, and exact X/Y coordinates. But this data is static, just a large table. The goal is to create a dynamic, visual representation where we can actually see the entities (our emojis) moving through the stages defined in our layout, forming queues, using resources, and progressing through the system over time.\ngenerate_animation leverages the power of the Plotly Express library, specifically its animated scatter plot capabilities, to achieve this. It takes the prepared snapshot data and maps it onto a visual canvas, adding interactive controls and static background elements to create the final animation figure.\n\n\n\nThe primary job of generate_animation is to take the full_patient_df_plus_pos DataFrame and use it to generate a Plotly Figure object containing an animated scatter plot.\nHere’s what it needs to do: 1. Plot Entities: For each time snapshot (minute), plot each active entity’s assigned icon at its calculated x_final, y_final coordinates. 2. Animate Movement: Instruct Plotly to treat points with the same patient ID across different time snapshots as the same object, allowing Plotly to automatically generate smooth transitions (tweening) between their positions from one frame to the next. 3. Add Context: Overlay static elements like stage labels (e.g., “Waiting Area”), resource placeholders (e.g., markers for available nurse bays), and potentially a background image. 4. Configure Display: Set up the plot’s appearance, including axes, size, time display format on the slider, animation speed, and interactive controls.\n\n\n\nWhile generate_animation is the engine doing the plotting work, you’ll typically interact with it indirectly via the main Animation Facade (animate_activity_log). The facade function prepares the data using the functions from Chapter 5 and then passes the result (full_patient_df_plus_pos) along with layout information and customisation parameters to generate_animation.\nHowever, understanding the key parameters generate_animation accepts is useful, especially if you want to customise the final look or potentially use it directly after preparing the data yourself:\n# Conceptual call structure:\nfig = generate_animation(\n    full_patient_df_plus_pos=prepared_data_df, # Output from generate_animation_df\n    event_position_df=layout_df,              # Layout definition (Chapter 3)\n    scenario=scenario_object,                 # For resource counts (Chapter 3 & 4)\n    plotly_height=900,                        # Figure height in pixels\n    plotly_width=None,                        # Figure width (None for auto)\n    include_play_button=True,                 # Show the play/pause button\n    add_background_image='path/to/bg.png',    # Optional background image\n    display_stage_labels=True,                # Show text labels for stages\n    icon_and_text_size=24,                    # Size of emoji icons\n    override_x_max=None,                      # Set fixed X-axis limit\n    override_y_max=None,                      # Set fixed Y-axis limit\n    time_display_units='dhm',                 # Format time on slider ('dhm', 'd', None)\n    resource_opacity=0.8,                     # Opacity of resource markers\n    custom_resource_icon='🏥',                # Use a custom icon for resources\n    wrap_resources_at=20,                     # Resource wrapping (match generate_animation_df)\n    gap_between_resources=10,                 # Resource spacing (match generate_animation_df)\n    gap_between_rows=30,                      # Row spacing (match generate_animation_df)\n    setup_mode=False,                         # Show axes/grid for layout setup?\n    frame_duration=400,                       # Milliseconds per frame\n    frame_transition_duration=600,            # Milliseconds for transition tweening\n    debug_mode=False\n)\n\n# fig is now a plotly.graph_objs._figure.Figure object\n# fig.show() or fig.write_html(...)\nThe most crucial inputs are the full_patient_df_plus_pos (the film reel) and the event_position_df (the map/layout). The other parameters control the aesthetics and behaviour of the animation.\n\n\n\nLet’s break down the steps generate_animation takes internally to create the visualisation.\n1. Plotly Express Core: The Animated Scatter Plot\nThe foundation of the animation is created using plotly.express.scatter (often imported as px). This powerful function can create animated plots directly from a DataFrame. The key lies in specifying the correct arguments:\n\ndata_frame=full_patient_df_plus_pos: The input data containing entity, position, icon, and time.\nx=\"x_final\", y=\"y_final\": The columns containing the coordinates for each point in each frame.\nanimation_frame=\"minute_display\": This column tells Plotly which rows belong to which frame of the animation. The function prepares a user-friendly minute_display column based on the time_display_units parameter.\nanimation_group=\"patient\": This is vital. It tells Plotly that rows with the same patient value across different animation_frames represent the same logical entity. Plotly uses this to smoothly interpolate the position (x_final, y_final) between frames, creating the illusion of movement.\ntext=\"icon\": Instead of plotting a standard marker (like a dot), we tell Plotly to display the text from the icon column (which contains our emojis) at the (x_final, y_final) position.\nopacity=0: We make the underlying scatter marker itself invisible, as we only want to see the text (the emoji).\nhover_name, hover_data: Configure the information shown when hovering over an entity in the interactive plot.\nrange_x, range_y: Set the boundaries of the plot axes.\nheight, width: Set the dimensions of the figure.\n\nThis single px.scatter call generates the base Plotly figure (fig) with the animated entities.\n# From: vidigi/animation.py (Simplified generate_animation function)\nimport plotly.express as px\n# ... other imports ...\n\ndef generate_animation(full_patient_df_plus_pos, event_position_df, scenario=None, #... other params ...\n                       ):\n    # ... code to calculate x_max, y_max, prepare 'minute_display' column ...\n\n    # Define hover info based on whether scenario (for resource_id) is present\n    if scenario is not None:\n        hovers = [\"patient\", \"pathway\", \"time\", \"minute\", \"resource_id\"]\n    else:\n        hovers = [\"patient\", \"pathway\", \"time\", \"minute\"]\n\n    # 1. Create the core animated scatter plot\n    fig = px.scatter(\n            full_patient_df_plus_pos.sort_values('minute'), # Ensure data is time-sorted\n            x=\"x_final\",\n            y=\"y_final\",\n            animation_frame=\"minute_display\", # Drive animation by time snapshots\n            animation_group=\"patient\",        # Link entities across frames\n            text=\"icon\",                      # Display emoji icon as text\n            hover_name=\"event\",               # Info on hover\n            hover_data=hovers,                # More info on hover\n            range_x=[0, x_max],               # Set plot boundaries\n            range_y=[0, y_max],\n            height=plotly_height,\n            width=plotly_width,\n            opacity=0                         # Make actual scatter marker invisible\n            )\n\n    # ... Code to add static layers and configure layout ...\n\n    return fig\nThis sets up the core animation – emojis moving around based on the prepared data.\n2. Adding Static Layers\nOnce the base fig object exists, generate_animation adds static layers using Plotly’s graph_objects module (often imported as go). These elements don’t change from frame to frame.\n\nStage Labels: If display_stage_labels=True, it iterates through the event_position_df and adds a go.Scatter trace with mode=\"text\". This trace plots the text from the label column of event_position_df near the corresponding base x, y coordinates.\n# From: vidigi/animation.py (Simplified generate_animation function)\nimport plotly.graph_objects as go\n\n# ... inside generate_animation, after px.scatter ...\n\nif display_stage_labels:\n    fig.add_trace(go.Scatter(\n        # Offset slightly from the base coordinates for better visibility\n        x=[pos + 10 for pos in event_position_df['x'].to_list()],\n        y=event_position_df['y'].to_list(),\n        mode=\"text\",                        # Display text, not markers\n        name=\"\",                            # No legend entry\n        text=event_position_df['label'].to_list(), # Use labels from layout df\n        textposition=\"middle right\",        # Position text relative to coordinates\n        hoverinfo='none'                    # No hover interaction for labels\n    ))\nResource Placeholders: If a scenario object is provided, it calculates the positions for each individual resource slot based on the event_position_df (finding rows with a non-null resource column), the resource count from getattr(scenario, resource_name), and layout parameters (gap_between_resources, wrap_resources_at, gap_between_rows). It then adds a go.Scatter trace with mode=\"markers\" (or mode=\"markers+text\" if custom_resource_icon is used) to display these placeholders, often as light blue circles, slightly offset from where the entities using them will appear.\n# From: vidigi/animation.py (Simplified generate_animation function)\n\n# ... inside generate_animation ...\n\nif scenario is not None:\n    # --- Calculate resource positions (Simplified - see Chapter 3 for details) ---\n    events_with_resources = event_position_df[event_position_df['resource'].notnull()].copy()\n    # Get counts from scenario object\n    events_with_resources['resource_count'] = events_with_resources['resource'].apply(\n        lambda resource_name: getattr(scenario, resource_name)\n    )\n    # Calculate individual resource slot positions including wrapping\n    # (Complex calculation involving gaps and wrapping omitted for brevity - stores results in resource_pos_df)\n    resource_pos_df = calculate_resource_slot_positions(\n        events_with_resources,\n        gap_between_resources,\n        gap_between_rows,\n        wrap_resources_at\n    )\n    # --- End Calculation ---\n\n    # Add the trace for resource placeholders\n    if custom_resource_icon is not None:\n         fig.add_trace(go.Scatter(\n             x=resource_pos_df['x_final'],\n             y=[y - 10 for y in resource_pos_df['y_final']], # Offset slightly\n             mode=\"markers+text\",\n             text=custom_resource_icon,          # Use custom icon text\n             marker=dict(opacity=0),             # Hide underlying marker\n             opacity=resource_opacity,           # Icon opacity\n             hoverinfo='none'\n         ))\n    else:\n         fig.add_trace(go.Scatter(\n             x=resource_pos_df['x_final'],\n             y=[y - 10 for y in resource_pos_df['y_final']], # Offset slightly\n             mode=\"markers\",\n             marker=dict(color='LightSkyBlue', size=15), # Default marker\n             opacity=resource_opacity,\n             hoverinfo='none'\n         ))\n(Note: calculate_resource_slot_positions is a conceptual representation of the logic embedded within generate_animation that determines the x_final, y_final for each resource slot based on its ID, the base position, gaps, and wrapping rules.)\nBackground Image: If add_background_image path is provided, it uses fig.add_layout_image to embed the image into the plot background, stretched to fit the axes.\n# From: vidigi/animation.py (Simplified generate_animation function)\n\nif add_background_image is not None:\n    fig.add_layout_image(\n        dict(\n            source=add_background_image, # Path or URL to the image\n            xref=\"x domain\",             # Coordinates relative to x-axis domain (0 to 1)\n            yref=\"y domain\",             # Coordinates relative to y-axis domain (0 to 1)\n            x=1, y=1,                    # Position image anchor at top-right of plot area\n            sizex=1, sizey=1,            # Image covers full width and height\n            xanchor=\"right\",\n            yanchor=\"top\",\n            sizing=\"stretch\",            # Stretch image to fit\n            opacity=0.5,                 # Make semi-transparent\n            layer=\"below\"                # Place behind data points\n        )\n    )\n\n3. Layout and Styling\nFinally, generate_animation applies various layout settings to polish the figure:\n\nIcon Size: Updates the text font size for the main scatter trace to control the emoji size (fig.update_traces(textfont_size=icon_and_text_size)).\nAxes: Hides tick labels, grid lines, and zero lines for a cleaner appearance, unless setup_mode=True (which is useful for initially determining coordinates for event_position_df). It also disables zooming (fixedrange=True). python     # From: vidigi/animation.py (Simplified generate_animation function)     if not setup_mode:         fig.update_xaxes(showticklabels=False, showgrid=False, zeroline=False, fixedrange=True)         fig.update_yaxes(showticklabels=False, showgrid=False, zeroline=False, fixedrange=True)\nTitles and Legend: Removes axis titles and the legend (fig.update_layout(yaxis_title=None, xaxis_title=None, showlegend=False)).\nAnimation Controls: Optionally removes the play/pause buttons (if not include_play_button: fig[\"layout\"].pop(\"updatemenus\")) and sets the frame duration and transition speed. python     # From: vidigi/animation.py (Simplified generate_animation function)     # Adjust speed of animation     fig.layout.updatemenus[0].buttons[0].args[1]['frame']['duration'] = frame_duration     fig.layout.updatemenus[0].buttons[0].args[1]['transition']['duration'] = frame_transition_duration\n\nConceptual Flow Diagram\n\n\n\n\n\nsequenceDiagram\n    participant Caller as animate_activity_log (or User)\n    participant GA as generate_animation\n    participant PX as plotly.express\n    participant GO as plotly.graph_objects\n    participant Figure\n\n    Caller-&gt;&gt;+GA: Call generate_animation(data, layout, scenario, options...)\n    GA-&gt;&gt;+PX: px.scatter(data, x=\"x_final\", y=\"y_final\", animation_frame=\"minute_display\", animation_group=\"patient\", text=\"icon\", ...)\n    PX--&gt;&gt;-GA: Return initial Figure object\n    Note over GA, Figure: Figure now contains base animated scatter plot.\n    GA-&gt;&gt;+GO: Create Scatter trace for Stage Labels (mode=\"text\")\n    GO--&gt;&gt;-GA: Stage Label trace object\n    GA-&gt;&gt;Figure: fig.add_trace(Stage Label trace)\n    alt scenario is provided\n        GA-&gt;&gt;GA: Calculate Resource Placeholder positions (using layout, scenario, options)\n        GA-&gt;&gt;+GO: Create Scatter trace for Resource Placeholders (mode=\"markers\")\n        GO--&gt;&gt;-GA: Resource Placeholder trace object\n        GA-&gt;&gt;Figure: fig.add_trace(Resource Placeholder trace)\n    end\n    alt add_background_image is provided\n        GA-&gt;&gt;Figure: fig.add_layout_image(...)\n    end\n    GA-&gt;&gt;Figure: fig.update_traces(textfont_size=...)\n    GA-&gt;&gt;Figure: fig.update_xaxes(...) / fig.update_yaxes(...)\n    GA-&gt;&gt;Figure: fig.update_layout(...)\n    Note over GA, Figure: Figure is now fully configured with static layers and styling.\n    GA--&gt;&gt;-Caller: Return final Figure object\n\n\n\n\n\n\nThis sequence shows how generate_animation builds the final figure layer by layer, starting with the core animation and adding static contextual elements and styling.\n\n\n\nThe generate_animation function is the final piece of the puzzle in the vidigi animation workflow. It acts as the rendering engine, taking the meticulously prepared full_patient_df_plus_pos DataFrame (the “film reel” created in Chapter 5) and projecting it onto a visual canvas using Plotly Express’s powerful animated scatter plot capabilities.\nBy mapping entity positions over time, adding contextual static layers like stage labels and resource placeholders derived from the Layout Configuration (event_position_df) and scenario object, and applying various styling options, it produces the final, interactive Plotly Figure object. This figure visually represents the dynamics captured in your simulation’s event_log, bringing your model to life.\nThis chapter concludes our walkthrough of the core components involved in generating animations with vidigi, from the high-level facade function down to the final plotting engine. Understanding these pieces allows you to effectively use vidigi and troubleshoot or customise the visualisations for your specific simulation models.\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "autodoc_v2/06_animation_generation_generate_animation_.html#motivation-bringing-the-data-to-life",
    "href": "autodoc_v2/06_animation_generation_generate_animation_.html#motivation-bringing-the-data-to-life",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "We have the data: entity IDs, time steps, icons, and exact X/Y coordinates. But this data is static, just a large table. The goal is to create a dynamic, visual representation where we can actually see the entities (our emojis) moving through the stages defined in our layout, forming queues, using resources, and progressing through the system over time.\ngenerate_animation leverages the power of the Plotly Express library, specifically its animated scatter plot capabilities, to achieve this. It takes the prepared snapshot data and maps it onto a visual canvas, adding interactive controls and static background elements to create the final animation figure.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "autodoc_v2/06_animation_generation_generate_animation_.html#the-core-task-rendering-the-animated-scatter-plot",
    "href": "autodoc_v2/06_animation_generation_generate_animation_.html#the-core-task-rendering-the-animated-scatter-plot",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "The primary job of generate_animation is to take the full_patient_df_plus_pos DataFrame and use it to generate a Plotly Figure object containing an animated scatter plot.\nHere’s what it needs to do: 1. Plot Entities: For each time snapshot (minute), plot each active entity’s assigned icon at its calculated x_final, y_final coordinates. 2. Animate Movement: Instruct Plotly to treat points with the same patient ID across different time snapshots as the same object, allowing Plotly to automatically generate smooth transitions (tweening) between their positions from one frame to the next. 3. Add Context: Overlay static elements like stage labels (e.g., “Waiting Area”), resource placeholders (e.g., markers for available nurse bays), and potentially a background image. 4. Configure Display: Set up the plot’s appearance, including axes, size, time display format on the slider, animation speed, and interactive controls.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "autodoc_v2/06_animation_generation_generate_animation_.html#usage-how-its-called",
    "href": "autodoc_v2/06_animation_generation_generate_animation_.html#usage-how-its-called",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "While generate_animation is the engine doing the plotting work, you’ll typically interact with it indirectly via the main Animation Facade (animate_activity_log). The facade function prepares the data using the functions from Chapter 5 and then passes the result (full_patient_df_plus_pos) along with layout information and customisation parameters to generate_animation.\nHowever, understanding the key parameters generate_animation accepts is useful, especially if you want to customise the final look or potentially use it directly after preparing the data yourself:\n# Conceptual call structure:\nfig = generate_animation(\n    full_patient_df_plus_pos=prepared_data_df, # Output from generate_animation_df\n    event_position_df=layout_df,              # Layout definition (Chapter 3)\n    scenario=scenario_object,                 # For resource counts (Chapter 3 & 4)\n    plotly_height=900,                        # Figure height in pixels\n    plotly_width=None,                        # Figure width (None for auto)\n    include_play_button=True,                 # Show the play/pause button\n    add_background_image='path/to/bg.png',    # Optional background image\n    display_stage_labels=True,                # Show text labels for stages\n    icon_and_text_size=24,                    # Size of emoji icons\n    override_x_max=None,                      # Set fixed X-axis limit\n    override_y_max=None,                      # Set fixed Y-axis limit\n    time_display_units='dhm',                 # Format time on slider ('dhm', 'd', None)\n    resource_opacity=0.8,                     # Opacity of resource markers\n    custom_resource_icon='🏥',                # Use a custom icon for resources\n    wrap_resources_at=20,                     # Resource wrapping (match generate_animation_df)\n    gap_between_resources=10,                 # Resource spacing (match generate_animation_df)\n    gap_between_rows=30,                      # Row spacing (match generate_animation_df)\n    setup_mode=False,                         # Show axes/grid for layout setup?\n    frame_duration=400,                       # Milliseconds per frame\n    frame_transition_duration=600,            # Milliseconds for transition tweening\n    debug_mode=False\n)\n\n# fig is now a plotly.graph_objs._figure.Figure object\n# fig.show() or fig.write_html(...)\nThe most crucial inputs are the full_patient_df_plus_pos (the film reel) and the event_position_df (the map/layout). The other parameters control the aesthetics and behaviour of the animation.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "autodoc_v2/06_animation_generation_generate_animation_.html#under-the-bonnet-how-it-works",
    "href": "autodoc_v2/06_animation_generation_generate_animation_.html#under-the-bonnet-how-it-works",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "Let’s break down the steps generate_animation takes internally to create the visualisation.\n1. Plotly Express Core: The Animated Scatter Plot\nThe foundation of the animation is created using plotly.express.scatter (often imported as px). This powerful function can create animated plots directly from a DataFrame. The key lies in specifying the correct arguments:\n\ndata_frame=full_patient_df_plus_pos: The input data containing entity, position, icon, and time.\nx=\"x_final\", y=\"y_final\": The columns containing the coordinates for each point in each frame.\nanimation_frame=\"minute_display\": This column tells Plotly which rows belong to which frame of the animation. The function prepares a user-friendly minute_display column based on the time_display_units parameter.\nanimation_group=\"patient\": This is vital. It tells Plotly that rows with the same patient value across different animation_frames represent the same logical entity. Plotly uses this to smoothly interpolate the position (x_final, y_final) between frames, creating the illusion of movement.\ntext=\"icon\": Instead of plotting a standard marker (like a dot), we tell Plotly to display the text from the icon column (which contains our emojis) at the (x_final, y_final) position.\nopacity=0: We make the underlying scatter marker itself invisible, as we only want to see the text (the emoji).\nhover_name, hover_data: Configure the information shown when hovering over an entity in the interactive plot.\nrange_x, range_y: Set the boundaries of the plot axes.\nheight, width: Set the dimensions of the figure.\n\nThis single px.scatter call generates the base Plotly figure (fig) with the animated entities.\n# From: vidigi/animation.py (Simplified generate_animation function)\nimport plotly.express as px\n# ... other imports ...\n\ndef generate_animation(full_patient_df_plus_pos, event_position_df, scenario=None, #... other params ...\n                       ):\n    # ... code to calculate x_max, y_max, prepare 'minute_display' column ...\n\n    # Define hover info based on whether scenario (for resource_id) is present\n    if scenario is not None:\n        hovers = [\"patient\", \"pathway\", \"time\", \"minute\", \"resource_id\"]\n    else:\n        hovers = [\"patient\", \"pathway\", \"time\", \"minute\"]\n\n    # 1. Create the core animated scatter plot\n    fig = px.scatter(\n            full_patient_df_plus_pos.sort_values('minute'), # Ensure data is time-sorted\n            x=\"x_final\",\n            y=\"y_final\",\n            animation_frame=\"minute_display\", # Drive animation by time snapshots\n            animation_group=\"patient\",        # Link entities across frames\n            text=\"icon\",                      # Display emoji icon as text\n            hover_name=\"event\",               # Info on hover\n            hover_data=hovers,                # More info on hover\n            range_x=[0, x_max],               # Set plot boundaries\n            range_y=[0, y_max],\n            height=plotly_height,\n            width=plotly_width,\n            opacity=0                         # Make actual scatter marker invisible\n            )\n\n    # ... Code to add static layers and configure layout ...\n\n    return fig\nThis sets up the core animation – emojis moving around based on the prepared data.\n2. Adding Static Layers\nOnce the base fig object exists, generate_animation adds static layers using Plotly’s graph_objects module (often imported as go). These elements don’t change from frame to frame.\n\nStage Labels: If display_stage_labels=True, it iterates through the event_position_df and adds a go.Scatter trace with mode=\"text\". This trace plots the text from the label column of event_position_df near the corresponding base x, y coordinates.\n# From: vidigi/animation.py (Simplified generate_animation function)\nimport plotly.graph_objects as go\n\n# ... inside generate_animation, after px.scatter ...\n\nif display_stage_labels:\n    fig.add_trace(go.Scatter(\n        # Offset slightly from the base coordinates for better visibility\n        x=[pos + 10 for pos in event_position_df['x'].to_list()],\n        y=event_position_df['y'].to_list(),\n        mode=\"text\",                        # Display text, not markers\n        name=\"\",                            # No legend entry\n        text=event_position_df['label'].to_list(), # Use labels from layout df\n        textposition=\"middle right\",        # Position text relative to coordinates\n        hoverinfo='none'                    # No hover interaction for labels\n    ))\nResource Placeholders: If a scenario object is provided, it calculates the positions for each individual resource slot based on the event_position_df (finding rows with a non-null resource column), the resource count from getattr(scenario, resource_name), and layout parameters (gap_between_resources, wrap_resources_at, gap_between_rows). It then adds a go.Scatter trace with mode=\"markers\" (or mode=\"markers+text\" if custom_resource_icon is used) to display these placeholders, often as light blue circles, slightly offset from where the entities using them will appear.\n# From: vidigi/animation.py (Simplified generate_animation function)\n\n# ... inside generate_animation ...\n\nif scenario is not None:\n    # --- Calculate resource positions (Simplified - see Chapter 3 for details) ---\n    events_with_resources = event_position_df[event_position_df['resource'].notnull()].copy()\n    # Get counts from scenario object\n    events_with_resources['resource_count'] = events_with_resources['resource'].apply(\n        lambda resource_name: getattr(scenario, resource_name)\n    )\n    # Calculate individual resource slot positions including wrapping\n    # (Complex calculation involving gaps and wrapping omitted for brevity - stores results in resource_pos_df)\n    resource_pos_df = calculate_resource_slot_positions(\n        events_with_resources,\n        gap_between_resources,\n        gap_between_rows,\n        wrap_resources_at\n    )\n    # --- End Calculation ---\n\n    # Add the trace for resource placeholders\n    if custom_resource_icon is not None:\n         fig.add_trace(go.Scatter(\n             x=resource_pos_df['x_final'],\n             y=[y - 10 for y in resource_pos_df['y_final']], # Offset slightly\n             mode=\"markers+text\",\n             text=custom_resource_icon,          # Use custom icon text\n             marker=dict(opacity=0),             # Hide underlying marker\n             opacity=resource_opacity,           # Icon opacity\n             hoverinfo='none'\n         ))\n    else:\n         fig.add_trace(go.Scatter(\n             x=resource_pos_df['x_final'],\n             y=[y - 10 for y in resource_pos_df['y_final']], # Offset slightly\n             mode=\"markers\",\n             marker=dict(color='LightSkyBlue', size=15), # Default marker\n             opacity=resource_opacity,\n             hoverinfo='none'\n         ))\n(Note: calculate_resource_slot_positions is a conceptual representation of the logic embedded within generate_animation that determines the x_final, y_final for each resource slot based on its ID, the base position, gaps, and wrapping rules.)\nBackground Image: If add_background_image path is provided, it uses fig.add_layout_image to embed the image into the plot background, stretched to fit the axes.\n# From: vidigi/animation.py (Simplified generate_animation function)\n\nif add_background_image is not None:\n    fig.add_layout_image(\n        dict(\n            source=add_background_image, # Path or URL to the image\n            xref=\"x domain\",             # Coordinates relative to x-axis domain (0 to 1)\n            yref=\"y domain\",             # Coordinates relative to y-axis domain (0 to 1)\n            x=1, y=1,                    # Position image anchor at top-right of plot area\n            sizex=1, sizey=1,            # Image covers full width and height\n            xanchor=\"right\",\n            yanchor=\"top\",\n            sizing=\"stretch\",            # Stretch image to fit\n            opacity=0.5,                 # Make semi-transparent\n            layer=\"below\"                # Place behind data points\n        )\n    )\n\n3. Layout and Styling\nFinally, generate_animation applies various layout settings to polish the figure:\n\nIcon Size: Updates the text font size for the main scatter trace to control the emoji size (fig.update_traces(textfont_size=icon_and_text_size)).\nAxes: Hides tick labels, grid lines, and zero lines for a cleaner appearance, unless setup_mode=True (which is useful for initially determining coordinates for event_position_df). It also disables zooming (fixedrange=True). python     # From: vidigi/animation.py (Simplified generate_animation function)     if not setup_mode:         fig.update_xaxes(showticklabels=False, showgrid=False, zeroline=False, fixedrange=True)         fig.update_yaxes(showticklabels=False, showgrid=False, zeroline=False, fixedrange=True)\nTitles and Legend: Removes axis titles and the legend (fig.update_layout(yaxis_title=None, xaxis_title=None, showlegend=False)).\nAnimation Controls: Optionally removes the play/pause buttons (if not include_play_button: fig[\"layout\"].pop(\"updatemenus\")) and sets the frame duration and transition speed. python     # From: vidigi/animation.py (Simplified generate_animation function)     # Adjust speed of animation     fig.layout.updatemenus[0].buttons[0].args[1]['frame']['duration'] = frame_duration     fig.layout.updatemenus[0].buttons[0].args[1]['transition']['duration'] = frame_transition_duration\n\nConceptual Flow Diagram\n\n\n\n\n\nsequenceDiagram\n    participant Caller as animate_activity_log (or User)\n    participant GA as generate_animation\n    participant PX as plotly.express\n    participant GO as plotly.graph_objects\n    participant Figure\n\n    Caller-&gt;&gt;+GA: Call generate_animation(data, layout, scenario, options...)\n    GA-&gt;&gt;+PX: px.scatter(data, x=\"x_final\", y=\"y_final\", animation_frame=\"minute_display\", animation_group=\"patient\", text=\"icon\", ...)\n    PX--&gt;&gt;-GA: Return initial Figure object\n    Note over GA, Figure: Figure now contains base animated scatter plot.\n    GA-&gt;&gt;+GO: Create Scatter trace for Stage Labels (mode=\"text\")\n    GO--&gt;&gt;-GA: Stage Label trace object\n    GA-&gt;&gt;Figure: fig.add_trace(Stage Label trace)\n    alt scenario is provided\n        GA-&gt;&gt;GA: Calculate Resource Placeholder positions (using layout, scenario, options)\n        GA-&gt;&gt;+GO: Create Scatter trace for Resource Placeholders (mode=\"markers\")\n        GO--&gt;&gt;-GA: Resource Placeholder trace object\n        GA-&gt;&gt;Figure: fig.add_trace(Resource Placeholder trace)\n    end\n    alt add_background_image is provided\n        GA-&gt;&gt;Figure: fig.add_layout_image(...)\n    end\n    GA-&gt;&gt;Figure: fig.update_traces(textfont_size=...)\n    GA-&gt;&gt;Figure: fig.update_xaxes(...) / fig.update_yaxes(...)\n    GA-&gt;&gt;Figure: fig.update_layout(...)\n    Note over GA, Figure: Figure is now fully configured with static layers and styling.\n    GA--&gt;&gt;-Caller: Return final Figure object\n\n\n\n\n\n\nThis sequence shows how generate_animation builds the final figure layer by layer, starting with the core animation and adding static contextual elements and styling.",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "autodoc_v2/06_animation_generation_generate_animation_.html#conclusion",
    "href": "autodoc_v2/06_animation_generation_generate_animation_.html#conclusion",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "The generate_animation function is the final piece of the puzzle in the vidigi animation workflow. It acts as the rendering engine, taking the meticulously prepared full_patient_df_plus_pos DataFrame (the “film reel” created in Chapter 5) and projecting it onto a visual canvas using Plotly Express’s powerful animated scatter plot capabilities.\nBy mapping entity positions over time, adding contextual static layers like stage labels and resource placeholders derived from the Layout Configuration (event_position_df) and scenario object, and applying various styling options, it produces the final, interactive Plotly Figure object. This figure visually represents the dynamics captured in your simulation’s event_log, bringing your model to life.\nThis chapter concludes our walkthrough of the core components involved in generating animations with vidigi, from the high-level facade function down to the final plotting engine. Understanding these pieces allows you to effectively use vidigi and troubleshoot or customise the visualisations for your specific simulation models.\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Version 2 - Intermediate Programmer",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "autodoc_v3/01_animation_facade_animate_activity_log_.html",
    "href": "autodoc_v3/01_animation_facade_animate_activity_log_.html",
    "title": "Chapter 1: Great Scott! Making Animations Easy with animate_activity_log",
    "section": "",
    "text": "Welcome, aspiring process visualizer! Ever felt like you have tons of data about how things move through a system – like patients in a hospital, flux capacitors being assembled, or even messages zipping through a computer network – but it’s all just numbers in a table? You wish you could see it happen, like watching Marty McFly zip back to 1985?\nTurning that raw data into a slick animation often feels like trying to build your own K.I.T.T. from spare parts – complicated! You need to figure out who is where at every single moment, plot them on a screen, and make it all move smoothly. It’s enough to make you want to yell, “Yippee-ki-yay… this is hard!”\nThat’s where vidigi comes in, specifically our main hero function: animate_activity_log. Think of it as the “Easy Button” or maybe the director calling “Action!” on your data movie set. It takes the essential ingredients and orchestrates the whole production, hiding the complex backstage machinery.\n\n\nLet’s imagine our mission, should we choose to accept it: we’ve simulated a busy clinic. We have a log showing when each patient (let’s call them “entities” or maybe “units” like Johnny 5) arrived, waited for a nurse, got treated, and left.\nOur goal: Create an animation showing these patients moving through the clinic over time. We want to see the queues build up, watch patients being treated, and get a feel for the flow, all without needing 1.21 gigawatts of programming power!\n\n\n\nThe animate_activity_log function is your primary tool in vidigi. It acts as a Facade – a simple, high-level interface that handles a complex process behind the scenes. It’s like the main control panel for the DeLorean; you tell it where you want to go (what data to animate and how), and it handles the tricky bits (flux capacitor calibration not included… yet!).\nIt takes a few key pieces of information:\n\nThe Event Log (event_log): This is the raw script of what happened and when. It’s a table detailing every important step each patient took. We’ll dive deep into this in Chapter 2: Event Log.\nThe Layout (event_position_df): This tells vidigi where each activity (like “Waiting Room” or “Treatment Bay”) should appear on the screen. Think of it as the stage layout or the map for your animation. More on this in Chapter 3: Layout Configuration (event_position_df).\nScenario Details (scenario, optional): Sometimes, you need to tell the animation about the resources available, like how many nurses (or maybe Ghostbusters proton packs) are active. This helps visualize resource capacity.\nCustomization Knobs: Want to change the animation speed? Add a cool background image like the digital world of Tron? Change icon sizes? animate_activity_log has lots of parameters for tweaking the look and feel.\n\n\n\n\nEnough talk, let’s see it in action! We need two main things to start: an event_log and an event_position_df. We’ll use super simple placeholder data for now.\nFirst, make sure you have vidigi installed and import the function:\n# Import the main animation function\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd # We use pandas DataFrames\nNow, let’s create a tiny event log. Imagine two patients, Maverick and Goose, going through basic training (arrival, training, departure).\n# Super simple event log (more detail in Chapter 2!)\nevent_data = [\n    {'patient': 'Maverick', 'event': 'arrival', 'time': 0, 'event_type': 'arrival_departure'},\n    {'patient': 'Goose', 'event': 'arrival', 'time': 5, 'event_type': 'arrival_departure'},\n    {'patient': 'Maverick', 'event': 'training_start', 'time': 10, 'event_type': 'resource_use'},\n    {'patient': 'Goose', 'event': 'training_start', 'time': 15, 'event_type': 'resource_use'},\n    {'patient': 'Maverick', 'event': 'training_end', 'time': 50, 'event_type': 'resource_use_end'},\n    {'patient': 'Goose', 'event': 'training_end', 'time': 65, 'event_type': 'resource_use_end'},\n    {'patient': 'Maverick', 'event': 'depart', 'time': 55, 'event_type': 'arrival_departure'},\n    {'patient': 'Goose', 'event': 'depart', 'time': 70, 'event_type': 'arrival_departure'}\n]\nevent_log_df = pd.DataFrame(event_data)\n\nprint(event_log_df.head()) # Show first few rows\nThis code snippet sets up our list of events and converts it into a pandas DataFrame, which is the format vidigi expects. The head() function just shows us the first few rows to check it looks okay.\nNext, we need to tell vidigi where these events happen on the screen using the event_position_df.\n# Simple positions (x, y coordinates - more in Chapter 3!)\nposition_data = [\n    {'event': 'arrival', 'x': 50, 'y': 100, 'label': 'Arrival Zone'},\n    {'event': 'training_start', 'x': 150, 'y': 100, 'label': 'Training Area'},\n    {'event': 'depart', 'x': 250, 'y': 100, 'label': 'Departure Deck'}\n    # Note: We don't need 'training_end' position here\n]\nevent_pos_df = pd.DataFrame(position_data)\n\nprint(event_pos_df)\nHere, we define where the ‘arrival’, ‘training_start’, and ‘depart’ activities are located using simple x and y coordinates. The ‘label’ is just for our reference (and can optionally be shown on the plot).\nNow for the magic! We call animate_activity_log with our data:\n# Call the main function! It's showtime!\nmy_animation = animate_activity_log(\n    event_log=event_log_df,\n    event_position_df=event_pos_df\n    # We're using defaults for everything else for now\n)\n\n# To see the animation (usually in a Jupyter Notebook or similar)\n# my_animation.show() # Uncomment this line to display!\nprint(\"Animation created! Use .show() to view it.\")\nThis is the core call! We pass our event_log_df and event_pos_df. The function does its thing and returns a Plotly Figure object (which we store in my_animation). If you were running this in an environment like a Jupyter Notebook, uncommenting my_animation.show() would display the interactive animation! You’d see icons representing Maverick and Goose appear, move to the training area, and then depart.\n\n\n\nWant to make it look cooler? animate_activity_log has many optional arguments. Let’s change the size and add stage labels.\n# Let's make the icons bigger and add labels\nfancy_animation = animate_activity_log(\n    event_log=event_log_df,\n    event_position_df=event_pos_df,\n    icon_and_text_size=30, # Bigger icons!\n    display_stage_labels=True, # Show the 'label' from event_pos_df\n    plotly_height=400 # Make the plot shorter\n)\n\n# fancy_animation.show() # Uncomment to see the fancier version!\nprint(\"Fancier animation created!\")\nSee? By adding a few parameters like icon_and_text_size and display_stage_labels, we can easily customize the output without needing to know the complex plotting commands underneath.\n\n\n\nSo how does animate_activity_log pull this off? It doesn’t actually build the animation frame-by-frame itself. Instead, it acts like a director, calling on specialized helper functions to handle different parts of the job. It’s like how Michael Knight tells K.I.T.T. what to do, and K.I.T.T.’s internal systems handle the driving, scanning, and witty remarks.\nHere’s the basic sequence of events when you call animate_activity_log:\n\nReceive Inputs: The function takes your event_log, event_position_df, and any other parameters you provided.\nSnapshot Prep Part 1 (reshape_for_animations): It calls a helper function (reshape_for_animations) to process the raw event_log. This function figures out who is doing what at regular time intervals (snapshots) throughout your simulation. It’s like taking still photos every few seconds during the action.\nSnapshot Prep Part 2 (generate_animation_df): It then calls another helper (generate_animation_df) which takes those snapshots and uses your event_position_df to calculate the exact (x, y) screen coordinates for every patient in every snapshot. This is like putting markers on the floor telling the actors where to stand in each photo.\nAnimation Generation (generate_animation): Finally, it hands off this fully prepared data (snapshots with positions) to the main animation engine (generate_animation). This function uses Plotly Express to actually build the animated plot, complete with icons moving between positions and a timeline slider. This is the final editing suite putting all the photos together into a movie.\nReturn the Final Cut: The generate_animation function returns the finished Plotly figure, and animate_activity_log passes it back to you.\n\nHere’s a diagram showing this flow:\n\n\n\n\n\nsequenceDiagram\n    participant User\n    participant AAL as animate_activity_log\n    participant RFA as reshape_for_animations\n    participant GADF as generate_animation_df\n    participant GA as generate_animation\n\n    User-&gt;&gt;AAL: Call with event_log, event_position_df, etc.\n    AAL-&gt;&gt;RFA: Process event_log (Take snapshots)\n    RFA--&gt;&gt;AAL: Return reshaped_data (Patient states over time)\n    AAL-&gt;&gt;GADF: Add positions using event_position_df (Place patients)\n    GADF--&gt;&gt;AAL: Return data_with_positions (Patient locations over time)\n    AAL-&gt;&gt;GA: Generate Plotly figure (Make the movie)\n    GA--&gt;&gt;AAL: Return plotly_figure\n    AAL--&gt;&gt;User: Return finished animation!\n\n\n\n\n\n\nInternally, the code looks something like this (highly simplified!):\n# Inside animate_activity_log function... simplified!\ndef animate_activity_log(event_log, event_position_df, scenario=None, ...): # ... means other parameters\n\n    # Step 1: Reshape data (call specialist function)\n    # Input: Raw event log. Output: Table of who is where at each time step.\n    full_patient_df = reshape_for_animations(event_log, ...)\n    # Status report: Got the snapshots!\n\n    # Step 2: Add positions (call another specialist)\n    # Input: Snapshots + Layout. Output: Snapshots with X, Y coordinates.\n    full_patient_df_plus_pos = generate_animation_df(\n        full_patient_df=full_patient_df,\n        event_position_df=event_position_df,\n        ...\n    )\n    # Status report: Actors know their marks!\n\n    # Step 3: Create the animation (final specialist)\n    # Input: Snapshots with positions. Output: Interactive Plotly animation.\n    animation = generate_animation(\n        full_patient_df_plus_pos=full_patient_df_plus_pos,\n        event_position_df=event_position_df,\n        scenario=scenario,\n        ...\n    )\n    # Status report: Rolling film... and cut! That's a wrap!\n\n    return animation # Return the final product to the user\nBy acting as this central coordinator, animate_activity_log saves you from having to call each of these steps individually and pass data between them. It’s your one-stop shop for awesome process animations!\n\n\n\nYou’ve just met the main command console for vidigi: animate_activity_log. It’s your friendly facade, your mission control, the “easy button” that takes your simulation data and layout, and turns it into a dynamic visual story. It orchestrates the behind-the-scenes work of data shaping and plot generation, letting you focus on understanding your process.\nBut this function needs fuel! The most crucial ingredient is the event_log. In the next chapter, we’ll put on our flight suits and dive into exactly what this event log looks like and how to create it.\nFasten your seatbelts! Let’s head to Chapter 2: Event Log.\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 1: Great Scott! Making Animations Easy with `animate_activity_log`"
    ]
  },
  {
    "objectID": "autodoc_v3/01_animation_facade_animate_activity_log_.html#the-mission-visualizing-patient-flow",
    "href": "autodoc_v3/01_animation_facade_animate_activity_log_.html#the-mission-visualizing-patient-flow",
    "title": "Chapter 1: Great Scott! Making Animations Easy with animate_activity_log",
    "section": "",
    "text": "Let’s imagine our mission, should we choose to accept it: we’ve simulated a busy clinic. We have a log showing when each patient (let’s call them “entities” or maybe “units” like Johnny 5) arrived, waited for a nurse, got treated, and left.\nOur goal: Create an animation showing these patients moving through the clinic over time. We want to see the queues build up, watch patients being treated, and get a feel for the flow, all without needing 1.21 gigawatts of programming power!",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 1: Great Scott! Making Animations Easy with `animate_activity_log`"
    ]
  },
  {
    "objectID": "autodoc_v3/01_animation_facade_animate_activity_log_.html#your-trusty-co-pilot-animate_activity_log",
    "href": "autodoc_v3/01_animation_facade_animate_activity_log_.html#your-trusty-co-pilot-animate_activity_log",
    "title": "Chapter 1: Great Scott! Making Animations Easy with animate_activity_log",
    "section": "",
    "text": "The animate_activity_log function is your primary tool in vidigi. It acts as a Facade – a simple, high-level interface that handles a complex process behind the scenes. It’s like the main control panel for the DeLorean; you tell it where you want to go (what data to animate and how), and it handles the tricky bits (flux capacitor calibration not included… yet!).\nIt takes a few key pieces of information:\n\nThe Event Log (event_log): This is the raw script of what happened and when. It’s a table detailing every important step each patient took. We’ll dive deep into this in Chapter 2: Event Log.\nThe Layout (event_position_df): This tells vidigi where each activity (like “Waiting Room” or “Treatment Bay”) should appear on the screen. Think of it as the stage layout or the map for your animation. More on this in Chapter 3: Layout Configuration (event_position_df).\nScenario Details (scenario, optional): Sometimes, you need to tell the animation about the resources available, like how many nurses (or maybe Ghostbusters proton packs) are active. This helps visualize resource capacity.\nCustomization Knobs: Want to change the animation speed? Add a cool background image like the digital world of Tron? Change icon sizes? animate_activity_log has lots of parameters for tweaking the look and feel.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 1: Great Scott! Making Animations Easy with `animate_activity_log`"
    ]
  },
  {
    "objectID": "autodoc_v3/01_animation_facade_animate_activity_log_.html#lets-get-this-show-on-the-road-basic-usage",
    "href": "autodoc_v3/01_animation_facade_animate_activity_log_.html#lets-get-this-show-on-the-road-basic-usage",
    "title": "Chapter 1: Great Scott! Making Animations Easy with animate_activity_log",
    "section": "",
    "text": "Enough talk, let’s see it in action! We need two main things to start: an event_log and an event_position_df. We’ll use super simple placeholder data for now.\nFirst, make sure you have vidigi installed and import the function:\n# Import the main animation function\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd # We use pandas DataFrames\nNow, let’s create a tiny event log. Imagine two patients, Maverick and Goose, going through basic training (arrival, training, departure).\n# Super simple event log (more detail in Chapter 2!)\nevent_data = [\n    {'patient': 'Maverick', 'event': 'arrival', 'time': 0, 'event_type': 'arrival_departure'},\n    {'patient': 'Goose', 'event': 'arrival', 'time': 5, 'event_type': 'arrival_departure'},\n    {'patient': 'Maverick', 'event': 'training_start', 'time': 10, 'event_type': 'resource_use'},\n    {'patient': 'Goose', 'event': 'training_start', 'time': 15, 'event_type': 'resource_use'},\n    {'patient': 'Maverick', 'event': 'training_end', 'time': 50, 'event_type': 'resource_use_end'},\n    {'patient': 'Goose', 'event': 'training_end', 'time': 65, 'event_type': 'resource_use_end'},\n    {'patient': 'Maverick', 'event': 'depart', 'time': 55, 'event_type': 'arrival_departure'},\n    {'patient': 'Goose', 'event': 'depart', 'time': 70, 'event_type': 'arrival_departure'}\n]\nevent_log_df = pd.DataFrame(event_data)\n\nprint(event_log_df.head()) # Show first few rows\nThis code snippet sets up our list of events and converts it into a pandas DataFrame, which is the format vidigi expects. The head() function just shows us the first few rows to check it looks okay.\nNext, we need to tell vidigi where these events happen on the screen using the event_position_df.\n# Simple positions (x, y coordinates - more in Chapter 3!)\nposition_data = [\n    {'event': 'arrival', 'x': 50, 'y': 100, 'label': 'Arrival Zone'},\n    {'event': 'training_start', 'x': 150, 'y': 100, 'label': 'Training Area'},\n    {'event': 'depart', 'x': 250, 'y': 100, 'label': 'Departure Deck'}\n    # Note: We don't need 'training_end' position here\n]\nevent_pos_df = pd.DataFrame(position_data)\n\nprint(event_pos_df)\nHere, we define where the ‘arrival’, ‘training_start’, and ‘depart’ activities are located using simple x and y coordinates. The ‘label’ is just for our reference (and can optionally be shown on the plot).\nNow for the magic! We call animate_activity_log with our data:\n# Call the main function! It's showtime!\nmy_animation = animate_activity_log(\n    event_log=event_log_df,\n    event_position_df=event_pos_df\n    # We're using defaults for everything else for now\n)\n\n# To see the animation (usually in a Jupyter Notebook or similar)\n# my_animation.show() # Uncomment this line to display!\nprint(\"Animation created! Use .show() to view it.\")\nThis is the core call! We pass our event_log_df and event_pos_df. The function does its thing and returns a Plotly Figure object (which we store in my_animation). If you were running this in an environment like a Jupyter Notebook, uncommenting my_animation.show() would display the interactive animation! You’d see icons representing Maverick and Goose appear, move to the training area, and then depart.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 1: Great Scott! Making Animations Easy with `animate_activity_log`"
    ]
  },
  {
    "objectID": "autodoc_v3/01_animation_facade_animate_activity_log_.html#pimp-my-ride-adding-customizations",
    "href": "autodoc_v3/01_animation_facade_animate_activity_log_.html#pimp-my-ride-adding-customizations",
    "title": "Chapter 1: Great Scott! Making Animations Easy with animate_activity_log",
    "section": "",
    "text": "Want to make it look cooler? animate_activity_log has many optional arguments. Let’s change the size and add stage labels.\n# Let's make the icons bigger and add labels\nfancy_animation = animate_activity_log(\n    event_log=event_log_df,\n    event_position_df=event_pos_df,\n    icon_and_text_size=30, # Bigger icons!\n    display_stage_labels=True, # Show the 'label' from event_pos_df\n    plotly_height=400 # Make the plot shorter\n)\n\n# fancy_animation.show() # Uncomment to see the fancier version!\nprint(\"Fancier animation created!\")\nSee? By adding a few parameters like icon_and_text_size and display_stage_labels, we can easily customize the output without needing to know the complex plotting commands underneath.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 1: Great Scott! Making Animations Easy with `animate_activity_log`"
    ]
  },
  {
    "objectID": "autodoc_v3/01_animation_facade_animate_activity_log_.html#whats-under-the-hood-no-need-for-a-mechanic",
    "href": "autodoc_v3/01_animation_facade_animate_activity_log_.html#whats-under-the-hood-no-need-for-a-mechanic",
    "title": "Chapter 1: Great Scott! Making Animations Easy with animate_activity_log",
    "section": "",
    "text": "So how does animate_activity_log pull this off? It doesn’t actually build the animation frame-by-frame itself. Instead, it acts like a director, calling on specialized helper functions to handle different parts of the job. It’s like how Michael Knight tells K.I.T.T. what to do, and K.I.T.T.’s internal systems handle the driving, scanning, and witty remarks.\nHere’s the basic sequence of events when you call animate_activity_log:\n\nReceive Inputs: The function takes your event_log, event_position_df, and any other parameters you provided.\nSnapshot Prep Part 1 (reshape_for_animations): It calls a helper function (reshape_for_animations) to process the raw event_log. This function figures out who is doing what at regular time intervals (snapshots) throughout your simulation. It’s like taking still photos every few seconds during the action.\nSnapshot Prep Part 2 (generate_animation_df): It then calls another helper (generate_animation_df) which takes those snapshots and uses your event_position_df to calculate the exact (x, y) screen coordinates for every patient in every snapshot. This is like putting markers on the floor telling the actors where to stand in each photo.\nAnimation Generation (generate_animation): Finally, it hands off this fully prepared data (snapshots with positions) to the main animation engine (generate_animation). This function uses Plotly Express to actually build the animated plot, complete with icons moving between positions and a timeline slider. This is the final editing suite putting all the photos together into a movie.\nReturn the Final Cut: The generate_animation function returns the finished Plotly figure, and animate_activity_log passes it back to you.\n\nHere’s a diagram showing this flow:\n\n\n\n\n\nsequenceDiagram\n    participant User\n    participant AAL as animate_activity_log\n    participant RFA as reshape_for_animations\n    participant GADF as generate_animation_df\n    participant GA as generate_animation\n\n    User-&gt;&gt;AAL: Call with event_log, event_position_df, etc.\n    AAL-&gt;&gt;RFA: Process event_log (Take snapshots)\n    RFA--&gt;&gt;AAL: Return reshaped_data (Patient states over time)\n    AAL-&gt;&gt;GADF: Add positions using event_position_df (Place patients)\n    GADF--&gt;&gt;AAL: Return data_with_positions (Patient locations over time)\n    AAL-&gt;&gt;GA: Generate Plotly figure (Make the movie)\n    GA--&gt;&gt;AAL: Return plotly_figure\n    AAL--&gt;&gt;User: Return finished animation!\n\n\n\n\n\n\nInternally, the code looks something like this (highly simplified!):\n# Inside animate_activity_log function... simplified!\ndef animate_activity_log(event_log, event_position_df, scenario=None, ...): # ... means other parameters\n\n    # Step 1: Reshape data (call specialist function)\n    # Input: Raw event log. Output: Table of who is where at each time step.\n    full_patient_df = reshape_for_animations(event_log, ...)\n    # Status report: Got the snapshots!\n\n    # Step 2: Add positions (call another specialist)\n    # Input: Snapshots + Layout. Output: Snapshots with X, Y coordinates.\n    full_patient_df_plus_pos = generate_animation_df(\n        full_patient_df=full_patient_df,\n        event_position_df=event_position_df,\n        ...\n    )\n    # Status report: Actors know their marks!\n\n    # Step 3: Create the animation (final specialist)\n    # Input: Snapshots with positions. Output: Interactive Plotly animation.\n    animation = generate_animation(\n        full_patient_df_plus_pos=full_patient_df_plus_pos,\n        event_position_df=event_position_df,\n        scenario=scenario,\n        ...\n    )\n    # Status report: Rolling film... and cut! That's a wrap!\n\n    return animation # Return the final product to the user\nBy acting as this central coordinator, animate_activity_log saves you from having to call each of these steps individually and pass data between them. It’s your one-stop shop for awesome process animations!",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 1: Great Scott! Making Animations Easy with `animate_activity_log`"
    ]
  },
  {
    "objectID": "autodoc_v3/01_animation_facade_animate_activity_log_.html#conclusion-your-animation-journey-begins",
    "href": "autodoc_v3/01_animation_facade_animate_activity_log_.html#conclusion-your-animation-journey-begins",
    "title": "Chapter 1: Great Scott! Making Animations Easy with animate_activity_log",
    "section": "",
    "text": "You’ve just met the main command console for vidigi: animate_activity_log. It’s your friendly facade, your mission control, the “easy button” that takes your simulation data and layout, and turns it into a dynamic visual story. It orchestrates the behind-the-scenes work of data shaping and plot generation, letting you focus on understanding your process.\nBut this function needs fuel! The most crucial ingredient is the event_log. In the next chapter, we’ll put on our flight suits and dive into exactly what this event log looks like and how to create it.\nFasten your seatbelts! Let’s head to Chapter 2: Event Log.\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 1: Great Scott! Making Animations Easy with `animate_activity_log`"
    ]
  },
  {
    "objectID": "autodoc_v3/03_layout_configuration_event_position_df_.html",
    "href": "autodoc_v3/03_layout_configuration_event_position_df_.html",
    "title": "Chapter 3: Where Am I? Mapping the Grid with event_position_df",
    "section": "",
    "text": "Greetings, Program! In Chapter 2: Log Everything! Like K.I.T.T.’s Mission Recorder, we learned how to create the crucial event_log, the detailed script telling us what happened and when in our system (like Maverick’s flight training log). But just knowing when Maverick started waiting for the simulator isn’t enough to make our animation. We need to know where on the screen the “Waiting Area” or the “Simulator Bay” should actually be.\nImagine trying to film Back to the Future without knowing where to put the Clock Tower or the Twin Pines Mall. Chaos! Or trying to navigate the Tron grid without coordinates. Double chaos! We need a map, a blueprint, a layout guide.\nThat’s exactly what the Layout Configuration (event_position_df) provides. It’s the stage map for your vidigi animation movie set.\n\n\nOur mission, should we choose to accept it (and not self-destruct this message), is to define the visual layout for our Top Gun training animation. We need to tell vidigi where the ‘Arrival Zone’, the ‘Waiting Area’, and the ‘Simulator Bays’ should appear on the screen. This allows vidigi to place the icons representing Maverick and Goose correctly as they move through their training steps.\n\n\n\nThe event_position_df is, like the event_log, a pandas DataFrame. It acts as a lookup table, connecting the event names from your log to specific locations and other visual properties on the animation canvas. Think of it as the director’s annotated script, marking where each scene takes place.\nHere are the key columns you’ll typically use:\n\nevent: This column contains the specific event names you used in your Event Log (e.g., ‘arrival’, ‘wait_for_simulator’, ‘start_simulator’, ‘depart’). This is the key vidigi uses to find the right location.\nx: The horizontal coordinate (like on an arcade screen) for this event’s base position. Lower numbers are typically further left.\ny: The vertical coordinate for this event’s base position. Lower numbers are typically higher up on the screen (like typical computer graphics coordinates, not graph paper!).\nlabel: A human-readable name for this stage or activity (e.g., “Arrival Zone”, “Wait for Simulator”, “Simulator Bay”). This is helpful for understanding the layout and can optionally be displayed directly on the animation (using the display_stage_labels=True option in animate_activity_log). Think of it as the sign outside the location, like “Lou’s Cafe” or “Stark Industries”.\nresource (Optional): This column is used for resource_use events (like ‘start_simulator’). It contains the name of the attribute in your scenario object (we’ll discuss scenarios later, think of it as the inventory list from Weyland-Yutani) that holds the total number of available resources for this step (e.g., the name of the variable storing the number of flight simulators). This allows vidigi to draw placeholders for all available resource slots, even if they aren’t currently in use.\n\nImportant Note: You only need to define positions for events where entities stop or start something visually significant: * arrival and depart (mandatory, unless you filter them out later). * queue events (e.g., ‘wait_for_simulator’). * resource_use start events (e.g., ‘start_simulator’). You don’t typically need entries for resource_use_end events (like ‘end_simulator’), as the entity is usually already at the resource location.\n\n\n\nLet’s build the event_position_df for our Top Gun example. We’ll use pandas again.\nimport pandas as pd\n\n# Define the layout data as a list of dictionaries\nposition_data = [\n    # Where pilots first appear\n    {'event': 'arrival', 'x': 50, 'y': 200, 'label': 'Hangar Deck (Arrival)'},\n\n    # Where pilots wait if simulators are busy\n    {'event': 'wait_for_simulator', 'x': 200, 'y': 200, 'label': 'Ready Room (Queue)'},\n\n    # The *base* position for the simulator resource area\n    {'event': 'start_simulator', 'x': 350, 'y': 200, 'label': 'Simulator Bays', 'resource': 'n_simulators'},\n    # ^ We added 'resource' here! Let's assume our scenario object (g) will have g.n_simulators\n\n    # Where pilots go after finishing\n    {'event': 'depart', 'x': 500, 'y': 200, 'label': 'Debriefing (Departure)'},\n\n    # We also need an 'exit' position for vidigi's internal logic\n    {'event': 'exit', 'x': 550, 'y': 200, 'label': 'Off Duty'}\n]\n\n# Convert the list into a pandas DataFrame\nevent_pos_df = pd.DataFrame(position_data)\n\n# Let's beam it up and see what it looks like!\nprint(\"Our Stage Layout Blueprint:\")\nprint(event_pos_df)\nThis code creates our layout definition. * We list each key event name from our Event Log. * We assign x and y coordinates. Think of the screen as a grid; (0, 0) is usually the top-left. Higher x moves right, higher y moves down. * We give each a readable label. * For ‘start_simulator’, we add the resource column, linking it to a hypothetical n_simulators variable in our setup (we’ll see this more in Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)). * We include an ‘exit’ event, which is used internally by vidigi to make entities disappear cleanly.\nThis event_pos_df DataFrame is the second crucial input (after the event_log_df) that you pass to the main animate_activity_log function.\n# --- Hypothetical call to the main function ---\n# (Assuming event_log_df from Chapter 2 and event_pos_df from above exist)\n# (Also assuming a 'scenario' object 'g' exists with g.n_simulators = 2)\n\n# from vidigi.animation import animate_activity_log # If not already imported\n\n# g = YourScenarioClass() # Define g with g.n_simulators = 2\n# g.n_simulators = 2 # Need to define this for the 'resource' column link\n\n# my_animation = animate_activity_log(\n#     event_log=event_log_df,          # The script (What/When)\n#     event_position_df=event_pos_df,  # The stage map (Where)\n#     scenario=g                       # Info about resource counts\n# )\n\n# my_animation.show() # Engage! Show the animation!\n# --- End Hypothetical Call ---\nprint(\"Imagine the animation running with this layout!\")\nIf you ran this (with the actual data and scenario setup), vidigi would use event_pos_df to place the icons for Maverick and Goose at the ‘Hangar Deck’ (50, 200), then move them to the ‘Ready Room’ (base X=200, Y=200) if they queue, or to one of the ‘Simulator Bays’ (base X=350, Y=200) when they start training, and finally to ‘Debriefing’ (500, 200).\n\n\n\nSo, how does vidigi use this blueprint? It doesn’t build the set itself, but it tells the actors (our patient/pilot icons) where to stand based on the script (event_log) and the map (event_position_df).\nThe key function that uses the event_position_df is generate_animation_df. Remember from Chapter 1 that the event_log gets processed into “snapshots” – a table showing which event each patient is currently experiencing at each moment in time.\ngenerate_animation_df takes these snapshots and the event_position_df and does the following:\n\nLookup: For each patient in each time snapshot, it looks at their current event.\nMerge: It finds the matching event row in the event_position_df.\nGet Base Position: It retrieves the base x and y coordinates from that row.\nCalculate Final Position: This is where it gets clever, like Johnny 5 calculating trajectories:\n\nIf the event_type is arrival_departure or resource_use_end (or anything not queue/resource use), the final position is usually just the base (x, y).\nIf the event_type is queue, it calculates an offset. Patients in a queue typically line up to the left of the base x coordinate. The first patient might be at x - gap, the second at x - 2*gap, and so on. If the queue gets too long (wrap_queues_at), it starts a new row below.\nIf the event_type is resource_use, it uses the resource_id (from the event log, e.g., ‘Sim_1’, ‘Sim_2’) to calculate an offset from the base x. Resource 1 might be at x - gap, Resource 2 at x - 2*gap, etc., again wrapping if needed (wrap_resources_at). This ensures Maverick always appears at the same simulator bay (‘Sim_1’) while using it.\n\n\nHere’s a simplified sequence diagram:\n\n\n\n\n\nsequenceDiagram\n    participant Snapshots as Snapshot Data (Patient, Event, Time, Type, ResourceID?)\n    participant GADF as generate_animation_df\n    participant Layout as event_position_df\n    participant Output as Data with Positions (X, Y added)\n\n    GADF-&gt;&gt;Snapshots: Receive snapshot data for a time point\n    loop For each patient in snapshot\n        GADF-&gt;&gt;Layout: Find row where Layout.event == Snapshot.event\n        Layout--&gt;&gt;GADF: Return matching row (with base X, Y, Type)\n        alt event_type is 'queue'\n            GADF-&gt;&gt;GADF: Calculate queue position (e.g., base_x - rank * gap)\n        else event_type is 'resource_use'\n            GADF-&gt;&gt;GADF: Calculate resource position (e.g., base_x - resource_id * gap)\n        else Other types\n            GADF-&gt;&gt;GADF: Use base position (x, y)\n        end\n        GADF-&gt;&gt;Output: Store patient, time, calculated X, Y, etc.\n    end\n    Output--&gt;&gt;GADF: Complete data with positions for this time point\n\n\n\n\n\n\nThe generate_animation function also uses event_position_df, primarily to: * Draw the optional stage labels (display_stage_labels=True). * Draw the placeholder icons for all available resources (using the resource column and the linked scenario object) so you can see empty slots.\nInternally, the code within vidigi/prep.py (specifically generate_animation_df) might look conceptually like this:\n# --- Inside generate_animation_df (Simplified Concept) ---\n# (Input: full_patient_df = snapshots, event_position_df = layout)\nimport pandas as pd\nimport numpy as np # For calculations\n\ndef calculate_positions(full_patient_df, event_position_df, gap_between_entities, wrap_queues_at, gap_between_rows):\n\n    # Merge snapshots with layout info based on the 'event' name\n    df_with_base_pos = pd.merge(full_patient_df, event_position_df, on='event', how='left')\n\n    # --- Calculate Queue Positions ---\n    queues = df_with_base_pos[df_with_base_pos['event_type'] == 'queue'].copy()\n    if not queues.empty:\n        # 'rank' tells us position in queue (1st, 2nd, etc.) - calculated earlier\n        queues['row'] = np.floor((queues['rank'] - 1) / wrap_queues_at)\n        # Base X minus offset for position in line, adjusted for wrapping\n        queues['x_final'] = queues['x'] - (queues['rank'] % wrap_queues_at) * gap_between_entities # Simplified!\n        # Base Y plus offset for row wrapping\n        queues['y_final'] = queues['y'] + queues['row'] * gap_between_rows\n\n    # --- Calculate Resource Positions (Similar logic using resource_id) ---\n    resources = df_with_base_pos[df_with_base_pos['event_type'] == 'resource_use'].copy()\n    # ... similar calculations for resources['x_final'], resources['y_final'] using resource_id ...\n    # Simplified: Assume resources just use base position for this example\n    if not resources.empty:\n        resources['x_final'] = resources['x']\n        resources['y_final'] = resources['y']\n\n\n    # --- Handle other event types (e.g., arrival, depart) ---\n    others = df_with_base_pos[~df_with_base_pos['event_type'].isin(['queue', 'resource_use'])].copy()\n    if not others.empty:\n        others['x_final'] = others['x'] # Just use the base position\n        others['y_final'] = others['y']\n\n    # Combine back into one DataFrame\n    final_df = pd.concat([queues, resources, others], ignore_index=True)\n    return final_df\n\n# (Output: final_df contains the original snapshot data plus 'x_final' and 'y_final' columns)\nThis simplified snippet shows the core idea: merge the layout’s base coordinates, then adjust them based on the event type and ranking/resource ID to get the final plotting position.\n\n\n\nYeah! You’ve now grasped the event_position_df, the essential blueprint that tells vidigi where to place everything in your animation. It maps your logical event names (like ‘wait_for_simulator’) to physical screen coordinates (X, Y), provides labels, and even helps visualize resource capacity.\nCombined with the Event Log (the “What” and “When”), the event_position_df (the “Where”) gives vidigi almost everything it needs to create your visual masterpiece via the Animation Facade (animate_activity_log).\nBut what about those resources? How do we properly represent things like nurses, simulators, or maybe even proton packs that entities need to use? And how does that resource_id in the event log get generated? We need to enhance our simulation model slightly.\nDon’t have a cow, man! Let’s find out in the next chapter: Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store).\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 3: Where Am I? Mapping the Grid with `event_position_df`"
    ]
  },
  {
    "objectID": "autodoc_v3/03_layout_configuration_event_position_df_.html#the-mission-setting-the-stage",
    "href": "autodoc_v3/03_layout_configuration_event_position_df_.html#the-mission-setting-the-stage",
    "title": "Chapter 3: Where Am I? Mapping the Grid with event_position_df",
    "section": "",
    "text": "Our mission, should we choose to accept it (and not self-destruct this message), is to define the visual layout for our Top Gun training animation. We need to tell vidigi where the ‘Arrival Zone’, the ‘Waiting Area’, and the ‘Simulator Bays’ should appear on the screen. This allows vidigi to place the icons representing Maverick and Goose correctly as they move through their training steps.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 3: Where Am I? Mapping the Grid with `event_position_df`"
    ]
  },
  {
    "objectID": "autodoc_v3/03_layout_configuration_event_position_df_.html#the-blueprint-anatomy-of-the-event_position_df",
    "href": "autodoc_v3/03_layout_configuration_event_position_df_.html#the-blueprint-anatomy-of-the-event_position_df",
    "title": "Chapter 3: Where Am I? Mapping the Grid with event_position_df",
    "section": "",
    "text": "The event_position_df is, like the event_log, a pandas DataFrame. It acts as a lookup table, connecting the event names from your log to specific locations and other visual properties on the animation canvas. Think of it as the director’s annotated script, marking where each scene takes place.\nHere are the key columns you’ll typically use:\n\nevent: This column contains the specific event names you used in your Event Log (e.g., ‘arrival’, ‘wait_for_simulator’, ‘start_simulator’, ‘depart’). This is the key vidigi uses to find the right location.\nx: The horizontal coordinate (like on an arcade screen) for this event’s base position. Lower numbers are typically further left.\ny: The vertical coordinate for this event’s base position. Lower numbers are typically higher up on the screen (like typical computer graphics coordinates, not graph paper!).\nlabel: A human-readable name for this stage or activity (e.g., “Arrival Zone”, “Wait for Simulator”, “Simulator Bay”). This is helpful for understanding the layout and can optionally be displayed directly on the animation (using the display_stage_labels=True option in animate_activity_log). Think of it as the sign outside the location, like “Lou’s Cafe” or “Stark Industries”.\nresource (Optional): This column is used for resource_use events (like ‘start_simulator’). It contains the name of the attribute in your scenario object (we’ll discuss scenarios later, think of it as the inventory list from Weyland-Yutani) that holds the total number of available resources for this step (e.g., the name of the variable storing the number of flight simulators). This allows vidigi to draw placeholders for all available resource slots, even if they aren’t currently in use.\n\nImportant Note: You only need to define positions for events where entities stop or start something visually significant: * arrival and depart (mandatory, unless you filter them out later). * queue events (e.g., ‘wait_for_simulator’). * resource_use start events (e.g., ‘start_simulator’). You don’t typically need entries for resource_use_end events (like ‘end_simulator’), as the entity is usually already at the resource location.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 3: Where Am I? Mapping the Grid with `event_position_df`"
    ]
  },
  {
    "objectID": "autodoc_v3/03_layout_configuration_event_position_df_.html#creating-your-layout-engage",
    "href": "autodoc_v3/03_layout_configuration_event_position_df_.html#creating-your-layout-engage",
    "title": "Chapter 3: Where Am I? Mapping the Grid with event_position_df",
    "section": "",
    "text": "Let’s build the event_position_df for our Top Gun example. We’ll use pandas again.\nimport pandas as pd\n\n# Define the layout data as a list of dictionaries\nposition_data = [\n    # Where pilots first appear\n    {'event': 'arrival', 'x': 50, 'y': 200, 'label': 'Hangar Deck (Arrival)'},\n\n    # Where pilots wait if simulators are busy\n    {'event': 'wait_for_simulator', 'x': 200, 'y': 200, 'label': 'Ready Room (Queue)'},\n\n    # The *base* position for the simulator resource area\n    {'event': 'start_simulator', 'x': 350, 'y': 200, 'label': 'Simulator Bays', 'resource': 'n_simulators'},\n    # ^ We added 'resource' here! Let's assume our scenario object (g) will have g.n_simulators\n\n    # Where pilots go after finishing\n    {'event': 'depart', 'x': 500, 'y': 200, 'label': 'Debriefing (Departure)'},\n\n    # We also need an 'exit' position for vidigi's internal logic\n    {'event': 'exit', 'x': 550, 'y': 200, 'label': 'Off Duty'}\n]\n\n# Convert the list into a pandas DataFrame\nevent_pos_df = pd.DataFrame(position_data)\n\n# Let's beam it up and see what it looks like!\nprint(\"Our Stage Layout Blueprint:\")\nprint(event_pos_df)\nThis code creates our layout definition. * We list each key event name from our Event Log. * We assign x and y coordinates. Think of the screen as a grid; (0, 0) is usually the top-left. Higher x moves right, higher y moves down. * We give each a readable label. * For ‘start_simulator’, we add the resource column, linking it to a hypothetical n_simulators variable in our setup (we’ll see this more in Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)). * We include an ‘exit’ event, which is used internally by vidigi to make entities disappear cleanly.\nThis event_pos_df DataFrame is the second crucial input (after the event_log_df) that you pass to the main animate_activity_log function.\n# --- Hypothetical call to the main function ---\n# (Assuming event_log_df from Chapter 2 and event_pos_df from above exist)\n# (Also assuming a 'scenario' object 'g' exists with g.n_simulators = 2)\n\n# from vidigi.animation import animate_activity_log # If not already imported\n\n# g = YourScenarioClass() # Define g with g.n_simulators = 2\n# g.n_simulators = 2 # Need to define this for the 'resource' column link\n\n# my_animation = animate_activity_log(\n#     event_log=event_log_df,          # The script (What/When)\n#     event_position_df=event_pos_df,  # The stage map (Where)\n#     scenario=g                       # Info about resource counts\n# )\n\n# my_animation.show() # Engage! Show the animation!\n# --- End Hypothetical Call ---\nprint(\"Imagine the animation running with this layout!\")\nIf you ran this (with the actual data and scenario setup), vidigi would use event_pos_df to place the icons for Maverick and Goose at the ‘Hangar Deck’ (50, 200), then move them to the ‘Ready Room’ (base X=200, Y=200) if they queue, or to one of the ‘Simulator Bays’ (base X=350, Y=200) when they start training, and finally to ‘Debriefing’ (500, 200).",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 3: Where Am I? Mapping the Grid with `event_position_df`"
    ]
  },
  {
    "objectID": "autodoc_v3/03_layout_configuration_event_position_df_.html#under-the-hood-how-vidigi-uses-the-layout",
    "href": "autodoc_v3/03_layout_configuration_event_position_df_.html#under-the-hood-how-vidigi-uses-the-layout",
    "title": "Chapter 3: Where Am I? Mapping the Grid with event_position_df",
    "section": "",
    "text": "So, how does vidigi use this blueprint? It doesn’t build the set itself, but it tells the actors (our patient/pilot icons) where to stand based on the script (event_log) and the map (event_position_df).\nThe key function that uses the event_position_df is generate_animation_df. Remember from Chapter 1 that the event_log gets processed into “snapshots” – a table showing which event each patient is currently experiencing at each moment in time.\ngenerate_animation_df takes these snapshots and the event_position_df and does the following:\n\nLookup: For each patient in each time snapshot, it looks at their current event.\nMerge: It finds the matching event row in the event_position_df.\nGet Base Position: It retrieves the base x and y coordinates from that row.\nCalculate Final Position: This is where it gets clever, like Johnny 5 calculating trajectories:\n\nIf the event_type is arrival_departure or resource_use_end (or anything not queue/resource use), the final position is usually just the base (x, y).\nIf the event_type is queue, it calculates an offset. Patients in a queue typically line up to the left of the base x coordinate. The first patient might be at x - gap, the second at x - 2*gap, and so on. If the queue gets too long (wrap_queues_at), it starts a new row below.\nIf the event_type is resource_use, it uses the resource_id (from the event log, e.g., ‘Sim_1’, ‘Sim_2’) to calculate an offset from the base x. Resource 1 might be at x - gap, Resource 2 at x - 2*gap, etc., again wrapping if needed (wrap_resources_at). This ensures Maverick always appears at the same simulator bay (‘Sim_1’) while using it.\n\n\nHere’s a simplified sequence diagram:\n\n\n\n\n\nsequenceDiagram\n    participant Snapshots as Snapshot Data (Patient, Event, Time, Type, ResourceID?)\n    participant GADF as generate_animation_df\n    participant Layout as event_position_df\n    participant Output as Data with Positions (X, Y added)\n\n    GADF-&gt;&gt;Snapshots: Receive snapshot data for a time point\n    loop For each patient in snapshot\n        GADF-&gt;&gt;Layout: Find row where Layout.event == Snapshot.event\n        Layout--&gt;&gt;GADF: Return matching row (with base X, Y, Type)\n        alt event_type is 'queue'\n            GADF-&gt;&gt;GADF: Calculate queue position (e.g., base_x - rank * gap)\n        else event_type is 'resource_use'\n            GADF-&gt;&gt;GADF: Calculate resource position (e.g., base_x - resource_id * gap)\n        else Other types\n            GADF-&gt;&gt;GADF: Use base position (x, y)\n        end\n        GADF-&gt;&gt;Output: Store patient, time, calculated X, Y, etc.\n    end\n    Output--&gt;&gt;GADF: Complete data with positions for this time point\n\n\n\n\n\n\nThe generate_animation function also uses event_position_df, primarily to: * Draw the optional stage labels (display_stage_labels=True). * Draw the placeholder icons for all available resources (using the resource column and the linked scenario object) so you can see empty slots.\nInternally, the code within vidigi/prep.py (specifically generate_animation_df) might look conceptually like this:\n# --- Inside generate_animation_df (Simplified Concept) ---\n# (Input: full_patient_df = snapshots, event_position_df = layout)\nimport pandas as pd\nimport numpy as np # For calculations\n\ndef calculate_positions(full_patient_df, event_position_df, gap_between_entities, wrap_queues_at, gap_between_rows):\n\n    # Merge snapshots with layout info based on the 'event' name\n    df_with_base_pos = pd.merge(full_patient_df, event_position_df, on='event', how='left')\n\n    # --- Calculate Queue Positions ---\n    queues = df_with_base_pos[df_with_base_pos['event_type'] == 'queue'].copy()\n    if not queues.empty:\n        # 'rank' tells us position in queue (1st, 2nd, etc.) - calculated earlier\n        queues['row'] = np.floor((queues['rank'] - 1) / wrap_queues_at)\n        # Base X minus offset for position in line, adjusted for wrapping\n        queues['x_final'] = queues['x'] - (queues['rank'] % wrap_queues_at) * gap_between_entities # Simplified!\n        # Base Y plus offset for row wrapping\n        queues['y_final'] = queues['y'] + queues['row'] * gap_between_rows\n\n    # --- Calculate Resource Positions (Similar logic using resource_id) ---\n    resources = df_with_base_pos[df_with_base_pos['event_type'] == 'resource_use'].copy()\n    # ... similar calculations for resources['x_final'], resources['y_final'] using resource_id ...\n    # Simplified: Assume resources just use base position for this example\n    if not resources.empty:\n        resources['x_final'] = resources['x']\n        resources['y_final'] = resources['y']\n\n\n    # --- Handle other event types (e.g., arrival, depart) ---\n    others = df_with_base_pos[~df_with_base_pos['event_type'].isin(['queue', 'resource_use'])].copy()\n    if not others.empty:\n        others['x_final'] = others['x'] # Just use the base position\n        others['y_final'] = others['y']\n\n    # Combine back into one DataFrame\n    final_df = pd.concat([queues, resources, others], ignore_index=True)\n    return final_df\n\n# (Output: final_df contains the original snapshot data plus 'x_final' and 'y_final' columns)\nThis simplified snippet shows the core idea: merge the layout’s base coordinates, then adjust them based on the event type and ranking/resource ID to get the final plotting position.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 3: Where Am I? Mapping the Grid with `event_position_df`"
    ]
  },
  {
    "objectID": "autodoc_v3/03_layout_configuration_event_position_df_.html#conclusion-you-have-the-touch-you-have-the-power",
    "href": "autodoc_v3/03_layout_configuration_event_position_df_.html#conclusion-you-have-the-touch-you-have-the-power",
    "title": "Chapter 3: Where Am I? Mapping the Grid with event_position_df",
    "section": "",
    "text": "Yeah! You’ve now grasped the event_position_df, the essential blueprint that tells vidigi where to place everything in your animation. It maps your logical event names (like ‘wait_for_simulator’) to physical screen coordinates (X, Y), provides labels, and even helps visualize resource capacity.\nCombined with the Event Log (the “What” and “When”), the event_position_df (the “Where”) gives vidigi almost everything it needs to create your visual masterpiece via the Animation Facade (animate_activity_log).\nBut what about those resources? How do we properly represent things like nurses, simulators, or maybe even proton packs that entities need to use? And how does that resource_id in the event log get generated? We need to enhance our simulation model slightly.\nDon’t have a cow, man! Let’s find out in the next chapter: Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store).\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 3: Where Am I? Mapping the Grid with `event_position_df`"
    ]
  },
  {
    "objectID": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html",
    "href": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html",
    "title": "Chapter 5: Prepare for Snapshots, McFly! (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Greetings, Programs! In Chapter 4: More Input! Giving Your Resources an Upgrade (CustomResource, Store, populate_store), we learned how to give our resources unique IDs, like giving each Cylon a distinct serial number, so we can track exactly which resource (like ‘Nurse_1’ or ‘Sim_2’) is being used. We ensured our Event Log now captures this crucial resource_id.\nBut our event_log is still just a chronological list of things that happened – like a mission diary dictated into K.I.T.T.’s recorder. It tells us when Maverick started waiting, when he got ‘Sim_1’, when he finished. To make an animation, we need something more structured. We need to know exactly who is exactly where at specific moments in time, like freezing frames in a movie. We need to turn that diary into a series of snapshots, ready for the big screen!\nThis is where the dynamic duo of data transformation comes in: reshape_for_animations and generate_animation_df. Think of them as the unsung heroes working behind the scenes, like the techs prepping the DeLorean or the crew setting up the shots for Top Gun.\n\n\nImagine you have K.I.T.T.’s complete sensor logs for a day. It’s just a long list: “10:01: Scanned sector Alpha”, “10:03: Detected suspicious activity”, “10:05: Engaged Turbo Boost”. To make a visual replay, you don’t just want the list; you want to see K.I.T.T.’s position and status on a map every, say, 10 seconds.\nThat’s our goal here. We take the raw Event Log (the diary) and transform it into a frame-by-frame description of the system state (the movie reel).\n\nreshape_for_animations: Figures out who is doing what event at regular time intervals (our snapshots).\ngenerate_animation_df: Calculates the precise X, Y coordinates for each entity in each snapshot, based on their event, status (queuing/using resource), and the Layout Configuration (event_position_df).\n\nThese functions are usually called automatically by the main animate_activity_log function, but understanding them helps you see how the magic happens!\n\n\n\nThis function is like hitting pause on your VCR at regular intervals during Back to the Future to see where Marty, Doc, and the Libyans are at that exact moment.\nPurpose: To convert the continuous stream of events into discrete snapshots in time.\nInput: The Event Log DataFrame.\nOutput: A new DataFrame. Each row represents a specific patient at a specific minute (or whatever every_x_time_units you choose). It tells you the event they were last recorded doing before or at that minute. It also calculates their rank if multiple patients are doing the same event (e.g., who is 1st, 2nd, 3rd in the ‘wait_for_simulator’ queue at that minute).\nLet’s imagine a tiny piece of our Top Gun Event Log:\n# --- Input Event Log (Simplified) ---\nevent_data = [\n    {'patient': 'Maverick', 'event': 'arrival', 'time': 0, 'event_type': 'arrival_departure'},\n    {'patient': 'Goose', 'event': 'arrival', 'time': 5, 'event_type': 'arrival_departure'},\n    {'patient': 'Maverick', 'event': 'wait_for_simulator', 'time': 1, 'event_type': 'queue'},\n    {'patient': 'Goose', 'event': 'wait_for_simulator', 'time': 6, 'event_type': 'queue'},\n    {'patient': 'Maverick', 'event': 'start_simulator', 'time': 10, 'event_type': 'resource_use', 'resource_id': 'Sim_1'},\n    {'patient': 'Goose', 'event': 'start_simulator', 'time': 15, 'event_type': 'resource_use', 'resource_id': 'Sim_2'}\n]\nevent_log_df = pd.DataFrame(event_data)\n# --- End Input ---\nIf we call reshape_for_animations (conceptually, with every_x_time_units=5), it might produce snapshots like this:\n# --- Output Snapshots (Conceptual from reshape_for_animations) ---\nsnapshot_data = [\n    # Minute 0: Only Maverick arrived\n    {'minute': 0, 'patient': 'Maverick', 'event': 'arrival', 'event_type': 'arrival_departure', 'rank': 1.0},\n    # Minute 5: Maverick is waiting, Goose just arrived\n    {'minute': 5, 'patient': 'Maverick', 'event': 'wait_for_simulator', 'event_type': 'queue', 'rank': 1.0},\n    {'minute': 5, 'patient': 'Goose', 'event': 'arrival', 'event_type': 'arrival_departure', 'rank': 1.0},\n    # Minute 10: Maverick started Sim 1, Goose is now waiting (rank 1 in queue)\n    {'minute': 10, 'patient': 'Maverick', 'event': 'start_simulator', 'event_type': 'resource_use', 'resource_id': 'Sim_1', 'rank': 1.0},\n    {'minute': 10, 'patient': 'Goose', 'event': 'wait_for_simulator', 'event_type': 'queue', 'rank': 1.0},\n    # Minute 15: Maverick still in Sim 1, Goose started Sim 2\n    {'minute': 15, 'patient': 'Maverick', 'event': 'start_simulator', 'event_type': 'resource_use', 'resource_id': 'Sim_1', 'rank': 1.0},\n    {'minute': 15, 'patient': 'Goose', 'event': 'start_simulator', 'event_type': 'resource_use', 'resource_id': 'Sim_2', 'rank': 2.0} # Note: Rank might be based on resource_id here\n]\nreshaped_df = pd.DataFrame(snapshot_data)\nprint(reshaped_df)\n# --- End Output ---\nThis reshaped_df tells us exactly who was doing what at each 5-minute interval. It’s the foundation for our animation frames!\n\n\n\nOkay, we have our snapshots telling us who is doing what and when. Now we need to figure out where they should be on the screen. This function is like the director telling the actors their exact marks on the stage floor, using the script (snapshots) and the set design (Layout Configuration (event_position_df)).\nPurpose: To calculate the final X and Y screen coordinates for each entity in each snapshot.\nInput: 1. The snapshot DataFrame produced by reshape_for_animations. 2. The Layout Configuration (event_position_df) DataFrame.\nOutput: A DataFrame almost identical to the input snapshot DataFrame, but with crucial new columns: * x_final: The calculated horizontal position. * y_final: The calculated vertical position. * icon: An assigned emoji icon for the entity (like giving each Smurf a unique hat… wait, wrong reference… like giving each Autobot a unique symbol!).\nIt uses the event, event_type, rank, and resource_id from the snapshot, along with the base x and y from the layout, to determine the final position.\n\nSimple Events: (like ‘arrival’, ‘depart’) often just use the base X, Y from the layout.\nQueues: Patients line up. The rank determines their position in the line (e.g., rank 1 is at base_x - gap, rank 2 at base_x - 2*gap). It can even wrap the queue into multiple rows like the aliens in Space Invaders if it gets too long!\nResource Use: The position is calculated based on the specific resource_id (e.g., ‘Sim_1’ might be at base_x - gap, ‘Sim_2’ at base_x - 2*gap). This ensures Maverick always appears at the same simulator spot when using ‘Sim_1’.\n\nLet’s take one snapshot from our previous example (Minute 10) and imagine our layout:\n# --- Input Snapshot Row (Minute 10) ---\nsnapshot_row_mav = {'minute': 10, 'patient': 'Maverick', 'event': 'start_simulator', 'event_type': 'resource_use', 'resource_id': 'Sim_1', 'rank': 1.0}\nsnapshot_row_goose = {'minute': 10, 'patient': 'Goose', 'event': 'wait_for_simulator', 'event_type': 'queue', 'rank': 1.0}\n\n# --- Input Layout Info (Simplified) ---\nlayout_info = {\n    'start_simulator': {'x': 350, 'y': 200},\n    'wait_for_simulator': {'x': 200, 'y': 200}\n}\n# --- Assume gap_between_entities = 10, gap_between_resources = 20 ---\ngap_entities = 10\ngap_resources = 20\ngenerate_animation_df would process these rows:\n# --- Output with Positions (Conceptual from generate_animation_df) ---\n\n# Maverick (Resource Use): Position depends on resource_id (Sim_1 is ID 1)\nmav_x_final = layout_info['start_simulator']['x'] - (1 * gap_resources) # 350 - 20 = 330\nmav_y_final = layout_info['start_simulator']['y'] # 200\noutput_row_mav = {**snapshot_row_mav, 'x_final': mav_x_final, 'y_final': mav_y_final, 'icon': '🧔🏼'}\n\n# Goose (Queue): Position depends on rank (Rank 1)\ngoose_x_final = layout_info['wait_for_simulator']['x'] - (1 * gap_entities) # 200 - 10 = 190\ngoose_y_final = layout_info['wait_for_simulator']['y'] # 200\noutput_row_goose = {**snapshot_row_goose, 'x_final': goose_x_final, 'y_final': goose_y_final, 'icon': '👨🏻‍🦰'}\n\nprint(output_row_mav)\nprint(output_row_goose)\n# --- End Output ---\nNow, each entity in each snapshot has precise coordinates and an icon. This is the data that directly feeds the animation engine! It’s like having the final shooting script with exact camera angles and actor positions marked.\n\n\n\nRemember the flow from Chapter 1: Great Scott! Making Animations Easy with animate_activity_log? reshape_for_animations and generate_animation_df are the crucial middle steps orchestrated by the main function:\n\n\n\n\n\nsequenceDiagram\n    participant AAL as animate_activity_log\n    participant RFA as reshape_for_animations\n    participant GADF as generate_animation_df\n    participant GA as generate_animation\n\n    AAL-&gt;&gt;RFA: Call with event_log\n    Note over RFA: Process log into time snapshots (who/what/when)\n    RFA--&gt;&gt;AAL: Return reshaped_df (Snapshots)\n    AAL-&gt;&gt;GADF: Call with reshaped_df & event_position_df\n    Note over GADF: Calculate final X,Y positions based on event, rank, resource_id & layout. Assign icons.\n    GADF--&gt;&gt;AAL: Return data_with_positions (Animation-ready data)\n    AAL-&gt;&gt;GA: Call with data_with_positions\n    GA--&gt;&gt;AAL: Return Plotly Figure\n\n\n\n\n\n\nThese two functions handle all the complex data wrangling, turning your raw simulation output into perfectly formatted input for the final animation step.\n\n\n\nLet’s peek briefly at the circuits inside vidigi/prep.py where these functions live. No need to grab your screwdriver like Stephanie trying to fix Number 5!\n\n\nConceptually, this function works like this:\n\nPivot Log: It first reshapes the event log slightly to easily find the ‘arrival’ and ‘depart’ times for each patient.\nIterate Through Time: It loops through time, usually in steps defined by every_x_time_units (e.g., 0, 10, 20…).\nFind Active Patients: At each minute, it identifies patients who have arrived before or at this minute and have departed after this minute (or haven’t departed yet). These are the patients “on screen” at this time.\nGet Latest Event: For each active patient, it looks back through their event history up to this minute and finds their single most recent event. This defines their current state (e.g., ‘wait_for_simulator’ or ‘start_simulator’).\nRank Patients: If multiple patients are in the same state (e.g., multiple people in the ‘wait_for_simulator’ queue), it ranks them based on when they entered that state (using the original event log index as a tie-breaker).\nLimit Snapshot Size: It might cap the number of patients shown per event per snapshot (step_snapshot_max) to keep things tidy.\nStore Snapshot: It stores the state (event, type, rank, etc.) for all active patients at this minute.\nAdd Exit Step: After processing all minutes, it adds a final ‘exit’ event for each patient slightly after their last recorded event, ensuring they visually leave the screen.\nCombine & Return: It combines all the snapshots into one big DataFrame.\n\nHere’s a simplified conceptual code snippet:\n# --- Inside reshape_for_animations (Conceptual - vidigi/prep.py) ---\nimport pandas as pd\n\ndef reshape_for_animations_simplified(event_log, every_x_time_units):\n    all_snapshots = []\n    # Get arrival/departure times easily (details omitted)\n    pivoted_log = event_log.pivot_table(...)\n\n    max_time = event_log['time'].max() # Find simulation end time\n\n    # Loop through time in steps\n    for minute in range(0, max_time + every_x_time_units, every_x_time_units):\n\n        # Find patients active at this 'minute' (details omitted)\n        active_patients = find_active_patients(pivoted_log, minute)\n\n        if active_patients:\n            # Get all events for active patients up to 'minute'\n            relevant_events = event_log[\n                (event_log['patient'].isin(active_patients)) &\n                (event_log['time'] &lt;= minute)\n            ]\n\n            # Find the single latest event for each patient\n            latest_states = relevant_events.sort_values('time').groupby('patient').tail(1)\n\n            # Rank patients within the same event (e.g., queue order)\n            latest_states['rank'] = latest_states.groupby('event')['time'].rank(method='first')\n\n            # Add the current minute to the snapshot data\n            latest_states['minute'] = minute\n            all_snapshots.append(latest_states)\n\n    # Combine all snapshots into one DataFrame\n    full_patient_df = pd.concat(all_snapshots, ignore_index=True)\n\n    # Add a final 'exit' step for cleanup (details omitted)\n    full_patient_df = add_final_exit_step(full_patient_df, every_x_time_units)\n\n    return full_patient_df.sort_values([\"minute\", \"event\"])\n# --- End Conceptual Code ---\n\n\n\nThis function takes the snapshots and layout and calculates positions:\n\nMerge Layout: It merges the snapshot DataFrame with the Layout Configuration (event_position_df) based on the event name. Now each snapshot row knows the base X and Y for its event.\nSeparate by Type: It often handles different event_type groups separately (queues, resource use, others).\nCalculate Queue Positions:\n\nFor queue events, it calculates the row and column within the queue based on the rank and the wrap_queues_at parameter.\nIt computes x_final by subtracting an offset (based on column and gap_between_entities) from the base x.\nIt computes y_final by adding an offset (based on row and gap_between_rows) to the base y.\n\nCalculate Resource Positions:\n\nFor resource_use events, it uses the resource_id (which is usually numeric after populate_store) and wrap_resources_at similarly to calculate row and column.\nIt computes x_final and y_final using offsets based on the resource’s column/row and gap_between_resources/gap_between_rows.\n\nHandle Other Events: For arrivals, departures, etc., x_final and y_final are usually just set to the base x and y.\nAssign Icons: It assigns a unique icon from a list (you can provide a custom_entity_icon_list) to each unique patient ID. Think of it like the machine in Short Circuit assigning laser targets – but with emojis!\nCombine & Return: It concatenates the processed groups back into a single DataFrame with x_final, y_final, and icon columns added.\n\nSimplified conceptual code:\n# --- Inside generate_animation_df (Conceptual - vidigi/prep.py) ---\nimport pandas as pd\nimport numpy as np\n\ndef generate_animation_df_simplified(snapshots_df, layout_df, wrap_queues_at, gap_entities, gap_rows):\n\n    # Merge snapshots with layout base positions\n    df_with_base_pos = pd.merge(snapshots_df, layout_df, on='event', how='left')\n\n    # --- Process Queues ---\n    queues = df_with_base_pos[df_with_base_pos['event_type'] == 'queue'].copy()\n    if not queues.empty:\n        # Calculate row number (0-based)\n        queues['row'] = np.floor((queues['rank'] - 1) / wrap_queues_at)\n        # Calculate position within the row (0-based, adjusted for rank starting at 1)\n        queues['col_in_row'] = (queues['rank'] - 1) % wrap_queues_at\n        # Calculate final positions\n        queues['x_final'] = queues['x'] - queues['col_in_row'] * gap_entities\n        queues['y_final'] = queues['y'] + queues['row'] * gap_rows\n\n    # --- Process Resources (Similar logic using resource_id) ---\n    resources = df_with_base_pos[df_with_base_pos['event_type'] == 'resource_use'].copy()\n    # ... similar x_final, y_final calculation using resource_id ...\n    if not resources.empty:\n        # Simplified: Assume base position for this example\n        resources['x_final'] = resources['x']\n        resources['y_final'] = resources['y']\n\n\n    # --- Process Others ---\n    others = df_with_base_pos[~df_with_base_pos['event_type'].isin(['queue', 'resource_use'])].copy()\n    if not others.empty:\n        others['x_final'] = others['x']\n        others['y_final'] = others['y']\n\n    # Combine results\n    final_df = pd.concat([queues, resources, others], ignore_index=True)\n\n    # Assign icons to patients (details omitted)\n    final_df = assign_icons(final_df)\n\n    return final_df\n# --- End Conceptual Code ---\nThese functions do the heavy lifting of data preparation so the final animation step can be smooth as hover-converting a DeLorean.\n\n\n\n\nWhoa, heavy! We’ve seen how vidigi takes the raw Event Log – our simulation’s diary – and uses the tag team of reshape_for_animations and generate_animation_df to turn it into perfectly structured, animation-ready data.\n\nreshape_for_animations acts like a time machine, taking snapshots to tell us who is doing what at regular intervals.\ngenerate_animation_df acts like a choreographer, using those snapshots and the Layout Configuration (event_position_df) to determine the exact screen coordinates for every entity, handling queues and resource assignments like a boss.\n\nNow we have a DataFrame where every row represents an entity at a specific time and a specific location on screen, complete with an icon. It’s like the final, detailed storyboard for our movie. All that’s left is to actually film it!\nGet ready to yell “Action!” as we move to the final step: Chapter 6: Animation Generation (generate_animation).\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 5: Prepare for Snapshots, McFly! (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#the-mission-from-diary-to-movie-frames",
    "href": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#the-mission-from-diary-to-movie-frames",
    "title": "Chapter 5: Prepare for Snapshots, McFly! (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Imagine you have K.I.T.T.’s complete sensor logs for a day. It’s just a long list: “10:01: Scanned sector Alpha”, “10:03: Detected suspicious activity”, “10:05: Engaged Turbo Boost”. To make a visual replay, you don’t just want the list; you want to see K.I.T.T.’s position and status on a map every, say, 10 seconds.\nThat’s our goal here. We take the raw Event Log (the diary) and transform it into a frame-by-frame description of the system state (the movie reel).\n\nreshape_for_animations: Figures out who is doing what event at regular time intervals (our snapshots).\ngenerate_animation_df: Calculates the precise X, Y coordinates for each entity in each snapshot, based on their event, status (queuing/using resource), and the Layout Configuration (event_position_df).\n\nThese functions are usually called automatically by the main animate_activity_log function, but understanding them helps you see how the magic happens!",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 5: Prepare for Snapshots, McFly! (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#step-1-taking-the-photos---reshape_for_animations",
    "href": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#step-1-taking-the-photos---reshape_for_animations",
    "title": "Chapter 5: Prepare for Snapshots, McFly! (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "This function is like hitting pause on your VCR at regular intervals during Back to the Future to see where Marty, Doc, and the Libyans are at that exact moment.\nPurpose: To convert the continuous stream of events into discrete snapshots in time.\nInput: The Event Log DataFrame.\nOutput: A new DataFrame. Each row represents a specific patient at a specific minute (or whatever every_x_time_units you choose). It tells you the event they were last recorded doing before or at that minute. It also calculates their rank if multiple patients are doing the same event (e.g., who is 1st, 2nd, 3rd in the ‘wait_for_simulator’ queue at that minute).\nLet’s imagine a tiny piece of our Top Gun Event Log:\n# --- Input Event Log (Simplified) ---\nevent_data = [\n    {'patient': 'Maverick', 'event': 'arrival', 'time': 0, 'event_type': 'arrival_departure'},\n    {'patient': 'Goose', 'event': 'arrival', 'time': 5, 'event_type': 'arrival_departure'},\n    {'patient': 'Maverick', 'event': 'wait_for_simulator', 'time': 1, 'event_type': 'queue'},\n    {'patient': 'Goose', 'event': 'wait_for_simulator', 'time': 6, 'event_type': 'queue'},\n    {'patient': 'Maverick', 'event': 'start_simulator', 'time': 10, 'event_type': 'resource_use', 'resource_id': 'Sim_1'},\n    {'patient': 'Goose', 'event': 'start_simulator', 'time': 15, 'event_type': 'resource_use', 'resource_id': 'Sim_2'}\n]\nevent_log_df = pd.DataFrame(event_data)\n# --- End Input ---\nIf we call reshape_for_animations (conceptually, with every_x_time_units=5), it might produce snapshots like this:\n# --- Output Snapshots (Conceptual from reshape_for_animations) ---\nsnapshot_data = [\n    # Minute 0: Only Maverick arrived\n    {'minute': 0, 'patient': 'Maverick', 'event': 'arrival', 'event_type': 'arrival_departure', 'rank': 1.0},\n    # Minute 5: Maverick is waiting, Goose just arrived\n    {'minute': 5, 'patient': 'Maverick', 'event': 'wait_for_simulator', 'event_type': 'queue', 'rank': 1.0},\n    {'minute': 5, 'patient': 'Goose', 'event': 'arrival', 'event_type': 'arrival_departure', 'rank': 1.0},\n    # Minute 10: Maverick started Sim 1, Goose is now waiting (rank 1 in queue)\n    {'minute': 10, 'patient': 'Maverick', 'event': 'start_simulator', 'event_type': 'resource_use', 'resource_id': 'Sim_1', 'rank': 1.0},\n    {'minute': 10, 'patient': 'Goose', 'event': 'wait_for_simulator', 'event_type': 'queue', 'rank': 1.0},\n    # Minute 15: Maverick still in Sim 1, Goose started Sim 2\n    {'minute': 15, 'patient': 'Maverick', 'event': 'start_simulator', 'event_type': 'resource_use', 'resource_id': 'Sim_1', 'rank': 1.0},\n    {'minute': 15, 'patient': 'Goose', 'event': 'start_simulator', 'event_type': 'resource_use', 'resource_id': 'Sim_2', 'rank': 2.0} # Note: Rank might be based on resource_id here\n]\nreshaped_df = pd.DataFrame(snapshot_data)\nprint(reshaped_df)\n# --- End Output ---\nThis reshaped_df tells us exactly who was doing what at each 5-minute interval. It’s the foundation for our animation frames!",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 5: Prepare for Snapshots, McFly! (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#step-2-setting-the-scene---generate_animation_df",
    "href": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#step-2-setting-the-scene---generate_animation_df",
    "title": "Chapter 5: Prepare for Snapshots, McFly! (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Okay, we have our snapshots telling us who is doing what and when. Now we need to figure out where they should be on the screen. This function is like the director telling the actors their exact marks on the stage floor, using the script (snapshots) and the set design (Layout Configuration (event_position_df)).\nPurpose: To calculate the final X and Y screen coordinates for each entity in each snapshot.\nInput: 1. The snapshot DataFrame produced by reshape_for_animations. 2. The Layout Configuration (event_position_df) DataFrame.\nOutput: A DataFrame almost identical to the input snapshot DataFrame, but with crucial new columns: * x_final: The calculated horizontal position. * y_final: The calculated vertical position. * icon: An assigned emoji icon for the entity (like giving each Smurf a unique hat… wait, wrong reference… like giving each Autobot a unique symbol!).\nIt uses the event, event_type, rank, and resource_id from the snapshot, along with the base x and y from the layout, to determine the final position.\n\nSimple Events: (like ‘arrival’, ‘depart’) often just use the base X, Y from the layout.\nQueues: Patients line up. The rank determines their position in the line (e.g., rank 1 is at base_x - gap, rank 2 at base_x - 2*gap). It can even wrap the queue into multiple rows like the aliens in Space Invaders if it gets too long!\nResource Use: The position is calculated based on the specific resource_id (e.g., ‘Sim_1’ might be at base_x - gap, ‘Sim_2’ at base_x - 2*gap). This ensures Maverick always appears at the same simulator spot when using ‘Sim_1’.\n\nLet’s take one snapshot from our previous example (Minute 10) and imagine our layout:\n# --- Input Snapshot Row (Minute 10) ---\nsnapshot_row_mav = {'minute': 10, 'patient': 'Maverick', 'event': 'start_simulator', 'event_type': 'resource_use', 'resource_id': 'Sim_1', 'rank': 1.0}\nsnapshot_row_goose = {'minute': 10, 'patient': 'Goose', 'event': 'wait_for_simulator', 'event_type': 'queue', 'rank': 1.0}\n\n# --- Input Layout Info (Simplified) ---\nlayout_info = {\n    'start_simulator': {'x': 350, 'y': 200},\n    'wait_for_simulator': {'x': 200, 'y': 200}\n}\n# --- Assume gap_between_entities = 10, gap_between_resources = 20 ---\ngap_entities = 10\ngap_resources = 20\ngenerate_animation_df would process these rows:\n# --- Output with Positions (Conceptual from generate_animation_df) ---\n\n# Maverick (Resource Use): Position depends on resource_id (Sim_1 is ID 1)\nmav_x_final = layout_info['start_simulator']['x'] - (1 * gap_resources) # 350 - 20 = 330\nmav_y_final = layout_info['start_simulator']['y'] # 200\noutput_row_mav = {**snapshot_row_mav, 'x_final': mav_x_final, 'y_final': mav_y_final, 'icon': '🧔🏼'}\n\n# Goose (Queue): Position depends on rank (Rank 1)\ngoose_x_final = layout_info['wait_for_simulator']['x'] - (1 * gap_entities) # 200 - 10 = 190\ngoose_y_final = layout_info['wait_for_simulator']['y'] # 200\noutput_row_goose = {**snapshot_row_goose, 'x_final': goose_x_final, 'y_final': goose_y_final, 'icon': '👨🏻‍🦰'}\n\nprint(output_row_mav)\nprint(output_row_goose)\n# --- End Output ---\nNow, each entity in each snapshot has precise coordinates and an icon. This is the data that directly feeds the animation engine! It’s like having the final shooting script with exact camera angles and actor positions marked.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 5: Prepare for Snapshots, McFly! (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#how-it-fits-together-the-assembly-line",
    "href": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#how-it-fits-together-the-assembly-line",
    "title": "Chapter 5: Prepare for Snapshots, McFly! (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Remember the flow from Chapter 1: Great Scott! Making Animations Easy with animate_activity_log? reshape_for_animations and generate_animation_df are the crucial middle steps orchestrated by the main function:\n\n\n\n\n\nsequenceDiagram\n    participant AAL as animate_activity_log\n    participant RFA as reshape_for_animations\n    participant GADF as generate_animation_df\n    participant GA as generate_animation\n\n    AAL-&gt;&gt;RFA: Call with event_log\n    Note over RFA: Process log into time snapshots (who/what/when)\n    RFA--&gt;&gt;AAL: Return reshaped_df (Snapshots)\n    AAL-&gt;&gt;GADF: Call with reshaped_df & event_position_df\n    Note over GADF: Calculate final X,Y positions based on event, rank, resource_id & layout. Assign icons.\n    GADF--&gt;&gt;AAL: Return data_with_positions (Animation-ready data)\n    AAL-&gt;&gt;GA: Call with data_with_positions\n    GA--&gt;&gt;AAL: Return Plotly Figure\n\n\n\n\n\n\nThese two functions handle all the complex data wrangling, turning your raw simulation output into perfectly formatted input for the final animation step.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 5: Prepare for Snapshots, McFly! (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#under-the-hood-like-looking-inside-johnny-5",
    "href": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#under-the-hood-like-looking-inside-johnny-5",
    "title": "Chapter 5: Prepare for Snapshots, McFly! (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Let’s peek briefly at the circuits inside vidigi/prep.py where these functions live. No need to grab your screwdriver like Stephanie trying to fix Number 5!\n\n\nConceptually, this function works like this:\n\nPivot Log: It first reshapes the event log slightly to easily find the ‘arrival’ and ‘depart’ times for each patient.\nIterate Through Time: It loops through time, usually in steps defined by every_x_time_units (e.g., 0, 10, 20…).\nFind Active Patients: At each minute, it identifies patients who have arrived before or at this minute and have departed after this minute (or haven’t departed yet). These are the patients “on screen” at this time.\nGet Latest Event: For each active patient, it looks back through their event history up to this minute and finds their single most recent event. This defines their current state (e.g., ‘wait_for_simulator’ or ‘start_simulator’).\nRank Patients: If multiple patients are in the same state (e.g., multiple people in the ‘wait_for_simulator’ queue), it ranks them based on when they entered that state (using the original event log index as a tie-breaker).\nLimit Snapshot Size: It might cap the number of patients shown per event per snapshot (step_snapshot_max) to keep things tidy.\nStore Snapshot: It stores the state (event, type, rank, etc.) for all active patients at this minute.\nAdd Exit Step: After processing all minutes, it adds a final ‘exit’ event for each patient slightly after their last recorded event, ensuring they visually leave the screen.\nCombine & Return: It combines all the snapshots into one big DataFrame.\n\nHere’s a simplified conceptual code snippet:\n# --- Inside reshape_for_animations (Conceptual - vidigi/prep.py) ---\nimport pandas as pd\n\ndef reshape_for_animations_simplified(event_log, every_x_time_units):\n    all_snapshots = []\n    # Get arrival/departure times easily (details omitted)\n    pivoted_log = event_log.pivot_table(...)\n\n    max_time = event_log['time'].max() # Find simulation end time\n\n    # Loop through time in steps\n    for minute in range(0, max_time + every_x_time_units, every_x_time_units):\n\n        # Find patients active at this 'minute' (details omitted)\n        active_patients = find_active_patients(pivoted_log, minute)\n\n        if active_patients:\n            # Get all events for active patients up to 'minute'\n            relevant_events = event_log[\n                (event_log['patient'].isin(active_patients)) &\n                (event_log['time'] &lt;= minute)\n            ]\n\n            # Find the single latest event for each patient\n            latest_states = relevant_events.sort_values('time').groupby('patient').tail(1)\n\n            # Rank patients within the same event (e.g., queue order)\n            latest_states['rank'] = latest_states.groupby('event')['time'].rank(method='first')\n\n            # Add the current minute to the snapshot data\n            latest_states['minute'] = minute\n            all_snapshots.append(latest_states)\n\n    # Combine all snapshots into one DataFrame\n    full_patient_df = pd.concat(all_snapshots, ignore_index=True)\n\n    # Add a final 'exit' step for cleanup (details omitted)\n    full_patient_df = add_final_exit_step(full_patient_df, every_x_time_units)\n\n    return full_patient_df.sort_values([\"minute\", \"event\"])\n# --- End Conceptual Code ---\n\n\n\nThis function takes the snapshots and layout and calculates positions:\n\nMerge Layout: It merges the snapshot DataFrame with the Layout Configuration (event_position_df) based on the event name. Now each snapshot row knows the base X and Y for its event.\nSeparate by Type: It often handles different event_type groups separately (queues, resource use, others).\nCalculate Queue Positions:\n\nFor queue events, it calculates the row and column within the queue based on the rank and the wrap_queues_at parameter.\nIt computes x_final by subtracting an offset (based on column and gap_between_entities) from the base x.\nIt computes y_final by adding an offset (based on row and gap_between_rows) to the base y.\n\nCalculate Resource Positions:\n\nFor resource_use events, it uses the resource_id (which is usually numeric after populate_store) and wrap_resources_at similarly to calculate row and column.\nIt computes x_final and y_final using offsets based on the resource’s column/row and gap_between_resources/gap_between_rows.\n\nHandle Other Events: For arrivals, departures, etc., x_final and y_final are usually just set to the base x and y.\nAssign Icons: It assigns a unique icon from a list (you can provide a custom_entity_icon_list) to each unique patient ID. Think of it like the machine in Short Circuit assigning laser targets – but with emojis!\nCombine & Return: It concatenates the processed groups back into a single DataFrame with x_final, y_final, and icon columns added.\n\nSimplified conceptual code:\n# --- Inside generate_animation_df (Conceptual - vidigi/prep.py) ---\nimport pandas as pd\nimport numpy as np\n\ndef generate_animation_df_simplified(snapshots_df, layout_df, wrap_queues_at, gap_entities, gap_rows):\n\n    # Merge snapshots with layout base positions\n    df_with_base_pos = pd.merge(snapshots_df, layout_df, on='event', how='left')\n\n    # --- Process Queues ---\n    queues = df_with_base_pos[df_with_base_pos['event_type'] == 'queue'].copy()\n    if not queues.empty:\n        # Calculate row number (0-based)\n        queues['row'] = np.floor((queues['rank'] - 1) / wrap_queues_at)\n        # Calculate position within the row (0-based, adjusted for rank starting at 1)\n        queues['col_in_row'] = (queues['rank'] - 1) % wrap_queues_at\n        # Calculate final positions\n        queues['x_final'] = queues['x'] - queues['col_in_row'] * gap_entities\n        queues['y_final'] = queues['y'] + queues['row'] * gap_rows\n\n    # --- Process Resources (Similar logic using resource_id) ---\n    resources = df_with_base_pos[df_with_base_pos['event_type'] == 'resource_use'].copy()\n    # ... similar x_final, y_final calculation using resource_id ...\n    if not resources.empty:\n        # Simplified: Assume base position for this example\n        resources['x_final'] = resources['x']\n        resources['y_final'] = resources['y']\n\n\n    # --- Process Others ---\n    others = df_with_base_pos[~df_with_base_pos['event_type'].isin(['queue', 'resource_use'])].copy()\n    if not others.empty:\n        others['x_final'] = others['x']\n        others['y_final'] = others['y']\n\n    # Combine results\n    final_df = pd.concat([queues, resources, others], ignore_index=True)\n\n    # Assign icons to patients (details omitted)\n    final_df = assign_icons(final_df)\n\n    return final_df\n# --- End Conceptual Code ---\nThese functions do the heavy lifting of data preparation so the final animation step can be smooth as hover-converting a DeLorean.",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 5: Prepare for Snapshots, McFly! (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#conclusion-data-reshaped-positions-calculated",
    "href": "autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#conclusion-data-reshaped-positions-calculated",
    "title": "Chapter 5: Prepare for Snapshots, McFly! (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Whoa, heavy! We’ve seen how vidigi takes the raw Event Log – our simulation’s diary – and uses the tag team of reshape_for_animations and generate_animation_df to turn it into perfectly structured, animation-ready data.\n\nreshape_for_animations acts like a time machine, taking snapshots to tell us who is doing what at regular intervals.\ngenerate_animation_df acts like a choreographer, using those snapshots and the Layout Configuration (event_position_df) to determine the exact screen coordinates for every entity, handling queues and resource assignments like a boss.\n\nNow we have a DataFrame where every row represents an entity at a specific time and a specific location on screen, complete with an icon. It’s like the final, detailed storyboard for our movie. All that’s left is to actually film it!\nGet ready to yell “Action!” as we move to the final step: Chapter 6: Animation Generation (generate_animation).\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Chapter 5: Prepare for Snapshots, McFly! (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "autodoc_v3/index.html",
    "href": "autodoc_v3/index.html",
    "title": "Tutorial: vidigi",
    "section": "",
    "text": "vidigi helps you visualize the output of discrete event simulations, especially those built with the Simpy library. It takes a detailed Event Log (tracking entities like patients through stages) and transforms it into an animated scatter plot using Plotly. This allows users to visually validate model logic and understand system dynamics like queues and resource usage over time. Key components handle preparing data into snapshots, generating the animation, configuring the visual layout, and enhancing Simpy resources for better tracking.\nSource Repository: https://github.com/Bergam0t/vidigi\n\n\n\n\n\nflowchart TD\n    A0[\"Event Log\"]\n    A1[\"Snapshot Preparation - reshape_for_animations & generate_animation_df\"]\n    A2[\"Animation Generation - generate_animation\"]\n    A3[\"Layout Configuration - event_position_df\"]\n    A4[\"Simpy Resource Enhancement - CustomResource, Store, populate_store\"]\n    A5[\"Animation Facade - animate_activity_log\"]\n    A0 -- \"Provides data for\" --&gt; A1\n    A0 -- \"Is input to\" --&gt; A5\n    A1 -- \"Provides data for\" --&gt; A2\n    A3 -- \"Defines positions for\" --&gt; A1\n    A3 -- \"Defines layout for\" --&gt; A2\n    A3 -- \"Is input to\" --&gt; A5\n    A4 -- \"Enables resource ID logging in\" --&gt; A0\n    A4 -- \"Provides resource info to\" --&gt; A2\n    A5 -- \"Calls\" --&gt; A1\n    A5 -- \"Calls\" --&gt; A2\n\n\n\n\n\n\n\n\n\nAnimation Facade (animate_activity_log)\nEvent Log\nLayout Configuration (event_position_df)\nSimpy Resource Enhancement (CustomResource, Store, populate_store)\nSnapshot Preparation (reshape_for_animations & generate_animation_df)\nAnimation Generation (generate_animation)\n\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Tutorial: vidigi"
    ]
  },
  {
    "objectID": "autodoc_v3/index.html#chapters",
    "href": "autodoc_v3/index.html#chapters",
    "title": "Tutorial: vidigi",
    "section": "",
    "text": "Animation Facade (animate_activity_log)\nEvent Log\nLayout Configuration (event_position_df)\nSimpy Resource Enhancement (CustomResource, Store, populate_store)\nSnapshot Preparation (reshape_for_animations & generate_animation_df)\nAnimation Generation (generate_animation)\n\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Beginner Friendly + 1980s References",
      "Tutorial: vidigi"
    ]
  }
]