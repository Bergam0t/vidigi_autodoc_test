[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tutorial: vidigi",
    "section": "",
    "text": "vidigi helps you visualize the output of discrete event simulations, especially those built with the Simpy library. It takes a detailed Event Log (tracking entities like patients through stages) and transforms it into an animated scatter plot using Plotly. This allows users to visually validate model logic and understand system dynamics like queues and resource usage over time. Key components handle preparing data into snapshots, generating the animation, configuring the visual layout, and enhancing Simpy resources for better tracking.\nSource Repository: https://github.com/Bergam0t/vidigi\n\n\n\n\n\nflowchart TD\n    A0[\"Event Log\n\"]\n    A1[\"Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)\n\"]\n    A2[\"Animation Generation (`generate_animation`)\n\"]\n    A3[\"Layout Configuration (`event_position_df`)\n\"]\n    A4[\"Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)\n\"]\n    A5[\"Animation Facade (`animate_activity_log`)\n\"]\n    A0 -- \"Provides data for\" --&gt; A1\n    A0 -- \"Is input to\" --&gt; A5\n    A1 -- \"Provides data for\" --&gt; A2\n    A3 -- \"Defines positions for\" --&gt; A1\n    A3 -- \"Defines layout for\" --&gt; A2\n    A3 -- \"Is input to\" --&gt; A5\n    A4 -- \"Enables resource ID logging in\" --&gt; A0\n    A4 -- \"Provides resource info to\" --&gt; A2\n    A5 -- \"Calls\" --&gt; A1\n    A5 -- \"Calls\" --&gt; A2\n\n\n\n\n\n\n\n\n\nAnimation Facade (animate_activity_log).qmd\nEvent Log\nLayout Configuration (event_position_df)\nSimpy Resource Enhancement (CustomResource, Store, populate_store)\nSnapshot Preparation (reshape_for_animations & generate_animation_df)\nAnimation Generation (generate_animation)\n\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Tutorial: vidigi"
    ]
  },
  {
    "objectID": "index.html#chapters",
    "href": "index.html#chapters",
    "title": "Tutorial: vidigi",
    "section": "",
    "text": "Animation Facade (animate_activity_log).qmd\nEvent Log\nLayout Configuration (event_position_df)\nSimpy Resource Enhancement (CustomResource, Store, populate_store)\nSnapshot Preparation (reshape_for_animations & generate_animation_df)\nAnimation Generation (generate_animation)\n\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Tutorial: vidigi"
    ]
  },
  {
    "objectID": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html",
    "href": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "In Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store), we learned how to make sure our simulation records which specific resource (like Cubicle 1 vs. Cubicle 2) each patient is using. This gives us a detailed Event Log, the script of our process. We also have our stage map, the Layout Configuration (event_position_df).\nBut how do we turn this script and map into an actual movie? A movie isn’t just a list of events; it’s a series of frames, or snapshots, showing where everyone is at specific moments in time. This chapter explores how vidigi prepares these snapshots.\n\n\nThink about the Event Log. It’s like a detailed diary:\n\n9:00 AM: Alice arrived.\n9:01 AM: Alice started waiting.\n9:15 AM: Alice started treatment (Cubicle 1).\n9:30 AM: Alice finished treatment.\n9:31 AM: Alice departed.\n\nThis tells us when things change. But an animation needs to show the state of the system at regular intervals, say, every 5 minutes. What was happening at 9:05 AM? What about 9:10 AM?\nWe need to transform our event-based diary into a “flipbook” where each page shows the location and status of everyone at a specific time (e.g., 9:00, 9:05, 9:10, 9:15…). This process involves two main steps, handled by two helper functions within vidigi:\n\nreshape_for_animations: Figures out who is doing what at each snapshot time. (Like sketching the characters and their basic activity on each flipbook page).\ngenerate_animation_df: Calculates the exact (X, Y) screen coordinates for each character on each page, arranging them neatly in queues or placing them at specific resource spots. (Like precisely positioning the sketches on the page according to layout rules).\n\nThese functions usually work behind the scenes when you call the main animate_activity_log function (the “Easy Button” from Chapter 1). You typically don’t need to call them yourself, but understanding them helps you see how the animation is built.\n\n\n\nGoal: To determine the status (event, event type, resource used) of every entity at regular time intervals.\nImagine you have your event log diary. reshape_for_animations acts like someone reading the diary and creating a summary for specific times. You tell it how often to take a snapshot using the every_x_time_units parameter (e.g., every_x_time_units=5 means take a snapshot every 5 minutes).\nHow it works (conceptually):\n\nLook at a Snapshot Time: It starts at time 0, then time 5, then time 10, and so on, up to a specified limit (limit_duration).\nFind Active Patients: For each snapshot time (say, minute 10), it looks at the Event Log to find all patients who have arrival time &lt;= 10 AND (depart time &gt;= 10 OR depart time is missing). These are the patients currently “in the system”.\nFind Latest Status: For each of these active patients, it finds the most recent event that happened at or before the current snapshot time (minute 10). For example, if Alice arrived at 0 and started waiting at 1, her status at minute 10 is still ‘start_wait’. If Bob arrived at 2 and started treatment (Resource 2) at 8, his status at minute 10 is ‘start_treat’ using Resource 2.\nRank Entities: If multiple patients are in the same state (e.g., multiple people waiting), it ranks them based on when they entered that state. This “rank” is important for positioning them later (e.g., first in line, second in line).\nRecord Snapshot: It records this information (patient ID, event, event type, resource ID if applicable, rank) for the current snapshot time.\nRepeat: It does this for every snapshot time interval.\nAdd Exit: It adds a final ‘exit’ event for each patient slightly after their last recorded event to make them disappear cleanly from the animation.\n\nInput: A simplified Event Log DataFrame:\n# event_log (from Chapter 2)\n#    patient       event_type        event  time  resource_id\n# 0        1  arrival_departure      arrival     0          NaN\n# 1        1              queue   start_wait     0          NaN\n# 2        1       resource_use  start_treat     5          1.0  # Used resource 1\n# 3        1  arrival_departure       depart    15          NaN\n# 4        2  arrival_departure      arrival     2          NaN\n# 5        2              queue   start_wait     2          NaN\n# 6        2       resource_use  start_treat     8          2.0  # Used resource 2\n# 7        2  arrival_departure       depart    20          NaN\nOutput: A “reshaped” DataFrame (let’s assume every_x_time_units=5):\n# Output of reshape_for_animations (simplified)\n#    minute  patient       event_type        event  resource_id  rank\n# 0       0        1  arrival_departure      arrival          NaN   1.0 # At minute 0, Patient 1 arrived\n# 1       0        1              queue   start_wait          NaN   1.0 # Immediately started waiting\n# 2       5        1       resource_use  start_treat          1.0   1.0 # At minute 5, Patient 1 started treatment (Resource 1)\n# 3       5        2              queue   start_wait          NaN   1.0 # At minute 5, Patient 2 was waiting (arrived at 2)\n# 4      10        1       resource_use  start_treat          1.0   1.0 # At minute 10, Patient 1 still treating\n# 5      10        2       resource_use  start_treat          2.0   1.0 # At minute 10, Patient 2 started treatment (Resource 2)\n# 6      15        1  arrival_departure       depart          NaN   1.0 # At minute 15, Patient 1 departed\n# 7      15        2       resource_use  start_treat          2.0   1.0 # At minute 15, Patient 2 still treating\n# 8      20        2  arrival_departure       depart          NaN   1.0 # At minute 20, Patient 2 departed\n# ... (plus added 'exit' events shortly after depart)\nNotice how this table tells us the state of both patients at each 5-minute interval (minute column). The rank column tells us their order within that state at that time (here, they are mostly alone in their state, so rank is 1.0).\n(Code Reference: The actual logic lives in the reshape_for_animations function within the vidigi/prep.py file.)\n\n\n\nGoal: To calculate the precise (X, Y) screen coordinates for every entity in every snapshot, based on their status and the layout rules.\nNow we have our flipbook pages sketched (reshape_for_animations output), but the characters are just listed, not positioned. generate_animation_df takes these sketches and the Layout Configuration (event_position_df) (our stage map) and figures out exactly where to draw everyone.\nHow it works (conceptually):\n\nTake a Snapshot Row: It looks at each row from the reshape_for_animations output (e.g., “At minute 5, Patient 2 was start_wait, rank 1.0”).\nFind Base Position: It looks up the event (‘start_wait’) in the Layout Configuration (event_position_df) to get the base anchor coordinates (e.g., X=200, Y=250 from Chapter 3’s example).\nApply Layout Rules:\n\nIf it’s a Queue (event_type == ‘queue’): It uses the patient’s rank (1.0 in this case) and parameters like wrap_queues_at and gap_between_entities to calculate an offset from the base (X, Y). Rank 1 might be right at the base (X=200), Rank 2 might be slightly to the left (X = 200 - gap_between_entities), and so on, potentially wrapping to a new row above.\nIf it’s Resource Use (event_type == ‘resource_use’): It uses the patient’s specific resource_id (e.g., Resource 1 or Resource 2 from the reshape_for_animations output) and parameters like wrap_resources_at and gap_between_resources to calculate the position relative to the base (X, Y) defined for that resource event in the layout. Resource 1 might be at (X - gap_between_resources * 1), Resource 2 at (X - gap_between_resources * 2), etc., potentially wrapping.\nIf it’s Arrival/Departure: It typically just uses the base (X, Y) directly.\n\nAssign Icon: It picks an icon (like an emoji 👩🏽‍⚕️, 👨‍💻, 🏭) for the patient, making sure each unique patient gets the same icon throughout the animation.\nRecord Final Position: It stores the calculated x_final, y_final, and icon along with the original snapshot information.\n\nInput:\n\nThe reshaped DataFrame from reshape_for_animations.\nThe Layout Configuration (event_position_df).\n\nOutput: The final “animation-ready” DataFrame. This contains everything needed to draw each frame: the time (minute), who (patient), their icon (icon), their exact position (x_final, y_final), and hover text (label).\n# Output of generate_animation_df (simplified, adding X/Y and icons)\n#    minute  patient       event_type        event  resource_id  rank  x_final  y_final      icon                       label\n# 0       0        1  arrival_departure      arrival          NaN   1.0     50.0    200.0       '🧔🏼'                  'Entrance' # At base X/Y for arrival\n# 1       0        1              queue   start_wait          NaN   1.0    200.0    250.0       '🧔🏼'              'Waiting Area' # At base X/Y for queue (rank 1)\n# 2       5        1       resource_use  start_treat          1.0   1.0    190.0    150.0       '🧔🏼'            'Treatment Bays' # Offset for resource 1 (base X=200, Y=150)\n# 3       5        2              queue   start_wait          NaN   1.0    200.0    250.0       '👨🏿‍🦯'              'Waiting Area' # At base X/Y for queue (rank 1)\n# 4      10        1       resource_use  start_treat          1.0   1.0    190.0    150.0       '🧔🏼'            'Treatment Bays' # Still at resource 1 spot\n# 5      10        2       resource_use  start_treat          2.0   1.0    180.0    150.0       '👨🏿‍🦯'            'Treatment Bays' # Offset for resource 2\n# 6      15        1  arrival_departure       depart          NaN   1.0    350.0    150.0       '🧔🏼'                 'Discharge' # At base X/Y for depart\n# 7      15        2       resource_use  start_treat          2.0   1.0    180.0    150.0       '👨🏿‍🦯'            'Treatment Bays' # Still at resource 2 spot\n# 8      20        2  arrival_departure       depart          NaN   1.0    350.0    150.0       '👨🏿‍🦯'                 'Discharge' # At base X/Y for depart\n# ... (plus 'exit' events)\nThis final table is the direct input for the animation engine itself.\n(Code Reference: The actual logic lives in the generate_animation_df function within the vidigi/prep.py file.)\n\n\n\nThe main animate_activity_log function orchestrates these two steps before creating the final animation:\n\n\n\n\n\nsequenceDiagram\n    participant User\n    participant AAL as animate_activity_log\n    participant RFA as reshape_for_animations\n    participant GAD as generate_animation_df\n    participant GA as generate_animation (Chapter 6)\n\n    User-&gt;&gt;AAL: Call with event_log, layout, options\n    AAL-&gt;&gt;RFA: Pass event_log, time interval (every_x_time_units)\n    RFA--&gt;&gt;AAL: Return reshaped_df (time slices)\n    AAL-&gt;&gt;GAD: Pass reshaped_df, layout, queue/resource rules\n    GAD--&gt;&gt;AAL: Return animation_df (with X, Y, icons)\n    AAL-&gt;&gt;GA: Pass animation_df, display options\n    GA--&gt;&gt;AAL: Return Plotly Figure\n    AAL--&gt;&gt;User: Return Plotly Figure\n\n\n\n\n\n\nFirst, reshape_for_animations processes the raw log into time slices. Then, generate_animation_df takes those slices and calculates the precise visual positions using the layout map.\n\n\n\nSnapshot preparation is the crucial data transformation stage in vidigi. It bridges the gap between the raw, event-based simulation log and the frame-by-frame data needed for animation.\n\nreshape_for_animations acts like a scribe, turning the event diary into a flipbook summary by figuring out who is doing what at regular time intervals.\ngenerate_animation_df acts like an artist, taking the flipbook summary and the stage map (event_position_df) to calculate the exact (X, Y) coordinates for every character on every page, respecting queueing and resource layout rules.\n\nTogether, they produce a detailed DataFrame where each row represents an entity at a specific time with a specific icon and screen position. This prepared data is now ready to be fed into the final animation engine.\nHow does vidigi take this final DataFrame and actually draw the moving pictures using Plotly? That’s what we’ll explore in the next chapter!\nNext up: Chapter 6: Animation Generation (generate_animation)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Modules",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#from-diary-to-flipbook-the-need-for-snapshots",
    "href": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#from-diary-to-flipbook-the-need-for-snapshots",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Think about the Event Log. It’s like a detailed diary:\n\n9:00 AM: Alice arrived.\n9:01 AM: Alice started waiting.\n9:15 AM: Alice started treatment (Cubicle 1).\n9:30 AM: Alice finished treatment.\n9:31 AM: Alice departed.\n\nThis tells us when things change. But an animation needs to show the state of the system at regular intervals, say, every 5 minutes. What was happening at 9:05 AM? What about 9:10 AM?\nWe need to transform our event-based diary into a “flipbook” where each page shows the location and status of everyone at a specific time (e.g., 9:00, 9:05, 9:10, 9:15…). This process involves two main steps, handled by two helper functions within vidigi:\n\nreshape_for_animations: Figures out who is doing what at each snapshot time. (Like sketching the characters and their basic activity on each flipbook page).\ngenerate_animation_df: Calculates the exact (X, Y) screen coordinates for each character on each page, arranging them neatly in queues or placing them at specific resource spots. (Like precisely positioning the sketches on the page according to layout rules).\n\nThese functions usually work behind the scenes when you call the main animate_activity_log function (the “Easy Button” from Chapter 1). You typically don’t need to call them yourself, but understanding them helps you see how the animation is built.",
    "crumbs": [
      "Modules",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#step-1-creating-time-slices-reshape_for_animations",
    "href": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#step-1-creating-time-slices-reshape_for_animations",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Goal: To determine the status (event, event type, resource used) of every entity at regular time intervals.\nImagine you have your event log diary. reshape_for_animations acts like someone reading the diary and creating a summary for specific times. You tell it how often to take a snapshot using the every_x_time_units parameter (e.g., every_x_time_units=5 means take a snapshot every 5 minutes).\nHow it works (conceptually):\n\nLook at a Snapshot Time: It starts at time 0, then time 5, then time 10, and so on, up to a specified limit (limit_duration).\nFind Active Patients: For each snapshot time (say, minute 10), it looks at the Event Log to find all patients who have arrival time &lt;= 10 AND (depart time &gt;= 10 OR depart time is missing). These are the patients currently “in the system”.\nFind Latest Status: For each of these active patients, it finds the most recent event that happened at or before the current snapshot time (minute 10). For example, if Alice arrived at 0 and started waiting at 1, her status at minute 10 is still ‘start_wait’. If Bob arrived at 2 and started treatment (Resource 2) at 8, his status at minute 10 is ‘start_treat’ using Resource 2.\nRank Entities: If multiple patients are in the same state (e.g., multiple people waiting), it ranks them based on when they entered that state. This “rank” is important for positioning them later (e.g., first in line, second in line).\nRecord Snapshot: It records this information (patient ID, event, event type, resource ID if applicable, rank) for the current snapshot time.\nRepeat: It does this for every snapshot time interval.\nAdd Exit: It adds a final ‘exit’ event for each patient slightly after their last recorded event to make them disappear cleanly from the animation.\n\nInput: A simplified Event Log DataFrame:\n# event_log (from Chapter 2)\n#    patient       event_type        event  time  resource_id\n# 0        1  arrival_departure      arrival     0          NaN\n# 1        1              queue   start_wait     0          NaN\n# 2        1       resource_use  start_treat     5          1.0  # Used resource 1\n# 3        1  arrival_departure       depart    15          NaN\n# 4        2  arrival_departure      arrival     2          NaN\n# 5        2              queue   start_wait     2          NaN\n# 6        2       resource_use  start_treat     8          2.0  # Used resource 2\n# 7        2  arrival_departure       depart    20          NaN\nOutput: A “reshaped” DataFrame (let’s assume every_x_time_units=5):\n# Output of reshape_for_animations (simplified)\n#    minute  patient       event_type        event  resource_id  rank\n# 0       0        1  arrival_departure      arrival          NaN   1.0 # At minute 0, Patient 1 arrived\n# 1       0        1              queue   start_wait          NaN   1.0 # Immediately started waiting\n# 2       5        1       resource_use  start_treat          1.0   1.0 # At minute 5, Patient 1 started treatment (Resource 1)\n# 3       5        2              queue   start_wait          NaN   1.0 # At minute 5, Patient 2 was waiting (arrived at 2)\n# 4      10        1       resource_use  start_treat          1.0   1.0 # At minute 10, Patient 1 still treating\n# 5      10        2       resource_use  start_treat          2.0   1.0 # At minute 10, Patient 2 started treatment (Resource 2)\n# 6      15        1  arrival_departure       depart          NaN   1.0 # At minute 15, Patient 1 departed\n# 7      15        2       resource_use  start_treat          2.0   1.0 # At minute 15, Patient 2 still treating\n# 8      20        2  arrival_departure       depart          NaN   1.0 # At minute 20, Patient 2 departed\n# ... (plus added 'exit' events shortly after depart)\nNotice how this table tells us the state of both patients at each 5-minute interval (minute column). The rank column tells us their order within that state at that time (here, they are mostly alone in their state, so rank is 1.0).\n(Code Reference: The actual logic lives in the reshape_for_animations function within the vidigi/prep.py file.)",
    "crumbs": [
      "Modules",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#step-2-calculating-positions-generate_animation_df",
    "href": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#step-2-calculating-positions-generate_animation_df",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Goal: To calculate the precise (X, Y) screen coordinates for every entity in every snapshot, based on their status and the layout rules.\nNow we have our flipbook pages sketched (reshape_for_animations output), but the characters are just listed, not positioned. generate_animation_df takes these sketches and the Layout Configuration (event_position_df) (our stage map) and figures out exactly where to draw everyone.\nHow it works (conceptually):\n\nTake a Snapshot Row: It looks at each row from the reshape_for_animations output (e.g., “At minute 5, Patient 2 was start_wait, rank 1.0”).\nFind Base Position: It looks up the event (‘start_wait’) in the Layout Configuration (event_position_df) to get the base anchor coordinates (e.g., X=200, Y=250 from Chapter 3’s example).\nApply Layout Rules:\n\nIf it’s a Queue (event_type == ‘queue’): It uses the patient’s rank (1.0 in this case) and parameters like wrap_queues_at and gap_between_entities to calculate an offset from the base (X, Y). Rank 1 might be right at the base (X=200), Rank 2 might be slightly to the left (X = 200 - gap_between_entities), and so on, potentially wrapping to a new row above.\nIf it’s Resource Use (event_type == ‘resource_use’): It uses the patient’s specific resource_id (e.g., Resource 1 or Resource 2 from the reshape_for_animations output) and parameters like wrap_resources_at and gap_between_resources to calculate the position relative to the base (X, Y) defined for that resource event in the layout. Resource 1 might be at (X - gap_between_resources * 1), Resource 2 at (X - gap_between_resources * 2), etc., potentially wrapping.\nIf it’s Arrival/Departure: It typically just uses the base (X, Y) directly.\n\nAssign Icon: It picks an icon (like an emoji 👩🏽‍⚕️, 👨‍💻, 🏭) for the patient, making sure each unique patient gets the same icon throughout the animation.\nRecord Final Position: It stores the calculated x_final, y_final, and icon along with the original snapshot information.\n\nInput:\n\nThe reshaped DataFrame from reshape_for_animations.\nThe Layout Configuration (event_position_df).\n\nOutput: The final “animation-ready” DataFrame. This contains everything needed to draw each frame: the time (minute), who (patient), their icon (icon), their exact position (x_final, y_final), and hover text (label).\n# Output of generate_animation_df (simplified, adding X/Y and icons)\n#    minute  patient       event_type        event  resource_id  rank  x_final  y_final      icon                       label\n# 0       0        1  arrival_departure      arrival          NaN   1.0     50.0    200.0       '🧔🏼'                  'Entrance' # At base X/Y for arrival\n# 1       0        1              queue   start_wait          NaN   1.0    200.0    250.0       '🧔🏼'              'Waiting Area' # At base X/Y for queue (rank 1)\n# 2       5        1       resource_use  start_treat          1.0   1.0    190.0    150.0       '🧔🏼'            'Treatment Bays' # Offset for resource 1 (base X=200, Y=150)\n# 3       5        2              queue   start_wait          NaN   1.0    200.0    250.0       '👨🏿‍🦯'              'Waiting Area' # At base X/Y for queue (rank 1)\n# 4      10        1       resource_use  start_treat          1.0   1.0    190.0    150.0       '🧔🏼'            'Treatment Bays' # Still at resource 1 spot\n# 5      10        2       resource_use  start_treat          2.0   1.0    180.0    150.0       '👨🏿‍🦯'            'Treatment Bays' # Offset for resource 2\n# 6      15        1  arrival_departure       depart          NaN   1.0    350.0    150.0       '🧔🏼'                 'Discharge' # At base X/Y for depart\n# 7      15        2       resource_use  start_treat          2.0   1.0    180.0    150.0       '👨🏿‍🦯'            'Treatment Bays' # Still at resource 2 spot\n# 8      20        2  arrival_departure       depart          NaN   1.0    350.0    150.0       '👨🏿‍🦯'                 'Discharge' # At base X/Y for depart\n# ... (plus 'exit' events)\nThis final table is the direct input for the animation engine itself.\n(Code Reference: The actual logic lives in the generate_animation_df function within the vidigi/prep.py file.)",
    "crumbs": [
      "Modules",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#how-they-work-together",
    "href": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#how-they-work-together",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "The main animate_activity_log function orchestrates these two steps before creating the final animation:\n\n\n\n\n\nsequenceDiagram\n    participant User\n    participant AAL as animate_activity_log\n    participant RFA as reshape_for_animations\n    participant GAD as generate_animation_df\n    participant GA as generate_animation (Chapter 6)\n\n    User-&gt;&gt;AAL: Call with event_log, layout, options\n    AAL-&gt;&gt;RFA: Pass event_log, time interval (every_x_time_units)\n    RFA--&gt;&gt;AAL: Return reshaped_df (time slices)\n    AAL-&gt;&gt;GAD: Pass reshaped_df, layout, queue/resource rules\n    GAD--&gt;&gt;AAL: Return animation_df (with X, Y, icons)\n    AAL-&gt;&gt;GA: Pass animation_df, display options\n    GA--&gt;&gt;AAL: Return Plotly Figure\n    AAL--&gt;&gt;User: Return Plotly Figure\n\n\n\n\n\n\nFirst, reshape_for_animations processes the raw log into time slices. Then, generate_animation_df takes those slices and calculates the precise visual positions using the layout map.",
    "crumbs": [
      "Modules",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#conclusion",
    "href": "05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html#conclusion",
    "title": "Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)",
    "section": "",
    "text": "Snapshot preparation is the crucial data transformation stage in vidigi. It bridges the gap between the raw, event-based simulation log and the frame-by-frame data needed for animation.\n\nreshape_for_animations acts like a scribe, turning the event diary into a flipbook summary by figuring out who is doing what at regular time intervals.\ngenerate_animation_df acts like an artist, taking the flipbook summary and the stage map (event_position_df) to calculate the exact (X, Y) coordinates for every character on every page, respecting queueing and resource layout rules.\n\nTogether, they produce a detailed DataFrame where each row represents an entity at a specific time with a specific icon and screen position. This prepared data is now ready to be fed into the final animation engine.\nHow does vidigi take this final DataFrame and actually draw the moving pictures using Plotly? That’s what we’ll explore in the next chapter!\nNext up: Chapter 6: Animation Generation (generate_animation)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Modules",
      "Chapter 5: Snapshot Preparation (`reshape_for_animations` & `generate_animation_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html",
    "href": "03_layout_configuration_event_position_df_.html",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "In Chapter 2: Event Log, we learned about the event_log, which is like the detailed script telling vidigi what happened, when, and to whom. But just knowing the script isn’t enough to make a movie – you also need to know where the scenes take place! Where is the entrance? Where’s the waiting area? Where are the treatment rooms located on the screen?\nThat’s where the Layout Configuration, represented by the event_position_df DataFrame, comes in. It’s the blueprint or map for your animation’s background.\n\n\nImagine you’re setting up a stage play. You need to decide:\n\nWhere will actors enter? (Stage Left)\nWhere is the waiting bench? (Center Stage)\nWhere is the doctor’s office set piece? (Stage Right)\n\nWithout this plan, the actors wouldn’t know where to go, and the audience would be confused.\nSimilarly, vidigi needs a map to know where to place the icons representing your patients or entities on the screen. The event_position_df provides exactly this map. For every key step (event) in your process, it defines a specific (X, Y) coordinate on the animation screen.\n\n\n\nThe event_position_df is typically a pandas DataFrame – essentially a table. Each row in this table describes a specific location or stage in your process.\nHere are the essential columns you need in this table:\n\nevent: This column contains the exact name of the event from your Event Log that corresponds to this location. For example, 'arrival', 'start_wait', 'treatment_begins'. This is how vidigi links the location map to the event script.\nx: The horizontal coordinate (position from left to right) for this event’s base location on the screen.\ny: The vertical coordinate (position from top to bottom) for this event’s base location on the screen.\n\nThink of the (X, Y) coordinates as anchor points.\n\nFor queues (like 'start_wait'), patients will line up extending leftwards from this anchor point.\nFor resources (like 'treatment_begins'), the available resource slots (e.g., treatment beds) will be placed near this anchor point, usually extending leftwards too.\nFor arrivals and departures, patients will appear or disappear at this exact anchor point.\n\nYou’ll often include these helpful optional columns too:\n\nlabel: A human-readable name for the stage (like \"Arrival Area\", \"Waiting Room\", \"Treatment Bays\"). vidigi can display these labels on the animation to make it easier to understand.\nresource: This column links events associated with resource usage (like 'treatment_begins') to the name of the resource capacity defined in an external object (often called scenario). For example, if you have an event 'treatment_begins' and your scenario object says you have scenario.n_nurses = 5 nurses, you would put 'n_nurses' in the resource column for the 'treatment_begins' row. This tells vidigi how many resource slots to draw and manage for that step.\n\n\n\n\nLet’s create a basic event_position_df for the simple clinic example we’ve been using.\nimport pandas as pd\n\n# Create the layout DataFrame\nlayout_data = {\n    'event': ['arrival', 'start_wait', 'treatment_begins', 'depart', 'exit'], # Must match event names in the log!\n    'x': [50, 200, 200, 350, 350],  # Horizontal positions\n    'y': [200, 250, 150, 150, 50],   # Vertical positions\n    'label': ['Entrance', 'Waiting Area', 'Treatment Bays', 'Discharge', 'Exit Point'], # Human-friendly names\n    'resource': [None, None, 'n_cubicles', None, None] # Link 'treatment_begins' to the number of cubicles\n}\nmy_layout = pd.DataFrame(layout_data)\n\nprint(my_layout)\n-*Output:**\n              event    x    y             label   resource\n0           arrival   50  200          Entrance       None\n1        start_wait  200  250      Waiting Area       None\n2  treatment_begins  200  150    Treatment Bays n_cubicles  # This step uses 'n_cubicles' resources\n3            depart  350  150         Discharge       None\n4              exit  350   50        Exit Point       None\nLet’s break this down:\n\nRow 0: Anyone recorded with the event ‘arrival’ in the log will appear at coordinates (X=50, Y=200). This spot will be labelled “Entrance”.\nRow 1: When a patient’s event becomes ‘start_wait’, they move towards (X=200, Y=250). If others are already waiting, they’ll queue up extending to the left from this point. This area is labelled “Waiting Area”.\nRow 2: When a patient’s event is ‘treatment_begins’, they move towards (X=200, Y=150). Because this row has 'n_cubicles' in the resource column, vidigi knows this involves using a resource. It will look up how many n_cubicles are available (from the scenario object you provide) and place the patient icon in the correct cubicle slot near (200, 150). This area is labelled “Treatment Bays”.\nRow 3 & 4: Patients move to (350, 150) for ‘depart’ and finally vanish at the ‘exit’ point (350, 50).\n\n-(Note: We added an ‘exit’ event here, which wasn’t in the Chapter 2 log but is often added automatically by vidigi’s internal processing to ensure entities cleanly leave the screen).*\n\n\n\nYou provide this event_position_df (our my_layout variable) directly to the main animate_activity_log function:\n# (Assuming my_event_log and scenario_details from Chapter 1 & 2 exist)\nfrom vidigi.animation import animate_activity_log\n\n# --- Our layout from above ---\n# my_layout = pd.DataFrame(...)\n\n# --- Pretend we have these ---\n# my_event_log = pd.DataFrame(...) from Chapter 2\n# class SimpleScenario: n_cubicles = 2 # From Chapter 1 layout example\n# scenario_details = SimpleScenario()\n\n# --- Call the animation function ---\nmy_animation = animate_activity_log(\n    event_log=my_event_log,\n    event_position_df=my_layout,  # &lt;-- Pass the layout here!\n    scenario=scenario_details,   # &lt;-- Needed for resource counts ('n_cubicles')\n    # ... other options like time_display_units, icon_size etc.\n)\n\n# my_animation.show()\nWhen you run this, vidigi uses my_layout to determine where to draw everything. Patients arrive near (50, 200), queue leftwards from (200, 250), occupy one of the (in this case 2) treatment slots near (200, 150), and then depart via (350, 150) and (350, 50).\n\n\n\nYou don’t usually need to worry about the deep internals, but it helps to understand the basics. When animate_activity_log needs to figure out the exact position of every patient at every snapshot in time, it uses a helper function called generate_animation_df.\nHere’s a simplified idea of what generate_animation_df does:\n\nGet Base Position: For a patient P whose current event is, say, 'start_wait' at time T, it looks up 'start_wait' in the event_position_df to find the base coordinates (e.g., X=200, Y=250).\nHandle Queues: If the event_type is 'queue', it checks how many other patients are also in the 'start_wait' state at time T. It calculates an offset (usually moving left and wrapping to new rows if needed) from the base (X, Y) based on the patient’s position in the queue.\nHandle Resources: If the event_type is 'resource_use' (like 'treatment_begins'), it checks the resource column in event_position_df (e.g., 'n_cubicles'). It then asks the scenario object, “How many n_cubicles are there?”. It also looks at the patient’s specific resource_id from the event log (e.g., they are using cubicle 1). It then calculates the exact position for cubicle 1 relative to the base (X, Y) for 'treatment_begins'.\nAssign Final Position: It stores these calculated (X, Y) coordinates for patient P at time T.\n\nThis process repeats for every patient at every time snapshot.\nHere’s a simplified diagram showing the interaction:\n\n\n\n\n\nsequenceDiagram\n    participant AAL as animate_activity_log\n    participant GAD as generate_animation_df\n    participant Layout as event_position_df (The Blueprint)\n    participant Log as Event Log\n    participant Scenario as scenario object\n\n    AAL-&gt;&gt;GAD: Calculate positions for all patients at all times\n    GAD-&gt;&gt;Log: Get patient P's event & resource_id at time T\n    GAD-&gt;&gt;Layout: Get base (x, y) & resource name for event\n    alt Event is Resource Use\n        GAD-&gt;&gt;Scenario: Get total count for resource name\n        GAD-&gt;&gt;GAD: Calculate position based on base(x,y), resource_id, total count\n    else Event is Queue\n        GAD-&gt;&gt;GAD: Calculate queue position offset from base(x,y)\n    else Event is Arrival/Depart\n        GAD-&gt;&gt;GAD: Use base(x,y) directly\n    end\n    GAD--&gt;&gt;AAL: Return DataFrame with calculated positions\n\n\n\n\n\n\n\n\n\n\nMatch Event Names: The event names in event_position_df must exactly match the event names used in your event_log.\nCoordinates are Anchors: Remember (X, Y) are often the bottom-right anchor for queues and resources, which typically extend leftwards and potentially upwards in rows.\nUse setup_mode: When first creating your layout, pass setup_mode=True to animate_activity_log. This will display grid lines and coordinate axes on the animation, making it much easier to figure out good X and Y values!\nIterate: Getting the layout perfect often takes a few tries. Run the animation, see how it looks, adjust the X/Y values in your DataFrame, and run it again.\n\n\n\n\nThe event_position_df is your essential blueprint for the visual layout of your vidigi animation. It’s a simple table (DataFrame) that tells vidigi the base (X, Y) coordinates for each key event, allows you to add descriptive labels, and connects resource-using events to their capacities defined in a scenario object. By carefully crafting this layout, you control where queues form, where resources are located, and how entities move across the screen, turning your raw event data into an understandable visual story.\nNow that we understand the script (event_log) and the stage map (event_position_df), we need to look closer at the actors that use specific props – the resources. How does vidigi handle knowing exactly which cubicle or which nurse a patient is using? That involves enhancing how we define and use resources in our simulation model, which is the topic of our next chapter.\nNext up: Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Modules",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#setting-the-stage-why-we-need-a-layout",
    "href": "03_layout_configuration_event_position_df_.html#setting-the-stage-why-we-need-a-layout",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "Imagine you’re setting up a stage play. You need to decide:\n\nWhere will actors enter? (Stage Left)\nWhere is the waiting bench? (Center Stage)\nWhere is the doctor’s office set piece? (Stage Right)\n\nWithout this plan, the actors wouldn’t know where to go, and the audience would be confused.\nSimilarly, vidigi needs a map to know where to place the icons representing your patients or entities on the screen. The event_position_df provides exactly this map. For every key step (event) in your process, it defines a specific (X, Y) coordinate on the animation screen.",
    "crumbs": [
      "Modules",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#what-does-the-layout-blueprint-look-like",
    "href": "03_layout_configuration_event_position_df_.html#what-does-the-layout-blueprint-look-like",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "The event_position_df is typically a pandas DataFrame – essentially a table. Each row in this table describes a specific location or stage in your process.\nHere are the essential columns you need in this table:\n\nevent: This column contains the exact name of the event from your Event Log that corresponds to this location. For example, 'arrival', 'start_wait', 'treatment_begins'. This is how vidigi links the location map to the event script.\nx: The horizontal coordinate (position from left to right) for this event’s base location on the screen.\ny: The vertical coordinate (position from top to bottom) for this event’s base location on the screen.\n\nThink of the (X, Y) coordinates as anchor points.\n\nFor queues (like 'start_wait'), patients will line up extending leftwards from this anchor point.\nFor resources (like 'treatment_begins'), the available resource slots (e.g., treatment beds) will be placed near this anchor point, usually extending leftwards too.\nFor arrivals and departures, patients will appear or disappear at this exact anchor point.\n\nYou’ll often include these helpful optional columns too:\n\nlabel: A human-readable name for the stage (like \"Arrival Area\", \"Waiting Room\", \"Treatment Bays\"). vidigi can display these labels on the animation to make it easier to understand.\nresource: This column links events associated with resource usage (like 'treatment_begins') to the name of the resource capacity defined in an external object (often called scenario). For example, if you have an event 'treatment_begins' and your scenario object says you have scenario.n_nurses = 5 nurses, you would put 'n_nurses' in the resource column for the 'treatment_begins' row. This tells vidigi how many resource slots to draw and manage for that step.",
    "crumbs": [
      "Modules",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#a-simple-blueprint-example",
    "href": "03_layout_configuration_event_position_df_.html#a-simple-blueprint-example",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "Let’s create a basic event_position_df for the simple clinic example we’ve been using.\nimport pandas as pd\n\n# Create the layout DataFrame\nlayout_data = {\n    'event': ['arrival', 'start_wait', 'treatment_begins', 'depart', 'exit'], # Must match event names in the log!\n    'x': [50, 200, 200, 350, 350],  # Horizontal positions\n    'y': [200, 250, 150, 150, 50],   # Vertical positions\n    'label': ['Entrance', 'Waiting Area', 'Treatment Bays', 'Discharge', 'Exit Point'], # Human-friendly names\n    'resource': [None, None, 'n_cubicles', None, None] # Link 'treatment_begins' to the number of cubicles\n}\nmy_layout = pd.DataFrame(layout_data)\n\nprint(my_layout)\n-*Output:**\n              event    x    y             label   resource\n0           arrival   50  200          Entrance       None\n1        start_wait  200  250      Waiting Area       None\n2  treatment_begins  200  150    Treatment Bays n_cubicles  # This step uses 'n_cubicles' resources\n3            depart  350  150         Discharge       None\n4              exit  350   50        Exit Point       None\nLet’s break this down:\n\nRow 0: Anyone recorded with the event ‘arrival’ in the log will appear at coordinates (X=50, Y=200). This spot will be labelled “Entrance”.\nRow 1: When a patient’s event becomes ‘start_wait’, they move towards (X=200, Y=250). If others are already waiting, they’ll queue up extending to the left from this point. This area is labelled “Waiting Area”.\nRow 2: When a patient’s event is ‘treatment_begins’, they move towards (X=200, Y=150). Because this row has 'n_cubicles' in the resource column, vidigi knows this involves using a resource. It will look up how many n_cubicles are available (from the scenario object you provide) and place the patient icon in the correct cubicle slot near (200, 150). This area is labelled “Treatment Bays”.\nRow 3 & 4: Patients move to (350, 150) for ‘depart’ and finally vanish at the ‘exit’ point (350, 50).\n\n-(Note: We added an ‘exit’ event here, which wasn’t in the Chapter 2 log but is often added automatically by vidigi’s internal processing to ensure entities cleanly leave the screen).*",
    "crumbs": [
      "Modules",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#using-the-blueprint",
    "href": "03_layout_configuration_event_position_df_.html#using-the-blueprint",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "You provide this event_position_df (our my_layout variable) directly to the main animate_activity_log function:\n# (Assuming my_event_log and scenario_details from Chapter 1 & 2 exist)\nfrom vidigi.animation import animate_activity_log\n\n# --- Our layout from above ---\n# my_layout = pd.DataFrame(...)\n\n# --- Pretend we have these ---\n# my_event_log = pd.DataFrame(...) from Chapter 2\n# class SimpleScenario: n_cubicles = 2 # From Chapter 1 layout example\n# scenario_details = SimpleScenario()\n\n# --- Call the animation function ---\nmy_animation = animate_activity_log(\n    event_log=my_event_log,\n    event_position_df=my_layout,  # &lt;-- Pass the layout here!\n    scenario=scenario_details,   # &lt;-- Needed for resource counts ('n_cubicles')\n    # ... other options like time_display_units, icon_size etc.\n)\n\n# my_animation.show()\nWhen you run this, vidigi uses my_layout to determine where to draw everything. Patients arrive near (50, 200), queue leftwards from (200, 250), occupy one of the (in this case 2) treatment slots near (200, 150), and then depart via (350, 150) and (350, 50).",
    "crumbs": [
      "Modules",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#how-vidigi-reads-the-blueprint-under-the-hood",
    "href": "03_layout_configuration_event_position_df_.html#how-vidigi-reads-the-blueprint-under-the-hood",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "You don’t usually need to worry about the deep internals, but it helps to understand the basics. When animate_activity_log needs to figure out the exact position of every patient at every snapshot in time, it uses a helper function called generate_animation_df.\nHere’s a simplified idea of what generate_animation_df does:\n\nGet Base Position: For a patient P whose current event is, say, 'start_wait' at time T, it looks up 'start_wait' in the event_position_df to find the base coordinates (e.g., X=200, Y=250).\nHandle Queues: If the event_type is 'queue', it checks how many other patients are also in the 'start_wait' state at time T. It calculates an offset (usually moving left and wrapping to new rows if needed) from the base (X, Y) based on the patient’s position in the queue.\nHandle Resources: If the event_type is 'resource_use' (like 'treatment_begins'), it checks the resource column in event_position_df (e.g., 'n_cubicles'). It then asks the scenario object, “How many n_cubicles are there?”. It also looks at the patient’s specific resource_id from the event log (e.g., they are using cubicle 1). It then calculates the exact position for cubicle 1 relative to the base (X, Y) for 'treatment_begins'.\nAssign Final Position: It stores these calculated (X, Y) coordinates for patient P at time T.\n\nThis process repeats for every patient at every time snapshot.\nHere’s a simplified diagram showing the interaction:\n\n\n\n\n\nsequenceDiagram\n    participant AAL as animate_activity_log\n    participant GAD as generate_animation_df\n    participant Layout as event_position_df (The Blueprint)\n    participant Log as Event Log\n    participant Scenario as scenario object\n\n    AAL-&gt;&gt;GAD: Calculate positions for all patients at all times\n    GAD-&gt;&gt;Log: Get patient P's event & resource_id at time T\n    GAD-&gt;&gt;Layout: Get base (x, y) & resource name for event\n    alt Event is Resource Use\n        GAD-&gt;&gt;Scenario: Get total count for resource name\n        GAD-&gt;&gt;GAD: Calculate position based on base(x,y), resource_id, total count\n    else Event is Queue\n        GAD-&gt;&gt;GAD: Calculate queue position offset from base(x,y)\n    else Event is Arrival/Depart\n        GAD-&gt;&gt;GAD: Use base(x,y) directly\n    end\n    GAD--&gt;&gt;AAL: Return DataFrame with calculated positions",
    "crumbs": [
      "Modules",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#tips-for-setting-up-your-layout",
    "href": "03_layout_configuration_event_position_df_.html#tips-for-setting-up-your-layout",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "Match Event Names: The event names in event_position_df must exactly match the event names used in your event_log.\nCoordinates are Anchors: Remember (X, Y) are often the bottom-right anchor for queues and resources, which typically extend leftwards and potentially upwards in rows.\nUse setup_mode: When first creating your layout, pass setup_mode=True to animate_activity_log. This will display grid lines and coordinate axes on the animation, making it much easier to figure out good X and Y values!\nIterate: Getting the layout perfect often takes a few tries. Run the animation, see how it looks, adjust the X/Y values in your DataFrame, and run it again.",
    "crumbs": [
      "Modules",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "03_layout_configuration_event_position_df_.html#conclusion",
    "href": "03_layout_configuration_event_position_df_.html#conclusion",
    "title": "Chapter 3: Layout Configuration (event_position_df)",
    "section": "",
    "text": "The event_position_df is your essential blueprint for the visual layout of your vidigi animation. It’s a simple table (DataFrame) that tells vidigi the base (X, Y) coordinates for each key event, allows you to add descriptive labels, and connects resource-using events to their capacities defined in a scenario object. By carefully crafting this layout, you control where queues form, where resources are located, and how entities move across the screen, turning your raw event data into an understandable visual story.\nNow that we understand the script (event_log) and the stage map (event_position_df), we need to look closer at the actors that use specific props – the resources. How does vidigi handle knowing exactly which cubicle or which nurse a patient is using? That involves enhancing how we define and use resources in our simulation model, which is the topic of our next chapter.\nNext up: Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Modules",
      "Chapter 3: Layout Configuration (`event_position_df`)"
    ]
  },
  {
    "objectID": "01_animation_facade_animate_activity_log_.html",
    "href": "01_animation_facade_animate_activity_log_.html",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "Welcome to vidigi! If you’ve ever watched a simulation of people moving through a hospital, a queue at a shop, or any process, you know how helpful visualizations can be. vidigi is designed to help you create exactly those kinds of animations from your process data.\nBut creating animations can seem complicated, right? You need to track where everyone is at every moment, figure out their positions on the screen, and then stitch it all together. It sounds like a lot of work!\nThat’s where animate_activity_log comes in. Think of it as the “Easy Button” for creating your vidigi animations.\n\n\nImagine you’re directing a movie. You have actors (your data points, like patients), a script (the sequence of events), and a set (the layout on the screen). As the director, you don’t need to personally handle the camera, the lighting, and the sound – you coordinate specialists who do that.\nanimate_activity_log is like that director. It’s the main, high-level function you’ll usually interact with. You give it the raw information:\n\nWhat happened? The sequence of events (like patient arrivals, waiting, treatment). This is called the Event Log.\nWhere should things be? The layout or map showing where different activities (like the waiting room or treatment cubicle) appear on the screen. This is the Layout Configuration (event_position_df).\nOptional Details: Extra information, like how many nurses are available (we call this scenario info), and how you want the animation to look (speed, icons, background image, etc.).\n\nYou provide these inputs, and animate_activity_log coordinates all the underlying steps needed to produce the final, animated movie (a Plotly figure). It simplifies the whole process for you!\n\n\n\nLet’s say you have your data ready in two tables (we’ll learn how to make these in later chapters!):\n\nmy_event_log: A table listing every time a patient arrived, started waiting, got treated, etc.\nmy_layout: A table defining the (x, y) coordinates on the screen for “Arrival”, “Waiting Area”, “Treatment Room”, and “Exit”.\n\nUsing animate_activity_log is straightforward:\n# Import the function first\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd # We'll use pandas DataFrames\n\n# --- Pretend we have these already ---\n# (Chapters 2 & 3 will show how to create these!)\nmy_event_log = pd.DataFrame({ # A simplified example log\n    'patient': [1, 1, 1, 1, 2, 2, 2, 2],\n    'event': ['arrival', 'start_wait', 'start_treat', 'depart',\n              'arrival', 'start_wait', 'start_treat', 'depart'],\n    'time': [0, 0, 5, 15, 2, 2, 8, 20],\n    # ... other columns needed like event_type, pathway, resource_id ...\n    'event_type': ['arrival_departure','queue','resource_use','arrival_departure',\n                   'arrival_departure','queue','resource_use','arrival_departure'],\n    'pathway': ['A','A','A','A', 'A','A','A','A'],\n    'resource_id': [None, None, 1, None, None, None, 2, None],\n    'run': [1,1,1,1, 1,1,1,1]\n})\n\nmy_layout = pd.DataFrame({ # A simplified example layout\n    'event': ['arrival', 'start_wait', 'start_treat', 'depart'],\n    'x': [10, 50, 100, 150],\n    'y': [50, 50, 50, 50],\n    'label': ['Arrival', 'Waiting', 'Treatment', 'Exit'], # Human-readable names\n    'resource': [None, None, 'treatment_rooms', None] # Link resource events to capacity\n})\n\n# --- A simple scenario object (optional) ---\nclass SimpleScenario:\n    treatment_rooms = 2 # Let's say we have 2 treatment rooms\nscenario_details = SimpleScenario()\n\n# --- Now, the magic happens! ---\n# Call the \"Easy Button\" function\nmy_animation = animate_activity_log(\n    event_log=my_event_log,          # What happened?\n    event_position_df=my_layout,     # Where should things be?\n    scenario=scenario_details,       # How many resources? (Optional)\n    time_display_units='dhm',        # Show time as days/hours/mins\n    icon_and_text_size=20,           # Make icons a bit smaller\n    every_x_time_units=1             # Take a snapshot every 1 time unit\n)\n\n# You can now display the animation (e.g., in a Jupyter Notebook)\n# my_animation.show() # This would pop up the interactive animation\nWhat happens when you run this?\nYou don’t get numbers or text back directly. Instead, my_animation holds an interactive Plotly animation object. If you were running this in a tool like a Jupyter Notebook and called my_animation.show(), you’d see an animation appear, showing little icons (representing patients) moving from the ‘Arrival’ location, possibly waiting at ‘Waiting’, moving to ‘Treatment’, and finally leaving via ‘Exit’, all synchronized with the times in my_event_log.\n\n\n\nanimate_activity_log acts like our movie director, but it relies on a crew of helper functions to do the actual work. Here’s a simplified view of the steps it takes internally when you call it:\n\nSnapshot Prep (Act 1): The raw event_log tells us when things change, but an animation needs to know where everyone is at regular intervals (like every minute, or every 10 minutes). animate_activity_log first calls helper functions (reshape_for_animations) to process the event log and figure out the status (location or activity) of every patient at each “snapshot” time.\nPosition Calculation (Act 2): Knowing a patient is “Waiting” isn’t enough for the animation; we need exact (x, y) screen coordinates. animate_activity_log uses another helper (generate_animation_df) along with your event_position_df (the layout) to calculate the precise (x, y) position for every patient in every snapshot, handling things like arranging patients neatly in queues or assigning them to specific resource slots (like Treatment Room 1 vs. Treatment Room 2).\nAnimation Generation (The Final Cut): With the fully prepared data frame containing patient IDs, icons, and precise (x, y) coordinates for every time snapshot, animate_activity_log calls the final specialist function (generate_animation). This function takes all that prepared data and uses the Plotly library to build the actual interactive animation figure, complete with a timeline slider, play/pause buttons, and tooltips.\n\nHere’s a diagram showing that flow:\n\n\n\n\n\nsequenceDiagram\n    participant U as User\n    participant AAL as animate_activity_log (The Director)\n    participant RFA as reshape_for_animations (Snapshot Prep)\n    participant GAD as generate_animation_df (Position Calc)\n    participant GA as generate_animation (Animation Builder)\n    participant PFig as Plotly Figure (The Movie)\n\n    U-&gt;&gt;AAL: Call with event_log, layout, options\n    AAL-&gt;&gt;RFA: Process event_log for snapshots\n    RFA--&gt;&gt;AAL: Return snapshot data\n    AAL-&gt;&gt;GAD: Calculate (x, y) positions using snapshot data & layout\n    GAD--&gt;&gt;AAL: Return data with positions\n    AAL-&gt;&gt;GA: Generate animation using positioned data & options\n    GA--&gt;&gt;AAL: Return Plotly animation object\n    AAL--&gt;&gt;U: Return Plotly Figure\n\n\n\n\n\n\nEssentially, animate_activity_log orchestrates calls to these more specialized functions, which you can explore in later chapters:\n\nSnapshot Preparation (reshape_for_animations & generate_animation_df)\nAnimation Generation (generate_animation)\n\nYou can call these functions individually if you need very fine-grained control, but for most uses, the animate_activity_log facade is the way to go!\n\n\n\nWhile we used basic options above, animate_activity_log has many parameters to customize your animation:\n\nevery_x_time_units: How often to take a snapshot (smaller numbers = smoother but potentially slower animation).\nicon_and_text_size: Controls the size of the patient icons and any labels.\nadd_background_image: You can overlay the animation on a floor plan or diagram!\ntime_display_units: Show time as simple numbers, or format it like ‘Days:Hours:Minutes’.\nframe_duration / frame_transition_duration: Control the speed of the animation playback.\nwrap_queues_at: How many patients to show in a line before starting a new row in a queue.\n\n…and many more! Check the function’s documentation for all the possibilities.\n\n\n\nYou’ve now met animate_activity_log, the main entry point and “easy button” for creating process animations with vidigi. It acts as a facade, hiding the complexity of data preparation and animation generation by coordinating specialized helper functions. You provide the raw event data and layout information, and it delivers the final animated visualization.\nBut how do we get that crucial event_log data in the first place? That’s exactly what we’ll cover in the next chapter!\nNext up: Chapter 2: Event Log\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Modules",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "01_animation_facade_animate_activity_log_.html#the-easy-button-concept",
    "href": "01_animation_facade_animate_activity_log_.html#the-easy-button-concept",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "Imagine you’re directing a movie. You have actors (your data points, like patients), a script (the sequence of events), and a set (the layout on the screen). As the director, you don’t need to personally handle the camera, the lighting, and the sound – you coordinate specialists who do that.\nanimate_activity_log is like that director. It’s the main, high-level function you’ll usually interact with. You give it the raw information:\n\nWhat happened? The sequence of events (like patient arrivals, waiting, treatment). This is called the Event Log.\nWhere should things be? The layout or map showing where different activities (like the waiting room or treatment cubicle) appear on the screen. This is the Layout Configuration (event_position_df).\nOptional Details: Extra information, like how many nurses are available (we call this scenario info), and how you want the animation to look (speed, icons, background image, etc.).\n\nYou provide these inputs, and animate_activity_log coordinates all the underlying steps needed to produce the final, animated movie (a Plotly figure). It simplifies the whole process for you!",
    "crumbs": [
      "Modules",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "01_animation_facade_animate_activity_log_.html#how-to-use-animate_activity_log-a-simple-example",
    "href": "01_animation_facade_animate_activity_log_.html#how-to-use-animate_activity_log-a-simple-example",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "Let’s say you have your data ready in two tables (we’ll learn how to make these in later chapters!):\n\nmy_event_log: A table listing every time a patient arrived, started waiting, got treated, etc.\nmy_layout: A table defining the (x, y) coordinates on the screen for “Arrival”, “Waiting Area”, “Treatment Room”, and “Exit”.\n\nUsing animate_activity_log is straightforward:\n# Import the function first\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd # We'll use pandas DataFrames\n\n# --- Pretend we have these already ---\n# (Chapters 2 & 3 will show how to create these!)\nmy_event_log = pd.DataFrame({ # A simplified example log\n    'patient': [1, 1, 1, 1, 2, 2, 2, 2],\n    'event': ['arrival', 'start_wait', 'start_treat', 'depart',\n              'arrival', 'start_wait', 'start_treat', 'depart'],\n    'time': [0, 0, 5, 15, 2, 2, 8, 20],\n    # ... other columns needed like event_type, pathway, resource_id ...\n    'event_type': ['arrival_departure','queue','resource_use','arrival_departure',\n                   'arrival_departure','queue','resource_use','arrival_departure'],\n    'pathway': ['A','A','A','A', 'A','A','A','A'],\n    'resource_id': [None, None, 1, None, None, None, 2, None],\n    'run': [1,1,1,1, 1,1,1,1]\n})\n\nmy_layout = pd.DataFrame({ # A simplified example layout\n    'event': ['arrival', 'start_wait', 'start_treat', 'depart'],\n    'x': [10, 50, 100, 150],\n    'y': [50, 50, 50, 50],\n    'label': ['Arrival', 'Waiting', 'Treatment', 'Exit'], # Human-readable names\n    'resource': [None, None, 'treatment_rooms', None] # Link resource events to capacity\n})\n\n# --- A simple scenario object (optional) ---\nclass SimpleScenario:\n    treatment_rooms = 2 # Let's say we have 2 treatment rooms\nscenario_details = SimpleScenario()\n\n# --- Now, the magic happens! ---\n# Call the \"Easy Button\" function\nmy_animation = animate_activity_log(\n    event_log=my_event_log,          # What happened?\n    event_position_df=my_layout,     # Where should things be?\n    scenario=scenario_details,       # How many resources? (Optional)\n    time_display_units='dhm',        # Show time as days/hours/mins\n    icon_and_text_size=20,           # Make icons a bit smaller\n    every_x_time_units=1             # Take a snapshot every 1 time unit\n)\n\n# You can now display the animation (e.g., in a Jupyter Notebook)\n# my_animation.show() # This would pop up the interactive animation\nWhat happens when you run this?\nYou don’t get numbers or text back directly. Instead, my_animation holds an interactive Plotly animation object. If you were running this in a tool like a Jupyter Notebook and called my_animation.show(), you’d see an animation appear, showing little icons (representing patients) moving from the ‘Arrival’ location, possibly waiting at ‘Waiting’, moving to ‘Treatment’, and finally leaving via ‘Exit’, all synchronized with the times in my_event_log.",
    "crumbs": [
      "Modules",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "01_animation_facade_animate_activity_log_.html#whats-happening-under-the-hood",
    "href": "01_animation_facade_animate_activity_log_.html#whats-happening-under-the-hood",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "animate_activity_log acts like our movie director, but it relies on a crew of helper functions to do the actual work. Here’s a simplified view of the steps it takes internally when you call it:\n\nSnapshot Prep (Act 1): The raw event_log tells us when things change, but an animation needs to know where everyone is at regular intervals (like every minute, or every 10 minutes). animate_activity_log first calls helper functions (reshape_for_animations) to process the event log and figure out the status (location or activity) of every patient at each “snapshot” time.\nPosition Calculation (Act 2): Knowing a patient is “Waiting” isn’t enough for the animation; we need exact (x, y) screen coordinates. animate_activity_log uses another helper (generate_animation_df) along with your event_position_df (the layout) to calculate the precise (x, y) position for every patient in every snapshot, handling things like arranging patients neatly in queues or assigning them to specific resource slots (like Treatment Room 1 vs. Treatment Room 2).\nAnimation Generation (The Final Cut): With the fully prepared data frame containing patient IDs, icons, and precise (x, y) coordinates for every time snapshot, animate_activity_log calls the final specialist function (generate_animation). This function takes all that prepared data and uses the Plotly library to build the actual interactive animation figure, complete with a timeline slider, play/pause buttons, and tooltips.\n\nHere’s a diagram showing that flow:\n\n\n\n\n\nsequenceDiagram\n    participant U as User\n    participant AAL as animate_activity_log (The Director)\n    participant RFA as reshape_for_animations (Snapshot Prep)\n    participant GAD as generate_animation_df (Position Calc)\n    participant GA as generate_animation (Animation Builder)\n    participant PFig as Plotly Figure (The Movie)\n\n    U-&gt;&gt;AAL: Call with event_log, layout, options\n    AAL-&gt;&gt;RFA: Process event_log for snapshots\n    RFA--&gt;&gt;AAL: Return snapshot data\n    AAL-&gt;&gt;GAD: Calculate (x, y) positions using snapshot data & layout\n    GAD--&gt;&gt;AAL: Return data with positions\n    AAL-&gt;&gt;GA: Generate animation using positioned data & options\n    GA--&gt;&gt;AAL: Return Plotly animation object\n    AAL--&gt;&gt;U: Return Plotly Figure\n\n\n\n\n\n\nEssentially, animate_activity_log orchestrates calls to these more specialized functions, which you can explore in later chapters:\n\nSnapshot Preparation (reshape_for_animations & generate_animation_df)\nAnimation Generation (generate_animation)\n\nYou can call these functions individually if you need very fine-grained control, but for most uses, the animate_activity_log facade is the way to go!",
    "crumbs": [
      "Modules",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "01_animation_facade_animate_activity_log_.html#key-customization-options",
    "href": "01_animation_facade_animate_activity_log_.html#key-customization-options",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "While we used basic options above, animate_activity_log has many parameters to customize your animation:\n\nevery_x_time_units: How often to take a snapshot (smaller numbers = smoother but potentially slower animation).\nicon_and_text_size: Controls the size of the patient icons and any labels.\nadd_background_image: You can overlay the animation on a floor plan or diagram!\ntime_display_units: Show time as simple numbers, or format it like ‘Days:Hours:Minutes’.\nframe_duration / frame_transition_duration: Control the speed of the animation playback.\nwrap_queues_at: How many patients to show in a line before starting a new row in a queue.\n\n…and many more! Check the function’s documentation for all the possibilities.",
    "crumbs": [
      "Modules",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "01_animation_facade_animate_activity_log_.html#conclusion",
    "href": "01_animation_facade_animate_activity_log_.html#conclusion",
    "title": "Chapter 1: Animation Facade (animate_activity_log)",
    "section": "",
    "text": "You’ve now met animate_activity_log, the main entry point and “easy button” for creating process animations with vidigi. It acts as a facade, hiding the complexity of data preparation and animation generation by coordinating specialized helper functions. You provide the raw event data and layout information, and it delivers the final animated visualization.\nBut how do we get that crucial event_log data in the first place? That’s exactly what we’ll cover in the next chapter!\nNext up: Chapter 2: Event Log\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Modules",
      "Chapter 1: Animation Facade (`animate_activity_log`)"
    ]
  },
  {
    "objectID": "02_event_log_.html",
    "href": "02_event_log_.html",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "In Chapter 1: Animation Facade (animate_activity_log), we learned about the “Easy Button” animate_activity_log function. We saw that it needs two main ingredients: the “What happened?” data and the “Where should things be?” layout.\nThis chapter focuses on the first ingredient: the Event Log. It’s the heart of your simulation data and tells vidigi exactly what happened, to whom, and when.\n\n\nImagine you’re trying to make a movie about a busy day at a small clinic. To show what happened accurately, you wouldn’t just film random moments. You’d need a detailed script or a logbook tracking each patient:\n\nWhen did Patient Alice arrive? (9:00 AM)\nWhen did she start waiting in the waiting room? (9:01 AM)\nWhen did Nurse Bob become free? (9:15 AM)\nWhen did Alice start her consultation with Nurse Bob? (9:15 AM)\nWhen did the consultation end? (9:30 AM)\nWhen did Alice leave the clinic? (9:31 AM)\n\nAnd you’d need this information for every patient (Alice, Charlie, David…).\nThat’s precisely what the Event Log provides for vidigi. It’s like a detailed diary or logbook for your simulated system (like the clinic, a factory line, a call center, etc.). It tracks every important step or “event” for each “patient” or “entity” as it moves through the process. Without this detailed sequence, vidigi wouldn’t know how to create the animation!\n\n\n\nThe Event Log is essentially a table, most commonly represented as a pandas DataFrame in Python. Think of it like a spreadsheet where each row represents a significant moment (an event) that occurred.\nTo work correctly with vidigi, this table must have specific columns:\n\npatient: This column identifies who the event happened to. It could be a patient ID number, a customer name, a product code – whatever uniquely identifies the entity moving through your system.\nevent_type: This tells vidigi the kind of event that occurred. It’s a broad category. The main types are:\n\narrival_departure: The entity entered or exited the system.\nqueue: The entity started waiting in a line or area.\nresource_use: The entity started using a specific resource (like a nurse, a machine, a checkout counter).\nresource_use_end: The entity finished using that specific resource.\n\nevent: This gives the specific name of the event. For arrivals and departures, this must be exactly 'arrival' or 'depart'. For queues and resource use, you can define custom names (like 'start_wait_room', 'begin_treatment', 'end_checkout').\ntime: This records when the event happened, usually as a number representing the simulation time (e.g., minutes or hours from the start).\n\nAnd one more, which is needed only for specific event_types:\n\nresource_id: When an entity starts or stops using a specific resource (like Treatment Room 1 vs Treatment Room 2), this column tells vidigi which one it was. This is only required for event_type 'resource_use' and 'resource_use_end'.\n\nYou might also see other helpful columns like:\n\npathway: If your system has different routes entities can take, this might label the specific path.\nrun: If you run your simulation multiple times, this identifies which run the event belongs to.\n\n\n\n\nLet’s look at a small, simplified Event Log DataFrame, similar to the one we saw in Chapter 1:\nimport pandas as pd\n\n# Create a simple Event Log as a pandas DataFrame\nevent_log_data = {\n    'patient': [1, 1, 1, 1, 2, 2, 2, 2],\n    'event_type': ['arrival_departure', 'queue', 'resource_use', 'arrival_departure',\n                   'arrival_departure', 'queue', 'resource_use', 'arrival_departure'],\n    'event': ['arrival', 'start_wait', 'start_treat', 'depart',\n              'arrival', 'start_wait', 'start_treat', 'depart'],\n    'time': [0, 0, 5, 15, 2, 2, 8, 20],\n    'resource_id': [None, None, 1, None, None, None, 2, None], # Note: Only filled for 'resource_use'\n    'pathway': ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A'], # Optional: All follow Pathway A\n    'run': [1, 1, 1, 1, 1, 1, 1, 1] # Optional: All from Run 1\n}\nmy_event_log = pd.DataFrame(event_log_data)\n\nprint(my_event_log)\nOutput:\n   patient       event_type        event  time  resource_id pathway  run\n0        1  arrival_departure      arrival     0          NaN       A    1\n1        1              queue   start_wait     0          NaN       A    1\n2        1       resource_use  start_treat     5          1.0       A    1  # Used resource 1\n3        1  arrival_departure       depart    15          NaN       A    1\n4        2  arrival_departure      arrival     2          NaN       A    1\n5        2              queue   start_wait     2          NaN       A    1\n6        2       resource_use  start_treat     8          2.0       A    1  # Used resource 2\n7        2  arrival_departure       depart    20          NaN       A    1\nLet’s break down what this log tells vidigi:\n\nRow 0: Patient 1 arrival occurred (event_type arrival_departure) at time 0.\nRow 1: Patient 1 started waiting (event start_wait, event_type queue) also at time 0.\nRow 2: Patient 1 started treatment (event start_treat, event_type resource_use) at time 5. Crucially, it used resource 1 (resource_id is 1.0).\nRow 3: Patient 1 left the system (event depart, event_type arrival_departure) at time 15.\nRow 4: Patient 2 arrival occurred at time 2.\n…and so on for Patient 2, who used resource 2.\n\nNotice how resource_id is only filled in when the event_type is resource_use. We’d also need it for resource_use_end events (which aren’t shown in this very simplified example, but are important in real logs!).\n\n\n\nThis log is the raw material. When you call animate_activity_log (or the helper functions it uses, like reshape_for_animations), vidigi reads this table.\nIt essentially “plays back” the log, figuring out: “At time 0, who was where? At time 1? At time 2?…” It uses the time column to order events and the event_type and event columns to understand what state each patient is in at any given moment. The resource_id helps it place patients at the correct resource spot in the animation.\nThink of vidigi as an animator reading the script (the Event Log) frame by frame to draw the movie. The more accurate and detailed your Event Log, the better your final animation will be!\n\n\n\nYou typically don’t create these logs by hand! They are usually generated automatically:\n\nSimulation Models: Software like SimPy (often used with vidigi) or Ciw can be programmed to record these events automatically as the simulation runs. You add small “logging” snippets to your simulation code at key points (like when a patient arrives, requests a resource, etc.).\n\nvidigi provides helpers to make this easier, like CustomResource and populate_store for SimPy.\nThere’s even a utility (utils.event_log_from_ciw_recs) to convert logs from the Ciw library.\nAn example of adding logging to a SimPy model can be found in the documentation (vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.qmd).\n\nReal-World Data: Sometimes, you might have data logs from real systems (like timestamped entries in a hospital database or factory sensor readings). You would need to process this data into the specific vidigi Event Log format (with the required columns).\n\n\n\n\nThe Event Log is the fundamental data input for vidigi. It’s a structured table (usually a pandas DataFrame) that acts like a detailed diary, recording every significant moment (event, event_type) for each entity (patient) at a specific time, sometimes involving a particular resource_id.\nvidigi reads this log to reconstruct the system’s dynamics and create the animation. Getting this log right is the first crucial step!\nNow that we understand what happened (the Event Log), how do we tell vidigi where these events should appear on the screen? That’s the job of the Layout Configuration, which we’ll explore next.\nNext up: Chapter 3: Layout Configuration (event_position_df)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Modules",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "02_event_log_.html#the-story-of-your-process-why-we-need-an-event-log",
    "href": "02_event_log_.html#the-story-of-your-process-why-we-need-an-event-log",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "Imagine you’re trying to make a movie about a busy day at a small clinic. To show what happened accurately, you wouldn’t just film random moments. You’d need a detailed script or a logbook tracking each patient:\n\nWhen did Patient Alice arrive? (9:00 AM)\nWhen did she start waiting in the waiting room? (9:01 AM)\nWhen did Nurse Bob become free? (9:15 AM)\nWhen did Alice start her consultation with Nurse Bob? (9:15 AM)\nWhen did the consultation end? (9:30 AM)\nWhen did Alice leave the clinic? (9:31 AM)\n\nAnd you’d need this information for every patient (Alice, Charlie, David…).\nThat’s precisely what the Event Log provides for vidigi. It’s like a detailed diary or logbook for your simulated system (like the clinic, a factory line, a call center, etc.). It tracks every important step or “event” for each “patient” or “entity” as it moves through the process. Without this detailed sequence, vidigi wouldn’t know how to create the animation!",
    "crumbs": [
      "Modules",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "02_event_log_.html#what-does-an-event-log-look-like",
    "href": "02_event_log_.html#what-does-an-event-log-look-like",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "The Event Log is essentially a table, most commonly represented as a pandas DataFrame in Python. Think of it like a spreadsheet where each row represents a significant moment (an event) that occurred.\nTo work correctly with vidigi, this table must have specific columns:\n\npatient: This column identifies who the event happened to. It could be a patient ID number, a customer name, a product code – whatever uniquely identifies the entity moving through your system.\nevent_type: This tells vidigi the kind of event that occurred. It’s a broad category. The main types are:\n\narrival_departure: The entity entered or exited the system.\nqueue: The entity started waiting in a line or area.\nresource_use: The entity started using a specific resource (like a nurse, a machine, a checkout counter).\nresource_use_end: The entity finished using that specific resource.\n\nevent: This gives the specific name of the event. For arrivals and departures, this must be exactly 'arrival' or 'depart'. For queues and resource use, you can define custom names (like 'start_wait_room', 'begin_treatment', 'end_checkout').\ntime: This records when the event happened, usually as a number representing the simulation time (e.g., minutes or hours from the start).\n\nAnd one more, which is needed only for specific event_types:\n\nresource_id: When an entity starts or stops using a specific resource (like Treatment Room 1 vs Treatment Room 2), this column tells vidigi which one it was. This is only required for event_type 'resource_use' and 'resource_use_end'.\n\nYou might also see other helpful columns like:\n\npathway: If your system has different routes entities can take, this might label the specific path.\nrun: If you run your simulation multiple times, this identifies which run the event belongs to.",
    "crumbs": [
      "Modules",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "02_event_log_.html#a-simple-example",
    "href": "02_event_log_.html#a-simple-example",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "Let’s look at a small, simplified Event Log DataFrame, similar to the one we saw in Chapter 1:\nimport pandas as pd\n\n# Create a simple Event Log as a pandas DataFrame\nevent_log_data = {\n    'patient': [1, 1, 1, 1, 2, 2, 2, 2],\n    'event_type': ['arrival_departure', 'queue', 'resource_use', 'arrival_departure',\n                   'arrival_departure', 'queue', 'resource_use', 'arrival_departure'],\n    'event': ['arrival', 'start_wait', 'start_treat', 'depart',\n              'arrival', 'start_wait', 'start_treat', 'depart'],\n    'time': [0, 0, 5, 15, 2, 2, 8, 20],\n    'resource_id': [None, None, 1, None, None, None, 2, None], # Note: Only filled for 'resource_use'\n    'pathway': ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A'], # Optional: All follow Pathway A\n    'run': [1, 1, 1, 1, 1, 1, 1, 1] # Optional: All from Run 1\n}\nmy_event_log = pd.DataFrame(event_log_data)\n\nprint(my_event_log)\nOutput:\n   patient       event_type        event  time  resource_id pathway  run\n0        1  arrival_departure      arrival     0          NaN       A    1\n1        1              queue   start_wait     0          NaN       A    1\n2        1       resource_use  start_treat     5          1.0       A    1  # Used resource 1\n3        1  arrival_departure       depart    15          NaN       A    1\n4        2  arrival_departure      arrival     2          NaN       A    1\n5        2              queue   start_wait     2          NaN       A    1\n6        2       resource_use  start_treat     8          2.0       A    1  # Used resource 2\n7        2  arrival_departure       depart    20          NaN       A    1\nLet’s break down what this log tells vidigi:\n\nRow 0: Patient 1 arrival occurred (event_type arrival_departure) at time 0.\nRow 1: Patient 1 started waiting (event start_wait, event_type queue) also at time 0.\nRow 2: Patient 1 started treatment (event start_treat, event_type resource_use) at time 5. Crucially, it used resource 1 (resource_id is 1.0).\nRow 3: Patient 1 left the system (event depart, event_type arrival_departure) at time 15.\nRow 4: Patient 2 arrival occurred at time 2.\n…and so on for Patient 2, who used resource 2.\n\nNotice how resource_id is only filled in when the event_type is resource_use. We’d also need it for resource_use_end events (which aren’t shown in this very simplified example, but are important in real logs!).",
    "crumbs": [
      "Modules",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "02_event_log_.html#how-vidigi-uses-the-event-log",
    "href": "02_event_log_.html#how-vidigi-uses-the-event-log",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "This log is the raw material. When you call animate_activity_log (or the helper functions it uses, like reshape_for_animations), vidigi reads this table.\nIt essentially “plays back” the log, figuring out: “At time 0, who was where? At time 1? At time 2?…” It uses the time column to order events and the event_type and event columns to understand what state each patient is in at any given moment. The resource_id helps it place patients at the correct resource spot in the animation.\nThink of vidigi as an animator reading the script (the Event Log) frame by frame to draw the movie. The more accurate and detailed your Event Log, the better your final animation will be!",
    "crumbs": [
      "Modules",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "02_event_log_.html#where-do-event-logs-come-from",
    "href": "02_event_log_.html#where-do-event-logs-come-from",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "You typically don’t create these logs by hand! They are usually generated automatically:\n\nSimulation Models: Software like SimPy (often used with vidigi) or Ciw can be programmed to record these events automatically as the simulation runs. You add small “logging” snippets to your simulation code at key points (like when a patient arrives, requests a resource, etc.).\n\nvidigi provides helpers to make this easier, like CustomResource and populate_store for SimPy.\nThere’s even a utility (utils.event_log_from_ciw_recs) to convert logs from the Ciw library.\nAn example of adding logging to a SimPy model can be found in the documentation (vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.qmd).\n\nReal-World Data: Sometimes, you might have data logs from real systems (like timestamped entries in a hospital database or factory sensor readings). You would need to process this data into the specific vidigi Event Log format (with the required columns).",
    "crumbs": [
      "Modules",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "02_event_log_.html#conclusion",
    "href": "02_event_log_.html#conclusion",
    "title": "Chapter 2: Event Log",
    "section": "",
    "text": "The Event Log is the fundamental data input for vidigi. It’s a structured table (usually a pandas DataFrame) that acts like a detailed diary, recording every significant moment (event, event_type) for each entity (patient) at a specific time, sometimes involving a particular resource_id.\nvidigi reads this log to reconstruct the system’s dynamics and create the animation. Getting this log right is the first crucial step!\nNow that we understand what happened (the Event Log), how do we tell vidigi where these events should appear on the screen? That’s the job of the Layout Configuration, which we’ll explore next.\nNext up: Chapter 3: Layout Configuration (event_position_df)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Modules",
      "Chapter 2: Event Log"
    ]
  },
  {
    "objectID": "04_simpy_resource_enhancement_customresource_store_populate_store_.html",
    "href": "04_simpy_resource_enhancement_customresource_store_populate_store_.html",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "In Chapter 3: Layout Configuration (event_position_df), we learned how to create a blueprint (event_position_df) that tells vidigi where to place entities on the screen for different events like waiting or using a resource. We saw that for resource steps (like “Treatment Bays”), vidigi needs to know how many resource slots are available.\nBut there’s a subtle challenge: how does vidigi know if Patient Alice is always using Treatment Bay 1 throughout her treatment, or if she magically swaps places with Patient Bob in Bay 2 halfway through? For a clear animation, we want to see Alice consistently stay in Bay 1.\nThis chapter explains how vidigi handles this using a special pattern when you build your simulation model with the popular library SimPy.\n\n\nImagine a small clinic with two identical treatment rooms (Room A and Room B). SimPy, a library often used to create the simulation data that vidigi visualizes, has a concept called simpy.Resource to represent things like these rooms.\nYou can tell SimPy “I have 2 treatment rooms”. When a patient needs a room, SimPy can tell you “Okay, a room is available”. But it doesn’t inherently tell you which room (A or B) the patient got.\nIf Patient Alice gets a room, and later Patient Bob gets a room, the simulation knows two rooms are busy. But the standard event log might just say:\n\nTime 5: Alice starts using a room.\nTime 8: Bob starts using a room.\n\nWhen vidigi reads this, it doesn’t know if Alice is in Room A and Bob in Room B, or vice-versa. In the animation, Alice might appear in the spot for Room A in one frame and Room B in the next, which looks confusing!\nWe need a way to give each individual resource (each room, each nurse, each machine) a unique ID, like giving each worker a specific ID badge.\n\n\n\nvidigi uses a clever workaround combined with helpers provided in its utils module:\n\nsimpy.Store: Instead of using simpy.Resource directly to represent the pool of treatment rooms, we use a simpy.Store. Think of a Store like a container or a shelf that can hold individual items. Our “shelf” will hold our individual, identifiable treatment rooms.\nvidigi.utils.CustomResource: We need items to put in the Store. We can’t just put standard simpy.Resource objects in there, because they still lack IDs. So, vidigi provides CustomResource. It’s almost identical to a simpy.Resource, but with one crucial addition: an id_attribute. This is our ID badge! Each CustomResource instance we create will represent one specific treatment room (like Room A or Room B) and will have its own unique ID.\nvidigi.utils.populate_store: Manually creating each CustomResource (each nurse, each room) and putting it into the Store can be repetitive. vidigi provides a helper function, populate_store, that does this for you. You tell it how many resources you need (e.g., 2 treatment rooms), which Store to put them in, and it automatically creates the right number of CustomResource objects, assigns them unique IDs (like 1, 2), and puts them into the Store.\n\nAnalogy:\n\nImagine you have 3 nurses (num_resources = 3).\nThe simpy.Store is the Nurses’ Station (simpy_store).\nCustomResource is a Nurse object that includes an ID badge (id_attribute).\npopulate_store is the supervisor who hires 3 nurses, gives them badges labelled “Nurse 1”, “Nurse 2”, “Nurse 3”, and tells them to wait at the Nurses’ Station (simpy_store).\n\n\n\n\nLet’s see how you’d modify a typical SimPy model setup.\n1. Before (Using simpy.Resource):\n# --- In your Model's __init__ or resource setup ---\nimport simpy\n\n# Assume 'self.env' is your simpy.Environment\n# Assume 'g.n_cubicles' holds the number of cubicles (e.g., 2)\n# self.treatment_cubicles = simpy.Resource(self.env, capacity=g.n_cubicles)\n\n# --- In your SimPy process function (e.g., attend_clinic) ---\n# def attend_clinic(self, patient):\n    # ... other code ...\n\n    # Request *a* cubicle\n    # with self.treatment_cubicles.request() as req:\n    #     yield req\n        # --- Log the start of treatment ---\n        # (Problem: No specific cubicle ID here!)\n        # self.event_log.append({\n        #     'patient': patient.identifier,\n        #     'event': 'treatment_begins',\n        #     'event_type': 'resource_use',\n        #     'time': self.env.now,\n        #     'resource_id': None # &lt;--- We don't know which one!\n        # })\n\n        # yield self.env.timeout(treatment_duration)\n        # --- Log the end of treatment ---\n        # (Still no specific ID)\n\n    # ... other code ...\nThis code works for SimPy, but it doesn’t log the specific resource_id needed by vidigi.\n2. After (Using Store, CustomResource, populate_store):\n# --- Add imports at the top of your file ---\nimport simpy\nfrom vidigi.utils import CustomResource, populate_store # Import helpers\n\n# --- In your Model's __init__ or resource setup ---\n# Assume 'self.env' is your simpy.Environment\n# Assume 'g.n_cubicles' holds the number of cubicles (e.g., 2)\n\n# 1. Create an empty Store instead of a Resource\nself.treatment_cubicles_store = simpy.Store(self.env)\n\n# 2. Use populate_store to fill it with ID'd CustomResources\npopulate_store(\n    num_resources=g.n_cubicles,             # How many cubicles?\n    simpy_store=self.treatment_cubicles_store, # Which store to fill?\n    sim_env=self.env                        # The SimPy environment\n)\n\n# --- In your SimPy process function (e.g., attend_clinic) ---\n# def attend_clinic(self, patient):\n    # ... other code ...\n\n    # Request a SPECIFIC cubicle FROM THE STORE\n    # Note: We use .get() on the store, not .request()\n    print(f\"Patient {patient.identifier} waiting for cubicle...\")\n    specific_cubicle = yield self.treatment_cubicles_store.get()\n    print(f\"Patient {patient.identifier} got cubicle {specific_cubicle.id_attribute}\")\n\n    # --- Log the start of treatment ---\n    # Now we can log the SPECIFIC ID!\n    self.event_log.append({\n        'patient': patient.identifier,\n        'event': 'treatment_begins',\n        'event_type': 'resource_use',\n        'time': self.env.now,\n        'resource_id': specific_cubicle.id_attribute # &lt;-- Success!\n    })\n\n    # Simulate treatment time\n    # yield self.env.timeout(treatment_duration)\n\n    # --- Log the end of treatment ---\n    # Also log the specific ID here\n    self.event_log.append({\n        'patient': patient.identifier,\n        'event': 'treatment_complete',\n        'event_type': 'resource_use_end',\n        'time': self.env.now,\n        'resource_id': specific_cubicle.id_attribute # &lt;-- Consistent ID!\n    })\n\n    # IMPORTANT: Put the specific cubicle BACK INTO THE STORE\n    print(f\"Patient {patient.identifier} releasing cubicle {specific_cubicle.id_attribute}\")\n    yield self.treatment_cubicles_store.put(specific_cubicle)\n\n    # ... other code ...\nKey Changes:\n\nWe replaced simpy.Resource with simpy.Store.\nWe used populate_store to fill the store initially.\nWe replaced resource.request() with store.get(). This yields the actual CustomResource object (our specific cubicle).\nWe accessed specific_cubicle.id_attribute to get the unique ID for logging in the Event Log.\nCrucially, after finishing, we used store.put(specific_cubicle) to return that specific cubicle back to the store, making it available for others.\n\nNow, when vidigi processes the event log, it sees entries like resource_id: 1 or resource_id: 2. When combined with the Layout Configuration (event_position_df) which defines the base position for “treatment_begins” and knows there are 2 cubicles, vidigi can calculate the exact position for “Cubicle 1” and “Cubicle 2”. If Patient Alice consistently logs resource_id: 1, she will always be shown in the animation at the spot calculated for Cubicle 1!\n\n\n\nConceptually, this pattern allows us to track individual resources:\n\n\n\n\n\nsequenceDiagram\n    participant P as Patient\n    participant S as Cubicle Store\n    participant C1 as Cubicle 1 (ID=1)\n    participant C2 as Cubicle 2 (ID=2)\n    participant Log as Event Log\n\n    Note over S,C1,C2: Store initially contains C1 and C2\n\n    P-&gt;&gt;S: Request cubicle (.get())\n    S--&gt;&gt;P: Provide C1\n    P-&gt;&gt;Log: Record treatment_begins, ID=1\n\n    Note over P: Uses Cubicle 1 for some time...\n\n    P-&gt;&gt;Log: Record treatment_complete, ID=1\n    P-&gt;&gt;S: Return C1 (.put(C1))\n\n    Note over S,C1,C2: Store now contains C1 and C2 again\n\n\n\n\n\n\n\nThe populate_store function itself is quite simple. Looking inside vidigi/utils.py, it essentially does this:\n# Simplified view of populate_store\ndef populate_store(num_resources, simpy_store, sim_env):\n    \"\"\"Fills a store with uniquely ID'd CustomResource objects.\"\"\"\n    for i in range(num_resources):\n        # Create a CustomResource, giving it an ID (1, 2, 3...)\n        resource_with_id = CustomResource(\n            sim_env,\n            capacity=1,         # Usually, each item has capacity 1\n            id_attribute = i+1  # Assign ID: 1, 2, 3,...\n        )\n        # Put this specific resource into the store\n        simpy_store.put(resource_with_id)\nAnd the CustomResource class in vidigi/utils.py is just a standard simpy.Resource with an extra attribute added during initialization:\n# Simplified view of CustomResource\nimport simpy\n\nclass CustomResource(simpy.Resource):\n    \"\"\"A simpy.Resource with an added id_attribute.\"\"\"\n    def __init__(self, env, capacity, id_attribute=None):\n        # Call the original SimPy Resource setup\n        super().__init__(env, capacity)\n        # Add our custom ID badge!\n        self.id_attribute = id_attribute\n    # (Request and release methods are inherited, no changes needed here)\nBy combining these simple pieces (Store, CustomResource, populate_store), we achieve the goal: logging specific resource IDs so vidigi can create clear and consistent animations.\n\n\n\nWe’ve learned that standard SimPy resources lack unique IDs, which poses a challenge for visualizing which specific resource an entity is using over time. vidigi overcomes this by using a pattern involving simpy.Store as a container, vidigi.utils.CustomResource as resources with ID badges (id_attribute), and vidigi.utils.populate_store to easily set them up.\nBy modifying your SimPy model to use .get() on the store, logging the resource.id_attribute, and using .put() to return the resource, you provide vidigi with the crucial resource_id information needed in the Event Log. This allows vidigi to track entity-resource interactions precisely and render them consistently in the final animation.\nWith the event log prepared (Chapter 2), the layout defined (Chapter 3), and our resources properly identified (this Chapter), we now have all the raw ingredients. The next step is to prepare this data for the animation frames. How does vidigi figure out exactly where everyone is at every single moment in time?\nNext up: Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Modules",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#the-problem-simpy-resources-dont-have-names-ids",
    "href": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#the-problem-simpy-resources-dont-have-names-ids",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Imagine a small clinic with two identical treatment rooms (Room A and Room B). SimPy, a library often used to create the simulation data that vidigi visualizes, has a concept called simpy.Resource to represent things like these rooms.\nYou can tell SimPy “I have 2 treatment rooms”. When a patient needs a room, SimPy can tell you “Okay, a room is available”. But it doesn’t inherently tell you which room (A or B) the patient got.\nIf Patient Alice gets a room, and later Patient Bob gets a room, the simulation knows two rooms are busy. But the standard event log might just say:\n\nTime 5: Alice starts using a room.\nTime 8: Bob starts using a room.\n\nWhen vidigi reads this, it doesn’t know if Alice is in Room A and Bob in Room B, or vice-versa. In the animation, Alice might appear in the spot for Room A in one frame and Room B in the next, which looks confusing!\nWe need a way to give each individual resource (each room, each nurse, each machine) a unique ID, like giving each worker a specific ID badge.",
    "crumbs": [
      "Modules",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#the-solution-store-customresource-and-populate_store",
    "href": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#the-solution-store-customresource-and-populate_store",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "vidigi uses a clever workaround combined with helpers provided in its utils module:\n\nsimpy.Store: Instead of using simpy.Resource directly to represent the pool of treatment rooms, we use a simpy.Store. Think of a Store like a container or a shelf that can hold individual items. Our “shelf” will hold our individual, identifiable treatment rooms.\nvidigi.utils.CustomResource: We need items to put in the Store. We can’t just put standard simpy.Resource objects in there, because they still lack IDs. So, vidigi provides CustomResource. It’s almost identical to a simpy.Resource, but with one crucial addition: an id_attribute. This is our ID badge! Each CustomResource instance we create will represent one specific treatment room (like Room A or Room B) and will have its own unique ID.\nvidigi.utils.populate_store: Manually creating each CustomResource (each nurse, each room) and putting it into the Store can be repetitive. vidigi provides a helper function, populate_store, that does this for you. You tell it how many resources you need (e.g., 2 treatment rooms), which Store to put them in, and it automatically creates the right number of CustomResource objects, assigns them unique IDs (like 1, 2), and puts them into the Store.\n\nAnalogy:\n\nImagine you have 3 nurses (num_resources = 3).\nThe simpy.Store is the Nurses’ Station (simpy_store).\nCustomResource is a Nurse object that includes an ID badge (id_attribute).\npopulate_store is the supervisor who hires 3 nurses, gives them badges labelled “Nurse 1”, “Nurse 2”, “Nurse 3”, and tells them to wait at the Nurses’ Station (simpy_store).",
    "crumbs": [
      "Modules",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#how-to-use-this-pattern-in-your-simpy-model",
    "href": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#how-to-use-this-pattern-in-your-simpy-model",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Let’s see how you’d modify a typical SimPy model setup.\n1. Before (Using simpy.Resource):\n# --- In your Model's __init__ or resource setup ---\nimport simpy\n\n# Assume 'self.env' is your simpy.Environment\n# Assume 'g.n_cubicles' holds the number of cubicles (e.g., 2)\n# self.treatment_cubicles = simpy.Resource(self.env, capacity=g.n_cubicles)\n\n# --- In your SimPy process function (e.g., attend_clinic) ---\n# def attend_clinic(self, patient):\n    # ... other code ...\n\n    # Request *a* cubicle\n    # with self.treatment_cubicles.request() as req:\n    #     yield req\n        # --- Log the start of treatment ---\n        # (Problem: No specific cubicle ID here!)\n        # self.event_log.append({\n        #     'patient': patient.identifier,\n        #     'event': 'treatment_begins',\n        #     'event_type': 'resource_use',\n        #     'time': self.env.now,\n        #     'resource_id': None # &lt;--- We don't know which one!\n        # })\n\n        # yield self.env.timeout(treatment_duration)\n        # --- Log the end of treatment ---\n        # (Still no specific ID)\n\n    # ... other code ...\nThis code works for SimPy, but it doesn’t log the specific resource_id needed by vidigi.\n2. After (Using Store, CustomResource, populate_store):\n# --- Add imports at the top of your file ---\nimport simpy\nfrom vidigi.utils import CustomResource, populate_store # Import helpers\n\n# --- In your Model's __init__ or resource setup ---\n# Assume 'self.env' is your simpy.Environment\n# Assume 'g.n_cubicles' holds the number of cubicles (e.g., 2)\n\n# 1. Create an empty Store instead of a Resource\nself.treatment_cubicles_store = simpy.Store(self.env)\n\n# 2. Use populate_store to fill it with ID'd CustomResources\npopulate_store(\n    num_resources=g.n_cubicles,             # How many cubicles?\n    simpy_store=self.treatment_cubicles_store, # Which store to fill?\n    sim_env=self.env                        # The SimPy environment\n)\n\n# --- In your SimPy process function (e.g., attend_clinic) ---\n# def attend_clinic(self, patient):\n    # ... other code ...\n\n    # Request a SPECIFIC cubicle FROM THE STORE\n    # Note: We use .get() on the store, not .request()\n    print(f\"Patient {patient.identifier} waiting for cubicle...\")\n    specific_cubicle = yield self.treatment_cubicles_store.get()\n    print(f\"Patient {patient.identifier} got cubicle {specific_cubicle.id_attribute}\")\n\n    # --- Log the start of treatment ---\n    # Now we can log the SPECIFIC ID!\n    self.event_log.append({\n        'patient': patient.identifier,\n        'event': 'treatment_begins',\n        'event_type': 'resource_use',\n        'time': self.env.now,\n        'resource_id': specific_cubicle.id_attribute # &lt;-- Success!\n    })\n\n    # Simulate treatment time\n    # yield self.env.timeout(treatment_duration)\n\n    # --- Log the end of treatment ---\n    # Also log the specific ID here\n    self.event_log.append({\n        'patient': patient.identifier,\n        'event': 'treatment_complete',\n        'event_type': 'resource_use_end',\n        'time': self.env.now,\n        'resource_id': specific_cubicle.id_attribute # &lt;-- Consistent ID!\n    })\n\n    # IMPORTANT: Put the specific cubicle BACK INTO THE STORE\n    print(f\"Patient {patient.identifier} releasing cubicle {specific_cubicle.id_attribute}\")\n    yield self.treatment_cubicles_store.put(specific_cubicle)\n\n    # ... other code ...\nKey Changes:\n\nWe replaced simpy.Resource with simpy.Store.\nWe used populate_store to fill the store initially.\nWe replaced resource.request() with store.get(). This yields the actual CustomResource object (our specific cubicle).\nWe accessed specific_cubicle.id_attribute to get the unique ID for logging in the Event Log.\nCrucially, after finishing, we used store.put(specific_cubicle) to return that specific cubicle back to the store, making it available for others.\n\nNow, when vidigi processes the event log, it sees entries like resource_id: 1 or resource_id: 2. When combined with the Layout Configuration (event_position_df) which defines the base position for “treatment_begins” and knows there are 2 cubicles, vidigi can calculate the exact position for “Cubicle 1” and “Cubicle 2”. If Patient Alice consistently logs resource_id: 1, she will always be shown in the animation at the spot calculated for Cubicle 1!",
    "crumbs": [
      "Modules",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#whats-happening-under-the-hood",
    "href": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#whats-happening-under-the-hood",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "Conceptually, this pattern allows us to track individual resources:\n\n\n\n\n\nsequenceDiagram\n    participant P as Patient\n    participant S as Cubicle Store\n    participant C1 as Cubicle 1 (ID=1)\n    participant C2 as Cubicle 2 (ID=2)\n    participant Log as Event Log\n\n    Note over S,C1,C2: Store initially contains C1 and C2\n\n    P-&gt;&gt;S: Request cubicle (.get())\n    S--&gt;&gt;P: Provide C1\n    P-&gt;&gt;Log: Record treatment_begins, ID=1\n\n    Note over P: Uses Cubicle 1 for some time...\n\n    P-&gt;&gt;Log: Record treatment_complete, ID=1\n    P-&gt;&gt;S: Return C1 (.put(C1))\n\n    Note over S,C1,C2: Store now contains C1 and C2 again\n\n\n\n\n\n\n\nThe populate_store function itself is quite simple. Looking inside vidigi/utils.py, it essentially does this:\n# Simplified view of populate_store\ndef populate_store(num_resources, simpy_store, sim_env):\n    \"\"\"Fills a store with uniquely ID'd CustomResource objects.\"\"\"\n    for i in range(num_resources):\n        # Create a CustomResource, giving it an ID (1, 2, 3...)\n        resource_with_id = CustomResource(\n            sim_env,\n            capacity=1,         # Usually, each item has capacity 1\n            id_attribute = i+1  # Assign ID: 1, 2, 3,...\n        )\n        # Put this specific resource into the store\n        simpy_store.put(resource_with_id)\nAnd the CustomResource class in vidigi/utils.py is just a standard simpy.Resource with an extra attribute added during initialization:\n# Simplified view of CustomResource\nimport simpy\n\nclass CustomResource(simpy.Resource):\n    \"\"\"A simpy.Resource with an added id_attribute.\"\"\"\n    def __init__(self, env, capacity, id_attribute=None):\n        # Call the original SimPy Resource setup\n        super().__init__(env, capacity)\n        # Add our custom ID badge!\n        self.id_attribute = id_attribute\n    # (Request and release methods are inherited, no changes needed here)\nBy combining these simple pieces (Store, CustomResource, populate_store), we achieve the goal: logging specific resource IDs so vidigi can create clear and consistent animations.",
    "crumbs": [
      "Modules",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#conclusion",
    "href": "04_simpy_resource_enhancement_customresource_store_populate_store_.html#conclusion",
    "title": "Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store)",
    "section": "",
    "text": "We’ve learned that standard SimPy resources lack unique IDs, which poses a challenge for visualizing which specific resource an entity is using over time. vidigi overcomes this by using a pattern involving simpy.Store as a container, vidigi.utils.CustomResource as resources with ID badges (id_attribute), and vidigi.utils.populate_store to easily set them up.\nBy modifying your SimPy model to use .get() on the store, logging the resource.id_attribute, and using .put() to return the resource, you provide vidigi with the crucial resource_id information needed in the Event Log. This allows vidigi to track entity-resource interactions precisely and render them consistently in the final animation.\nWith the event log prepared (Chapter 2), the layout defined (Chapter 3), and our resources properly identified (this Chapter), we now have all the raw ingredients. The next step is to prepare this data for the animation frames. How does vidigi figure out exactly where everyone is at every single moment in time?\nNext up: Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Modules",
      "Chapter 4: Simpy Resource Enhancement (`CustomResource`, `Store`, `populate_store`)"
    ]
  },
  {
    "objectID": "06_animation_generation_generate_animation_.html",
    "href": "06_animation_generation_generate_animation_.html",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "Welcome to the final chapter in our vidigi tutorial! In Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df), we saw how vidigi transforms our raw Event Log and Layout Configuration (event_position_df) into a detailed, frame-by-frame dataset. This dataset tells us exactly where each entity (like a patient) should be on the screen, with its specific icon, at every single snapshot in time.\nThink of the output from Chapter 5 as a perfectly prepared film reel for a movie. Each frame on the reel shows the precise position of all actors. Now, we need the movie projector to actually display this film reel as a moving picture. That’s the job of the generate_animation function!\n\n\ngenerate_animation is the core rendering engine of vidigi. It takes the “animation-ready” DataFrame prepared in the previous step (the one with minute, patient, icon, x_final, y_final, etc.) and uses a powerful plotting library called Plotly Express to create the actual interactive animation.\nIts main job is to:\n\nDraw Each Frame: For each time snapshot (minute), it plots each entity’s icon at its calculated x_final and y_final position.\nCreate Motion: It tells Plotly how to smoothly transition the icons from their positions in one frame to their positions in the next frame. This is what makes the entities appear to move through the different stages (queues, resources).\nAdd Controls & Polish: It adds features like a timeline slider, play/pause buttons, tooltips (text that appears when you hover over an icon), stage labels, and optional background images.\n\nEssentially, generate_animation is the final artist that takes the detailed blueprint and brings it to life as an interactive animation.\n\n\n\nMost of the time, you won’t call generate_animation directly. Remember the “Easy Button” from Chapter 1: Animation Facade (animate_activity_log)? That main animate_activity_log function calls generate_animation internally as its final step.\nHowever, if you wanted very fine-grained control or were building the animation step-by-step yourself, you could call it directly. You would first need to run the preparation steps from Chapter 5 to get the required input DataFrame.\nLet’s imagine we have the final DataFrame from Chapter 5, called animation_ready_df:\n# --- Assume we have this from Chapter 5 ---\n# animation_ready_df looks like this (simplified):\n#    minute  patient icon  x_final  y_final             label  ...\n# 0       0        1  '🧔🏼'     50.0    200.0          Entrance  ...\n# 1       0        1  '🧔🏼'    200.0    250.0      Waiting Area  ...\n# 2       5        1  '🧔🏼'    190.0    150.0    Treatment Bays  ...\n# 3       5        2  '👨🏿‍🦯'    200.0    250.0      Waiting Area  ...\n# ...\n\n# --- Assume we also have these from previous chapters ---\n# my_layout = pd.DataFrame(...) # From Chapter 3\n# class SimpleScenario: n_cubicles = 2\n# scenario_details = SimpleScenario() # From Chapter 1/3\n\n# --- Import the function ---\nfrom vidigi.animation import generate_animation\nimport pandas as pd # We'll use pandas DataFrames\n\n# --- Call generate_animation directly ---\n# (Normally done inside animate_activity_log)\nfinal_animation = generate_animation(\n    full_patient_df_plus_pos=animation_ready_df, # The prepared data!\n    event_position_df=my_layout,             # Needed for stage labels, resources\n    scenario=scenario_details,               # Needed for drawing resource markers\n    plotly_height=600,                       # Set the height of the animation\n    icon_and_text_size=20,                   # Make icons smaller\n    time_display_units='dhm',                # Show time nicely\n    frame_duration=500,                      # Slow down playback slightly\n    add_background_image='floorplan.png'     # Optional: Add a background\n)\n\n# You can now display the animation (e.g., in a Jupyter Notebook)\n# final_animation.show()\nWhat happens when you run this?\nThe variable final_animation now holds a Plotly Figure object. If you displayed it (e.g., using final_animation.show() in a Jupyter notebook), you would see the complete, interactive animation:\n\nIcons (like ‘🧔🏼’ and ‘👨🏿‍🦯’) representing patients moving between locations defined in my_layout.\nSmooth transitions between the time steps recorded in animation_ready_df.\nA slider at the bottom showing the time (formatted as Days/Hours/Minutes).\nPlay/Pause buttons.\nStage labels (“Entrance”, “Waiting Area”, etc.) displayed on the chart.\nStatic markers showing the available treatment bays (based on scenario_details).\nOptionally, the ‘floorplan.png’ image in the background.\n\n\n\n\ngenerate_animation relies heavily on the plotly.express.scatter function. Here’s a simplified breakdown of how it works:\n\nCore Scatter Plot: It calls px.scatter, telling it:\n\nUse animation_ready_df as the data source.\nPlot points at x=\"x_final\" and y=\"y_final\".\nUse the icon column as the text marker for each point (text=\"icon\"). This is how the emojis appear.\nSet the animation_frame based on the time column (minute_display). This tells Plotly which rows belong to which frame of the animation.\nSet the animation_group based on the patient column. This tells Plotly that all rows with the same patient ID represent the same object moving across frames, allowing for smooth transitions.\nDefine hover text (hover_name, hover_data) so useful information appears when you mouse over an icon.\nSet the plot boundaries (range_x, range_y) and size (height, width).\n\nAdding Static Layers: After creating the basic animated scatter plot, generate_animation adds extra, non-moving layers:\n\nStage Labels: If display_stage_labels=True, it adds another go.Scatter trace (this time non-animated) to display the text labels from the event_position_df at their respective (x, y) coordinates.\nResource Markers: If a scenario object is provided, it calculates the positions for each individual resource slot (like each treatment bay) based on the event_position_df and the resource counts in scenario. It then adds another static go.Scatter trace to draw markers (like light blue circles or custom icons) at these positions.\nBackground Image: If add_background_image is specified, it uses fig.add_layout_image to place the image underneath the animation layers.\n\nStyling and Controls: Finally, it adjusts the appearance:\n\nSets the size of the icon/text markers (icon_and_text_size).\nHides axes and gridlines (unless setup_mode=True).\nConfigures the animation player (play button, slider speed using frame_duration and frame_transition_duration).\nReturns the complete Plotly Figure object.\n\n\nHere’s a simplified view of the process:\n\n\n\n\n\nsequenceDiagram\n    participant AAL as animate_activity_log (Optional Caller)\n    participant GA as generate_animation (The Projector)\n    participant Data as animation_ready_df (The Film Reel)\n    participant Layout as event_position_df (Stage Map)\n    participant Scenario as scenario object (Resource Info)\n    participant PX as Plotly Express\n    participant PlotlyFig as Plotly Figure (The Movie)\n\n    AAL-&gt;&gt;GA: Call with Data, Layout, Scenario, Options\n    GA-&gt;&gt;PX: px.scatter(data=Data, x='x_final', y='y_final', text='icon', animation_frame='minute_display', animation_group='patient', ...)\n    PX--&gt;&gt;GA: Return basic animated figure (fig)\n    GA-&gt;&gt;Layout: Get stage label positions\n    GA-&gt;&gt;PlotlyFig: fig.add_trace(go.Scatter(...)) # Add stage labels\n    alt Scenario provided\n        GA-&gt;&gt;Layout: Get resource base positions & names\n        GA-&gt;&gt;Scenario: Get resource counts\n        GA-&gt;&gt;PlotlyFig: fig.add_trace(go.Scatter(...)) # Add resource markers\n    end\n    opt Background image provided\n        GA-&gt;&gt;PlotlyFig: fig.add_layout_image(...) # Add background\n    end\n    GA-&gt;&gt;PlotlyFig: Update layout, styles, animation speed\n    GA--&gt;&gt;AAL: Return final Plotly Figure\n\n\n\n\n\n\nCode Dive (Simplified):\nLooking inside the vidigi/animation.py file, the heart of generate_animation is the plotly.express.scatter call:\n# Simplified from vidigi/animation.py\n\nimport plotly.express as px\nimport plotly.graph_objects as go\n# ... other imports\n\ndef generate_animation(full_patient_df_plus_pos, event_position_df, scenario=None, ...):\n    # ... (setup code for time display, plot boundaries) ...\n\n    # === Core Animation Creation ===\n    fig = px.scatter(\n            full_patient_df_plus_pos.sort_values('minute'), # Use the prepared data\n            x=\"x_final\",            # Horizontal position from data\n            y=\"y_final\",            # Vertical position from data\n            animation_frame=\"minute_display\", # Column defining animation time steps\n            animation_group=\"patient\",  # Column identifying entities across frames\n            text=\"icon\",            # Column with the emoji/text to display\n            hover_name=\"event\",     # Show event name on hover\n            hover_data=[\"patient\", \"time\", \"resource_id\"], # Show other details\n            # ... (ranges, height, width) ...\n            opacity=0 # Make the actual scatter points invisible (we only see the text)\n            )\n\n    # === Add Stage Labels (if requested) ===\n    if display_stage_labels:\n        fig.add_trace(go.Scatter(\n            x=event_position_df['x'] + 10, # Offset slightly\n            y=event_position_df['y'],\n            mode=\"text\", # Display text, not points\n            text=event_position_df['label'], # Get labels from layout\n            # ... (styling) ...\n            hoverinfo='none' # Don't show hover info for labels\n        ))\n\n    # === Add Resource Markers (if scenario provided) ===\n    if scenario is not None:\n        # ... (code to calculate positions for each resource instance) ...\n        # events_with_resources = calculate_resource_positions(...)\n\n        fig.add_trace(go.Scatter(\n            x=events_with_resources['x_final'], # Calculated X for each resource spot\n            y=events_with_resources['y_final'] - 10, # Place slightly below entity Y\n            mode=\"markers\", # Draw markers (e.g., circles)\n            marker=dict(color='LightSkyBlue', size=15),\n            opacity=resource_opacity,\n            hoverinfo='none'\n        ))\n        # (Or use 'mode=\"markers+text\"' if using custom_resource_icon)\n\n    # === Add Background Image (if requested) ===\n    if add_background_image is not None:\n        fig.add_layout_image(\n            # ... (configuration for image source, position, opacity) ...\n        )\n\n    # === Final Styling and Controls ===\n    fig.update_traces(textfont_size=icon_and_text_size) # Set icon size\n    fig.update_xaxes(showticklabels=False, showgrid=False) # Clean up axes\n    fig.update_yaxes(showticklabels=False, showgrid=False)\n    # ... (configure animation speed, play button etc.) ...\n\n    return fig\nThis simplified view shows how generate_animation layers the different visual elements (animated entities, static labels, static resource markers, background) using Plotly’s capabilities to produce the final interactive figure.\n\n\n\nYou’ve reached the end of the vidigi core concepts tutorial! We’ve seen how generate_animation acts as the final “movie projector”. It takes the meticulously prepared frame-by-frame data (the output of generate_animation_df from Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)) and uses Plotly Express to render the interactive animation. It plots entities, handles smooth transitions, adds labels, resource markers, and controls, bringing your process simulation to life visually.\nWhile often called behind the scenes by the main animate_activity_log function, understanding generate_animation shows you how the final visualization is constructed.\nYou now have a complete picture of the vidigi pipeline:\n\nStarting with an Event Log (the script) and a Layout Configuration (event_position_df) (the map).\nEnsuring resources are uniquely identified using the pattern from Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store).\nPreparing frame-by-frame snapshot data using the functions covered in Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df).\nFinally, rendering the animation with generate_animation (this chapter), often orchestrated by the main animate_activity_log facade.\n\nCongratulations! You’re now equipped with the knowledge to understand and use vidigi to create insightful animations of your own processes. Happy visualizing!\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Modules",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "06_animation_generation_generate_animation_.html#the-movie-projector-turning-data-into-visuals",
    "href": "06_animation_generation_generate_animation_.html#the-movie-projector-turning-data-into-visuals",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "generate_animation is the core rendering engine of vidigi. It takes the “animation-ready” DataFrame prepared in the previous step (the one with minute, patient, icon, x_final, y_final, etc.) and uses a powerful plotting library called Plotly Express to create the actual interactive animation.\nIts main job is to:\n\nDraw Each Frame: For each time snapshot (minute), it plots each entity’s icon at its calculated x_final and y_final position.\nCreate Motion: It tells Plotly how to smoothly transition the icons from their positions in one frame to their positions in the next frame. This is what makes the entities appear to move through the different stages (queues, resources).\nAdd Controls & Polish: It adds features like a timeline slider, play/pause buttons, tooltips (text that appears when you hover over an icon), stage labels, and optional background images.\n\nEssentially, generate_animation is the final artist that takes the detailed blueprint and brings it to life as an interactive animation.",
    "crumbs": [
      "Modules",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "06_animation_generation_generate_animation_.html#how-to-use-generate_animation-usually-indirectly",
    "href": "06_animation_generation_generate_animation_.html#how-to-use-generate_animation-usually-indirectly",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "Most of the time, you won’t call generate_animation directly. Remember the “Easy Button” from Chapter 1: Animation Facade (animate_activity_log)? That main animate_activity_log function calls generate_animation internally as its final step.\nHowever, if you wanted very fine-grained control or were building the animation step-by-step yourself, you could call it directly. You would first need to run the preparation steps from Chapter 5 to get the required input DataFrame.\nLet’s imagine we have the final DataFrame from Chapter 5, called animation_ready_df:\n# --- Assume we have this from Chapter 5 ---\n# animation_ready_df looks like this (simplified):\n#    minute  patient icon  x_final  y_final             label  ...\n# 0       0        1  '🧔🏼'     50.0    200.0          Entrance  ...\n# 1       0        1  '🧔🏼'    200.0    250.0      Waiting Area  ...\n# 2       5        1  '🧔🏼'    190.0    150.0    Treatment Bays  ...\n# 3       5        2  '👨🏿‍🦯'    200.0    250.0      Waiting Area  ...\n# ...\n\n# --- Assume we also have these from previous chapters ---\n# my_layout = pd.DataFrame(...) # From Chapter 3\n# class SimpleScenario: n_cubicles = 2\n# scenario_details = SimpleScenario() # From Chapter 1/3\n\n# --- Import the function ---\nfrom vidigi.animation import generate_animation\nimport pandas as pd # We'll use pandas DataFrames\n\n# --- Call generate_animation directly ---\n# (Normally done inside animate_activity_log)\nfinal_animation = generate_animation(\n    full_patient_df_plus_pos=animation_ready_df, # The prepared data!\n    event_position_df=my_layout,             # Needed for stage labels, resources\n    scenario=scenario_details,               # Needed for drawing resource markers\n    plotly_height=600,                       # Set the height of the animation\n    icon_and_text_size=20,                   # Make icons smaller\n    time_display_units='dhm',                # Show time nicely\n    frame_duration=500,                      # Slow down playback slightly\n    add_background_image='floorplan.png'     # Optional: Add a background\n)\n\n# You can now display the animation (e.g., in a Jupyter Notebook)\n# final_animation.show()\nWhat happens when you run this?\nThe variable final_animation now holds a Plotly Figure object. If you displayed it (e.g., using final_animation.show() in a Jupyter notebook), you would see the complete, interactive animation:\n\nIcons (like ‘🧔🏼’ and ‘👨🏿‍🦯’) representing patients moving between locations defined in my_layout.\nSmooth transitions between the time steps recorded in animation_ready_df.\nA slider at the bottom showing the time (formatted as Days/Hours/Minutes).\nPlay/Pause buttons.\nStage labels (“Entrance”, “Waiting Area”, etc.) displayed on the chart.\nStatic markers showing the available treatment bays (based on scenario_details).\nOptionally, the ‘floorplan.png’ image in the background.",
    "crumbs": [
      "Modules",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "06_animation_generation_generate_animation_.html#whats-happening-under-the-hood",
    "href": "06_animation_generation_generate_animation_.html#whats-happening-under-the-hood",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "generate_animation relies heavily on the plotly.express.scatter function. Here’s a simplified breakdown of how it works:\n\nCore Scatter Plot: It calls px.scatter, telling it:\n\nUse animation_ready_df as the data source.\nPlot points at x=\"x_final\" and y=\"y_final\".\nUse the icon column as the text marker for each point (text=\"icon\"). This is how the emojis appear.\nSet the animation_frame based on the time column (minute_display). This tells Plotly which rows belong to which frame of the animation.\nSet the animation_group based on the patient column. This tells Plotly that all rows with the same patient ID represent the same object moving across frames, allowing for smooth transitions.\nDefine hover text (hover_name, hover_data) so useful information appears when you mouse over an icon.\nSet the plot boundaries (range_x, range_y) and size (height, width).\n\nAdding Static Layers: After creating the basic animated scatter plot, generate_animation adds extra, non-moving layers:\n\nStage Labels: If display_stage_labels=True, it adds another go.Scatter trace (this time non-animated) to display the text labels from the event_position_df at their respective (x, y) coordinates.\nResource Markers: If a scenario object is provided, it calculates the positions for each individual resource slot (like each treatment bay) based on the event_position_df and the resource counts in scenario. It then adds another static go.Scatter trace to draw markers (like light blue circles or custom icons) at these positions.\nBackground Image: If add_background_image is specified, it uses fig.add_layout_image to place the image underneath the animation layers.\n\nStyling and Controls: Finally, it adjusts the appearance:\n\nSets the size of the icon/text markers (icon_and_text_size).\nHides axes and gridlines (unless setup_mode=True).\nConfigures the animation player (play button, slider speed using frame_duration and frame_transition_duration).\nReturns the complete Plotly Figure object.\n\n\nHere’s a simplified view of the process:\n\n\n\n\n\nsequenceDiagram\n    participant AAL as animate_activity_log (Optional Caller)\n    participant GA as generate_animation (The Projector)\n    participant Data as animation_ready_df (The Film Reel)\n    participant Layout as event_position_df (Stage Map)\n    participant Scenario as scenario object (Resource Info)\n    participant PX as Plotly Express\n    participant PlotlyFig as Plotly Figure (The Movie)\n\n    AAL-&gt;&gt;GA: Call with Data, Layout, Scenario, Options\n    GA-&gt;&gt;PX: px.scatter(data=Data, x='x_final', y='y_final', text='icon', animation_frame='minute_display', animation_group='patient', ...)\n    PX--&gt;&gt;GA: Return basic animated figure (fig)\n    GA-&gt;&gt;Layout: Get stage label positions\n    GA-&gt;&gt;PlotlyFig: fig.add_trace(go.Scatter(...)) # Add stage labels\n    alt Scenario provided\n        GA-&gt;&gt;Layout: Get resource base positions & names\n        GA-&gt;&gt;Scenario: Get resource counts\n        GA-&gt;&gt;PlotlyFig: fig.add_trace(go.Scatter(...)) # Add resource markers\n    end\n    opt Background image provided\n        GA-&gt;&gt;PlotlyFig: fig.add_layout_image(...) # Add background\n    end\n    GA-&gt;&gt;PlotlyFig: Update layout, styles, animation speed\n    GA--&gt;&gt;AAL: Return final Plotly Figure\n\n\n\n\n\n\nCode Dive (Simplified):\nLooking inside the vidigi/animation.py file, the heart of generate_animation is the plotly.express.scatter call:\n# Simplified from vidigi/animation.py\n\nimport plotly.express as px\nimport plotly.graph_objects as go\n# ... other imports\n\ndef generate_animation(full_patient_df_plus_pos, event_position_df, scenario=None, ...):\n    # ... (setup code for time display, plot boundaries) ...\n\n    # === Core Animation Creation ===\n    fig = px.scatter(\n            full_patient_df_plus_pos.sort_values('minute'), # Use the prepared data\n            x=\"x_final\",            # Horizontal position from data\n            y=\"y_final\",            # Vertical position from data\n            animation_frame=\"minute_display\", # Column defining animation time steps\n            animation_group=\"patient\",  # Column identifying entities across frames\n            text=\"icon\",            # Column with the emoji/text to display\n            hover_name=\"event\",     # Show event name on hover\n            hover_data=[\"patient\", \"time\", \"resource_id\"], # Show other details\n            # ... (ranges, height, width) ...\n            opacity=0 # Make the actual scatter points invisible (we only see the text)\n            )\n\n    # === Add Stage Labels (if requested) ===\n    if display_stage_labels:\n        fig.add_trace(go.Scatter(\n            x=event_position_df['x'] + 10, # Offset slightly\n            y=event_position_df['y'],\n            mode=\"text\", # Display text, not points\n            text=event_position_df['label'], # Get labels from layout\n            # ... (styling) ...\n            hoverinfo='none' # Don't show hover info for labels\n        ))\n\n    # === Add Resource Markers (if scenario provided) ===\n    if scenario is not None:\n        # ... (code to calculate positions for each resource instance) ...\n        # events_with_resources = calculate_resource_positions(...)\n\n        fig.add_trace(go.Scatter(\n            x=events_with_resources['x_final'], # Calculated X for each resource spot\n            y=events_with_resources['y_final'] - 10, # Place slightly below entity Y\n            mode=\"markers\", # Draw markers (e.g., circles)\n            marker=dict(color='LightSkyBlue', size=15),\n            opacity=resource_opacity,\n            hoverinfo='none'\n        ))\n        # (Or use 'mode=\"markers+text\"' if using custom_resource_icon)\n\n    # === Add Background Image (if requested) ===\n    if add_background_image is not None:\n        fig.add_layout_image(\n            # ... (configuration for image source, position, opacity) ...\n        )\n\n    # === Final Styling and Controls ===\n    fig.update_traces(textfont_size=icon_and_text_size) # Set icon size\n    fig.update_xaxes(showticklabels=False, showgrid=False) # Clean up axes\n    fig.update_yaxes(showticklabels=False, showgrid=False)\n    # ... (configure animation speed, play button etc.) ...\n\n    return fig\nThis simplified view shows how generate_animation layers the different visual elements (animated entities, static labels, static resource markers, background) using Plotly’s capabilities to produce the final interactive figure.",
    "crumbs": [
      "Modules",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  },
  {
    "objectID": "06_animation_generation_generate_animation_.html#conclusion",
    "href": "06_animation_generation_generate_animation_.html#conclusion",
    "title": "Chapter 6: Animation Generation (generate_animation)",
    "section": "",
    "text": "You’ve reached the end of the vidigi core concepts tutorial! We’ve seen how generate_animation acts as the final “movie projector”. It takes the meticulously prepared frame-by-frame data (the output of generate_animation_df from Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df)) and uses Plotly Express to render the interactive animation. It plots entities, handles smooth transitions, adds labels, resource markers, and controls, bringing your process simulation to life visually.\nWhile often called behind the scenes by the main animate_activity_log function, understanding generate_animation shows you how the final visualization is constructed.\nYou now have a complete picture of the vidigi pipeline:\n\nStarting with an Event Log (the script) and a Layout Configuration (event_position_df) (the map).\nEnsuring resources are uniquely identified using the pattern from Chapter 4: Simpy Resource Enhancement (CustomResource, Store, populate_store).\nPreparing frame-by-frame snapshot data using the functions covered in Chapter 5: Snapshot Preparation (reshape_for_animations & generate_animation_df).\nFinally, rendering the animation with generate_animation (this chapter), often orchestrated by the main animate_activity_log facade.\n\nCongratulations! You’re now equipped with the knowledge to understand and use vidigi to create insightful animations of your own processes. Happy visualizing!\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Modules",
      "Chapter 6: Animation Generation (`generate_animation`)"
    ]
  }
]