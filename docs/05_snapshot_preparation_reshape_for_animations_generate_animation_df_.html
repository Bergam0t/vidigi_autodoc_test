<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>snapshot_preparation_reshape_for_animations_generate_animation_df_ – Vidigi - Auto Documentation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ddd961a2510921635943dfbbd19534c4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Vidigi - Auto Documentation</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-modules" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Modules</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-modules">    
        <li>
    <a class="dropdown-item" href="./01_animation_facade_animate_activity_log_.html">
 <span class="dropdown-text">Animation Facade (animate_activity_log)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./02_event_log_.html">
 <span class="dropdown-text">Event Log</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./03_layout_configuration_event_position_df_.html">
 <span class="dropdown-text">Layout Configuration (event_position_df)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./04_simpy_resource_enhancement_customresource_store_populate_store_.html">
 <span class="dropdown-text">SimPy Resource Enhancement (CustomResource, Store, populate_store)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html">
 <span class="dropdown-text">Snapshot Preparation (reshape_for_animations / generate_animation_df)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./06_animation_generation_generate_animation_.html">
 <span class="dropdown-text">Animation Generation (generate_animation)</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#chapter-5-snapshot-preparation-reshape_for_animations-generate_animation_df" id="toc-chapter-5-snapshot-preparation-reshape_for_animations-generate_animation_df" class="nav-link active" data-scroll-target="#chapter-5-snapshot-preparation-reshape_for_animations-generate_animation_df">Chapter 5: Snapshot Preparation (<code>reshape_for_animations</code> &amp; <code>generate_animation_df</code>)</a>
  <ul class="collapse">
  <li><a href="#from-diary-to-flipbook-the-need-for-snapshots" id="toc-from-diary-to-flipbook-the-need-for-snapshots" class="nav-link" data-scroll-target="#from-diary-to-flipbook-the-need-for-snapshots">From Diary to Flipbook: The Need for Snapshots</a></li>
  <li><a href="#step-1-creating-time-slices-reshape_for_animations" id="toc-step-1-creating-time-slices-reshape_for_animations" class="nav-link" data-scroll-target="#step-1-creating-time-slices-reshape_for_animations">Step 1: Creating Time Slices (<code>reshape_for_animations</code>)</a></li>
  <li><a href="#step-2-calculating-positions-generate_animation_df" id="toc-step-2-calculating-positions-generate_animation_df" class="nav-link" data-scroll-target="#step-2-calculating-positions-generate_animation_df">Step 2: Calculating Positions (<code>generate_animation_df</code>)</a></li>
  <li><a href="#how-they-work-together" id="toc-how-they-work-together" class="nav-link" data-scroll-target="#how-they-work-together">How They Work Together</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="chapter-5-snapshot-preparation-reshape_for_animations-generate_animation_df" class="level1">
<h1>Chapter 5: Snapshot Preparation (<code>reshape_for_animations</code> &amp; <code>generate_animation_df</code>)</h1>
<p>In <a href="04_simpy_resource_enhancement___customresource____store____populate_store___.qmd">Chapter 4: Simpy Resource Enhancement (<code>CustomResource</code>, <code>Store</code>, <code>populate_store</code>)</a>, we learned how to make sure our simulation records <em>which specific</em> resource (like Cubicle 1 vs.&nbsp;Cubicle 2) each patient is using. This gives us a detailed <a href="./02_event_log_.html">Event Log</a>, the script of our process. We also have our stage map, the <a href="./03_layout_configuration_event_position_df_.html">Layout Configuration (<code>event_position_df</code>)</a>.</p>
<p>But how do we turn this script and map into an actual movie? A movie isn’t just a list of events; it’s a series of frames, or snapshots, showing where everyone is at specific moments in time. This chapter explores how <code>vidigi</code> prepares these snapshots.</p>
<section id="from-diary-to-flipbook-the-need-for-snapshots" class="level2">
<h2 class="anchored" data-anchor-id="from-diary-to-flipbook-the-need-for-snapshots">From Diary to Flipbook: The Need for Snapshots</h2>
<p>Think about the <a href="./02_event_log_.html">Event Log</a>. It’s like a detailed diary: * 9:00 AM: Alice arrived. * 9:01 AM: Alice started waiting. * 9:15 AM: Alice started treatment (Cubicle 1). * 9:30 AM: Alice finished treatment. * 9:31 AM: Alice departed.</p>
<p>This tells us <em>when things change</em>. But an animation needs to show the state of the system at regular intervals, say, every 5 minutes. What was happening at 9:05 AM? What about 9:10 AM?</p>
<p>We need to transform our event-based diary into a “flipbook” where each page shows the location and status of <em>everyone</em> at a specific time (e.g., 9:00, 9:05, 9:10, 9:15…). This process involves two main steps, handled by two helper functions within <code>vidigi</code>:</p>
<ol type="1">
<li><strong><code>reshape_for_animations</code></strong>: Figures out <em>who</em> is doing <em>what</em> at each snapshot time. (Like sketching the characters and their basic activity on each flipbook page).</li>
<li><strong><code>generate_animation_df</code></strong>: Calculates the <em>exact (X, Y) screen coordinates</em> for each character on each page, arranging them neatly in queues or placing them at specific resource spots. (Like precisely positioning the sketches on the page according to layout rules).</li>
</ol>
<p>These functions usually work behind the scenes when you call the main <a href="./01_animation_facade_animate_activity_log_.html"><code>animate_activity_log</code></a> function (the “Easy Button” from Chapter 1). You typically don’t need to call them yourself, but understanding them helps you see how the animation is built.</p>
</section>
<section id="step-1-creating-time-slices-reshape_for_animations" class="level2">
<h2 class="anchored" data-anchor-id="step-1-creating-time-slices-reshape_for_animations">Step 1: Creating Time Slices (<code>reshape_for_animations</code>)</h2>
<p><strong>Goal:</strong> To determine the status (event, event type, resource used) of every entity at regular time intervals.</p>
<p>Imagine you have your event log diary. <code>reshape_for_animations</code> acts like someone reading the diary and creating a summary for specific times. You tell it how often to take a snapshot using the <code>every_x_time_units</code> parameter (e.g., <code>every_x_time_units=5</code> means take a snapshot every 5 minutes).</p>
<p><strong>How it works (conceptually):</strong></p>
<ol type="1">
<li><strong>Look at a Snapshot Time:</strong> It starts at time 0, then time 5, then time 10, and so on, up to a specified limit (<code>limit_duration</code>).</li>
<li><strong>Find Active Patients:</strong> For each snapshot time (say, minute 10), it looks at the <a href="./02_event_log_.html">Event Log</a> to find all patients who have <code>arrival</code> time &lt;= 10 AND (<code>depart</code> time &gt;= 10 OR <code>depart</code> time is missing). These are the patients currently “in the system”.</li>
<li><strong>Find Latest Status:</strong> For each of these active patients, it finds the <em>most recent event</em> that happened at or before the current snapshot time (minute 10). For example, if Alice arrived at 0 and started waiting at 1, her status at minute 10 is still ‘start_wait’. If Bob arrived at 2 and started treatment (Resource 2) at 8, his status at minute 10 is ‘start_treat’ using Resource 2.</li>
<li><strong>Rank Entities:</strong> If multiple patients are in the same state (e.g., multiple people waiting), it ranks them based on when they entered that state. This “rank” is important for positioning them later (e.g., first in line, second in line).</li>
<li><strong>Record Snapshot:</strong> It records this information (patient ID, event, event type, resource ID if applicable, rank) for the current snapshot time.</li>
<li><strong>Repeat:</strong> It does this for every snapshot time interval.</li>
<li><strong>Add Exit:</strong> It adds a final ‘exit’ event for each patient slightly after their last recorded event to make them disappear cleanly from the animation.</li>
</ol>
<p><strong>Input:</strong> A simplified <a href="./02_event_log_.html">Event Log</a> DataFrame:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># event_log (from Chapter 2)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">#    patient       event_type        event  time  resource_id</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 0        1  arrival_departure      arrival     0          NaN</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 1        1              queue   start_wait     0          NaN</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 2        1       resource_use  start_treat     5          1.0  # Used resource 1</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 3        1  arrival_departure       depart    15          NaN</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 4        2  arrival_departure      arrival     2          NaN</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 5        2              queue   start_wait     2          NaN</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 6        2       resource_use  start_treat     8          2.0  # Used resource 2</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 7        2  arrival_departure       depart    20          NaN</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Output:</strong> A “reshaped” DataFrame (let’s assume <code>every_x_time_units=5</code>):</p>
<pre><code># Output of reshape_for_animations (simplified)
#    minute  patient       event_type        event  resource_id  rank
# 0       0        1  arrival_departure      arrival          NaN   1.0 # At minute 0, Patient 1 arrived
# 1       0        1              queue   start_wait          NaN   1.0 # Immediately started waiting
# 2       5        1       resource_use  start_treat          1.0   1.0 # At minute 5, Patient 1 started treatment (Resource 1)
# 3       5        2              queue   start_wait          NaN   1.0 # At minute 5, Patient 2 was waiting (arrived at 2)
# 4      10        1       resource_use  start_treat          1.0   1.0 # At minute 10, Patient 1 still treating
# 5      10        2       resource_use  start_treat          2.0   1.0 # At minute 10, Patient 2 started treatment (Resource 2)
# 6      15        1  arrival_departure       depart          NaN   1.0 # At minute 15, Patient 1 departed
# 7      15        2       resource_use  start_treat          2.0   1.0 # At minute 15, Patient 2 still treating
# 8      20        2  arrival_departure       depart          NaN   1.0 # At minute 20, Patient 2 departed
# ... (plus added 'exit' events shortly after depart)</code></pre>
<p>Notice how this table tells us the state of <em>both</em> patients at each 5-minute interval (<code>minute</code> column). The <code>rank</code> column tells us their order within that state at that time (here, they are mostly alone in their state, so rank is 1.0).</p>
<p><strong>(Code Reference:</strong> The actual logic lives in the <code>reshape_for_animations</code> function within the <code>vidigi/prep.py</code> file.)</p>
</section>
<section id="step-2-calculating-positions-generate_animation_df" class="level2">
<h2 class="anchored" data-anchor-id="step-2-calculating-positions-generate_animation_df">Step 2: Calculating Positions (<code>generate_animation_df</code>)</h2>
<p><strong>Goal:</strong> To calculate the precise (X, Y) screen coordinates for every entity in every snapshot, based on their status and the layout rules.</p>
<p>Now we have our flipbook pages sketched (<code>reshape_for_animations</code> output), but the characters are just listed, not positioned. <code>generate_animation_df</code> takes these sketches and the <a href="./03_layout_configuration_event_position_df_.html">Layout Configuration (<code>event_position_df</code>)</a> (our stage map) and figures out exactly where to draw everyone.</p>
<p><strong>How it works (conceptually):</strong></p>
<ol type="1">
<li><strong>Take a Snapshot Row:</strong> It looks at each row from the <code>reshape_for_animations</code> output (e.g., “At minute 5, Patient 2 was <code>start_wait</code>, rank 1.0”).</li>
<li><strong>Find Base Position:</strong> It looks up the <code>event</code> (‘start_wait’) in the <a href="./03_layout_configuration_event_position_df_.html">Layout Configuration (<code>event_position_df</code>)</a> to get the base anchor coordinates (e.g., X=200, Y=250 from Chapter 3’s example).</li>
<li><strong>Apply Layout Rules:</strong>
<ul>
<li><strong>If it’s a Queue (<code>event_type</code> == ‘queue’):</strong> It uses the patient’s <code>rank</code> (1.0 in this case) and parameters like <code>wrap_queues_at</code> and <code>gap_between_entities</code> to calculate an offset from the base (X, Y). Rank 1 might be right at the base (X=200), Rank 2 might be slightly to the left (X = 200 - <code>gap_between_entities</code>), and so on, potentially wrapping to a new row above.</li>
<li><strong>If it’s Resource Use (<code>event_type</code> == ‘resource_use’):</strong> It uses the patient’s specific <code>resource_id</code> (e.g., Resource 1 or Resource 2 from the <code>reshape_for_animations</code> output) and parameters like <code>wrap_resources_at</code> and <code>gap_between_resources</code> to calculate the position relative to the base (X, Y) defined for that resource event in the layout. Resource 1 might be at (X - <code>gap_between_resources</code> * 1), Resource 2 at (X - <code>gap_between_resources</code> * 2), etc., potentially wrapping.</li>
<li><strong>If it’s Arrival/Departure:</strong> It typically just uses the base (X, Y) directly.</li>
</ul></li>
<li><strong>Assign Icon:</strong> It picks an icon (like an emoji 👩🏽‍⚕️, 👨‍💻, 🏭) for the patient, making sure each unique patient gets the same icon throughout the animation.</li>
<li><strong>Record Final Position:</strong> It stores the calculated <code>x_final</code>, <code>y_final</code>, and <code>icon</code> along with the original snapshot information.</li>
</ol>
<p><strong>Input:</strong> * The reshaped DataFrame from <code>reshape_for_animations</code>. * The <a href="./03_layout_configuration_event_position_df_.html">Layout Configuration (<code>event_position_df</code>)</a>.</p>
<p><strong>Output:</strong> The final “animation-ready” DataFrame. This contains everything needed to draw each frame: the time (<code>minute</code>), who (<code>patient</code>), their icon (<code>icon</code>), their exact position (<code>x_final</code>, <code>y_final</code>), and hover text (<code>label</code>).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Output of generate_animation_df (simplified, adding X/Y and icons)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">#    minute  patient       event_type        event  resource_id  rank  x_final  y_final      icon                       label</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 0       0        1  arrival_departure      arrival          NaN   1.0     50.0    200.0       '🧔🏼'                  'Entrance' # At base X/Y for arrival</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 1       0        1              queue   start_wait          NaN   1.0    200.0    250.0       '🧔🏼'              'Waiting Area' # At base X/Y for queue (rank 1)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 2       5        1       resource_use  start_treat          1.0   1.0    190.0    150.0       '🧔🏼'            'Treatment Bays' # Offset for resource 1 (base X=200, Y=150)</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 3       5        2              queue   start_wait          NaN   1.0    200.0    250.0       '👨🏿‍🦯'              'Waiting Area' # At base X/Y for queue (rank 1)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 4      10        1       resource_use  start_treat          1.0   1.0    190.0    150.0       '🧔🏼'            'Treatment Bays' # Still at resource 1 spot</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 5      10        2       resource_use  start_treat          2.0   1.0    180.0    150.0       '👨🏿‍🦯'            'Treatment Bays' # Offset for resource 2</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 6      15        1  arrival_departure       depart          NaN   1.0    350.0    150.0       '🧔🏼'                 'Discharge' # At base X/Y for depart</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 7      15        2       resource_use  start_treat          2.0   1.0    180.0    150.0       '👨🏿‍🦯'            'Treatment Bays' # Still at resource 2 spot</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 8      20        2  arrival_departure       depart          NaN   1.0    350.0    150.0       '👨🏿‍🦯'                 'Discharge' # At base X/Y for depart</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co"># ... (plus 'exit' events)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This final table is the direct input for the animation engine itself.</p>
<p><strong>(Code Reference:</strong> The actual logic lives in the <code>generate_animation_df</code> function within the <code>vidigi/prep.py</code> file.)</p>
</section>
<section id="how-they-work-together" class="level2">
<h2 class="anchored" data-anchor-id="how-they-work-together">How They Work Together</h2>
<p>The main <a href="./01_animation_facade_animate_activity_log_.html"><code>animate_activity_log</code></a> function orchestrates these two steps before creating the final animation:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">sequenceDiagram
    participant User
    participant AAL as animate_activity_log
    participant RFA as reshape_for_animations
    participant GAD as generate_animation_df
    participant GA as generate_animation (Chapter 6)

    User-&gt;&gt;AAL: Call with event_log, layout, options
    AAL-&gt;&gt;RFA: Pass event_log, time interval (every_x_time_units)
    RFA--&gt;&gt;AAL: Return reshaped_df (time slices)
    AAL-&gt;&gt;GAD: Pass reshaped_df, layout, queue/resource rules
    GAD--&gt;&gt;AAL: Return animation_df (with X, Y, icons)
    AAL-&gt;&gt;GA: Pass animation_df, display options
    GA--&gt;&gt;AAL: Return Plotly Figure
    AAL--&gt;&gt;User: Return Plotly Figure
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>First, <code>reshape_for_animations</code> processes the raw log into time slices. Then, <code>generate_animation_df</code> takes those slices and calculates the precise visual positions using the layout map.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Snapshot preparation is the crucial data transformation stage in <code>vidigi</code>. It bridges the gap between the raw, event-based simulation log and the frame-by-frame data needed for animation.</p>
<ul>
<li><strong><code>reshape_for_animations</code></strong> acts like a scribe, turning the event diary into a flipbook summary by figuring out who is doing what at regular time intervals.</li>
<li><strong><code>generate_animation_df</code></strong> acts like an artist, taking the flipbook summary and the stage map (<code>event_position_df</code>) to calculate the exact (X, Y) coordinates for every character on every page, respecting queueing and resource layout rules.</li>
</ul>
<p>Together, they produce a detailed DataFrame where each row represents an entity at a specific time with a specific icon and screen position. This prepared data is now ready to be fed into the final animation engine.</p>
<p>How does <code>vidigi</code> take this final DataFrame and actually draw the moving pictures using Plotly? That’s what we’ll explore in the next chapter!</p>
<p>Next up: <a href="./06_animation_generation_generate_animation_.html">Chapter 6: Animation Generation (<code>generate_animation</code>)</a></p>
<hr>
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>