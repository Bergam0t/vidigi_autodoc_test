<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.29">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>snapshot_preparation_reshape_for_animations_generate_animation_df_ – Vidigi - Auto Documentation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-0815c480559380816a4d1ea211a47e91.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5d2e30ad26079c1dae90a1fd11eba2b9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../autodoc_v2/index.html">Version 2 - Intermediate Programmer</a></li><li class="breadcrumb-item"><a href="../autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html">Chapter 5: Snapshot Preparation (`reshape_for_animations` &amp; `generate_animation_df`)</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Vidigi - Auto Documentation</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Version 1 - Beginner-Friendly</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tutorial: vidigi</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../01_animation_facade_animate_activity_log_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 1: Animation Facade (<code>animate_activity_log</code>)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../02_event_log_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 2: Event Log</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../03_layout_configuration_event_position_df_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 3: Layout Configuration (<code>event_position_df</code>)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../04_simpy_resource_enhancement_customresource_store_populate_store_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 4: Simpy Resource Enhancement (<code>CustomResource</code>, <code>Store</code>, <code>populate_store</code>)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 5: Snapshot Preparation (`reshape_for_animations` &amp; `generate_animation_df`)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../06_animation_generation_generate_animation_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 6: Animation Generation (<code>generate_animation</code>)</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Version 2 - Intermediate Programmer</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v2/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tutorial: vidigi</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v2/01_animation_facade_animate_activity_log_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 1: Animation Facade (<code>animate_activity_log</code>)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v2/02_event_log_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 2: Event Log</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v2/03_layout_configuration_event_position_df_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 3: Layout Configuration (<code>event_position_df</code>)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 4: Simpy Resource Enhancement (<code>CustomResource</code>, <code>Store</code>, <code>populate_store</code>)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Chapter 5: Snapshot Preparation (`reshape_for_animations` &amp; `generate_animation_df`)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v2/06_animation_generation_generate_animation_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 6: Animation Generation (<code>generate_animation</code>)</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Beginner Friendly + 1980s References</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v3/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tutorial: vidigi</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v3/01_animation_facade_animate_activity_log_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 1: Great Scott! Making Animations Easy with <code>animate_activity_log</code></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v3/02_event_log_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 2: Log Everything! Like K.I.T.T.’s Mission Recorder</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v3/03_layout_configuration_event_position_df_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 3: Where Am I? Mapping the Grid with <code>event_position_df</code></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v3/04_simpy_resource_enhancement_customresource_store_populate_store_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 4: More Input! Giving Your Resources an Upgrade (<code>CustomResource</code>, <code>Store</code>, <code>populate_store</code>)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v3/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 5: Prepare for Snapshots, McFly! (`reshape_for_animations` &amp; `generate_animation_df`)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../autodoc_v3/06_animation_generation_generate_animation_.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 6: Action! Making the Movie with <code>generate_animation</code></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#chapter-5-snapshot-preparation-reshape_for_animations-generate_animation_df" id="toc-chapter-5-snapshot-preparation-reshape_for_animations-generate_animation_df" class="nav-link active" data-scroll-target="#chapter-5-snapshot-preparation-reshape_for_animations-generate_animation_df">Chapter 5: Snapshot Preparation (<code>reshape_for_animations</code> &amp; <code>generate_animation_df</code>)</a>
  <ul class="collapse">
  <li><a href="#motivation-from-diary-to-film-reel" id="toc-motivation-from-diary-to-film-reel" class="nav-link" data-scroll-target="#motivation-from-diary-to-film-reel">Motivation: From Diary to Film Reel</a></li>
  <li><a href="#key-concepts-slicing-time-and-placing-pieces" id="toc-key-concepts-slicing-time-and-placing-pieces" class="nav-link" data-scroll-target="#key-concepts-slicing-time-and-placing-pieces">Key Concepts: Slicing Time and Placing Pieces</a></li>
  <li><a href="#time-slicing-with-reshape_for_animations" id="toc-time-slicing-with-reshape_for_animations" class="nav-link" data-scroll-target="#time-slicing-with-reshape_for_animations">Time Slicing with <code>reshape_for_animations</code></a></li>
  <li><a href="#calculating-positions-with-generate_animation_df" id="toc-calculating-positions-with-generate_animation_df" class="nav-link" data-scroll-target="#calculating-positions-with-generate_animation_df">Calculating Positions with <code>generate_animation_df</code></a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../autodoc_v2/index.html">Version 2 - Intermediate Programmer</a></li><li class="breadcrumb-item"><a href="../autodoc_v2/05_snapshot_preparation_reshape_for_animations_generate_animation_df_.html">Chapter 5: Snapshot Preparation (`reshape_for_animations` &amp; `generate_animation_df`)</a></li></ol></nav></header>




<section id="chapter-5-snapshot-preparation-reshape_for_animations-generate_animation_df" class="level1">
<h1>Chapter 5: Snapshot Preparation (<code>reshape_for_animations</code> &amp; <code>generate_animation_df</code>)</h1>
<p>In <a href="../autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html">Chapter 4: Simpy Resource Enhancement</a>, we saw how to modify a <code>simpy</code> model using <code>CustomResource</code> and <code>simpy.Store</code> to log the specific <code>resource_id</code> used by each entity. This detailed tracking is crucial for accurate visualisation. Now, we move on to the next stage: transforming the raw simulation output (the <a href="../autodoc_v2/02_event_log_.html">Event Log</a>) into a format suitable for creating the animation frames.</p>
<section id="motivation-from-diary-to-film-reel" class="level2">
<h2 class="anchored" data-anchor-id="motivation-from-diary-to-film-reel">Motivation: From Diary to Film Reel</h2>
<p>Think back to the <a href="../autodoc_v2/02_event_log_.html">Event Log</a>. It’s like a detailed diary, recording every significant event (arrival, start queue, start treatment, departure) for each entity precisely when it happened. This is great for analysis, but for an animation, we need something different. An animation is like a film reel – a sequence of static images (frames or snapshots) shown in quick succession. Each frame needs to show the position of <em>every</em> entity visible at that <em>specific moment</em> in time.</p>
<p>Our raw <code>event_log</code> tells us <em>when Patient 5 started treatment</em>, but it doesn’t directly tell us <em>where Patient 5 was at exactly 10:30 AM</em>, or <em>who else</em> was in the clinic at that time and where they were. We need a process to convert the event-driven diary into a time-sliced film reel.</p>
<p>This conversion is the core task of the snapshot preparation stage, handled primarily by two functions: <code>reshape_for_animations</code> and <code>generate_animation_df</code>.</p>
</section>
<section id="key-concepts-slicing-time-and-placing-pieces" class="level2">
<h2 class="anchored" data-anchor-id="key-concepts-slicing-time-and-placing-pieces">Key Concepts: Slicing Time and Placing Pieces</h2>
<p>The transformation happens in two main steps, orchestrated behind the scenes by the main <a href="../autodoc_v2/01_animation_facade_animate_activity_log_.html">Animation Facade (<code>animate_activity_log</code>)</a>:</p>
<ol type="1">
<li><p><strong><code>reshape_for_animations</code> (Time Slicing):</strong> This function takes the raw <code>event_log</code> and slices simulation time into regular intervals (e.g., every 1 minute, every 10 minutes, controlled by the <code>every_x_time_units</code> parameter). For each time slice, it determines the state (i.e., the last recorded <code>event</code>, like ‘wait_nurse’ or ‘use_nurse’) of every entity currently active in the system. It effectively answers the question: “At time T, who was doing what?” It also calculates the rank of entities within the same state (e.g., position in a queue).</p></li>
<li><p><strong><code>generate_animation_df</code> (Position Calculation):</strong> This function takes the output from <code>reshape_for_animations</code> (which tells us <em>who</em> is doing <em>what</em> at each time slice) and combines it with the layout information from the <a href="../autodoc_v2/03_layout_configuration_event_position_df_.html">Layout Configuration (<code>event_position_df</code>)</a>. Its job is to calculate the exact <code>x_final</code> and <code>y_final</code> coordinates for every entity in every time slice. It handles the logic for arranging entities in queues (potentially wrapping them) and placing entities using specific resources based on their <code>resource_id</code>. It answers: “Given who is doing what at time T, and the layout map, <em>where exactly</em> should each entity be placed on the screen?”</p></li>
</ol>
<p>The overall flow looks like this:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
    A[Raw `event_log` DataFrame &lt;br&gt;(From Chapter 2)] --&gt; B(reshape_for_animations);
    B -- every_x_time_units --&gt; C[Snapshot DataFrame &lt;br&gt;(`full_patient_df`) &lt;br&gt; Columns: patient, minute, event, event_type, rank, resource_id...];
    C --&gt; D(generate_animation_df);
    E[Layout `event_position_df` DataFrame &lt;br&gt;(From Chapter 3)] --&gt; D;
    F[Layout Params &lt;br&gt;(wrap_queues_at, gaps...)] --&gt; D;
    D --&gt; G[Positioned Snapshot DataFrame &lt;br&gt;(`full_patient_df_plus_pos`) &lt;br&gt; Columns: patient, minute, event, icon, x_final, y_final...];
    G --&gt; H[Animation Generation &lt;br&gt;(generate_animation) &lt;br&gt;(Chapter 6)];
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Let’s delve into how each function works.</p>
</section>
<section id="time-slicing-with-reshape_for_animations" class="level2">
<h2 class="anchored" data-anchor-id="time-slicing-with-reshape_for_animations">Time Slicing with <code>reshape_for_animations</code></h2>
<p>The primary goal of <code>reshape_for_animations</code> is to convert the sparse, event-driven log into a dense, time-step-based representation.</p>
<p><strong>Purpose:</strong> To determine the state (most recent event) and rank (e.g., queue position) of every active entity at regular time intervals.</p>
<p><strong>Inputs:</strong> * <code>event_log</code>: The raw DataFrame as described in <a href="../autodoc_v2/02_event_log_.html">Chapter 2: Event Log</a>. * <code>every_x_time_units</code>: The gap between consecutive time snapshots (e.g., <code>1</code> for every minute, <code>10</code> for every 10 minutes). * <code>limit_duration</code>: The maximum simulation time to process. * <code>step_snapshot_max</code>: Limits how many entities are processed per event type in a single snapshot (for performance with very large queues).</p>
<p><strong>Process (Conceptual):</strong></p>
<ol type="1">
<li><strong>Pivot (Optional but helpful):</strong> The code often starts by pivoting the <code>event_log</code> slightly to easily access arrival and departure times per patient.</li>
<li><strong>Iterate Through Time:</strong> Loop through simulation time from 0 up to <code>limit_duration</code>, taking steps of size <code>every_x_time_units</code>. Let the current time step be <code>minute</code>.</li>
<li><strong>Identify Active Entities:</strong> For the current <code>minute</code>, find all <code>patient</code> identifiers that have <code>arrival</code> time &lt;= <code>minute</code> AND (<code>depart</code> time &gt;= <code>minute</code> OR <code>depart</code> time is missing/null). These are the entities currently “in the system”.</li>
<li><strong>Find Latest State:</strong> Filter the original <code>event_log</code> to include only events for these active entities that occurred at or before the current <code>minute</code>. For each active entity, find their <em>very last</em> event in this filtered set (using <code>groupby('patient').tail(1)</code> after sorting by time). This last event represents the entity’s state (e.g., ‘wait_nurse’, ‘use_nurse’) at this specific <code>minute</code>.</li>
<li><strong>Rank Entities:</strong> Within each <code>event</code> category at the current <code>minute</code>, rank the entities based on when they entered that state (often approximated by the original event log’s index or time). This gives us the <code>rank</code> column, crucial for queue ordering.</li>
<li><strong>Limit Snapshot Size:</strong> Apply the <code>step_snapshot_max</code> limit if needed.</li>
<li><strong>Store Snapshot:</strong> Store the details (patient, event, event_type, resource_id, rank, original event time, current snapshot <code>minute</code>) for this time step.</li>
<li><strong>Concatenate:</strong> After looping through all time steps, combine the stored snapshots into a single large DataFrame (<code>full_patient_df</code>).</li>
<li><strong>Add Exit State:</strong> Append a final ‘exit’ event for each patient one time step after their last recorded event. This ensures entities visibly leave the animation area rather than just vanishing.</li>
</ol>
<p><strong>Output (<code>full_patient_df</code>):</strong> A DataFrame where each row represents a specific entity (<code>patient</code>) in a specific state (<code>event</code>, <code>event_type</code>, potentially using <code>resource_id</code>) at a specific snapshot time (<code>minute</code>), along with their <code>rank</code> within that state at that time.</p>
<p><strong>Code Glimpse:</strong></p>
<p>Here’s a simplified view of the core logic inside <code>vidigi.prep.reshape_for_animations</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># From: vidigi/prep.py (Simplified)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reshape_for_animations(event_log,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                           every_x_time_units<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                           limit_duration<span class="op">=</span><span class="dv">14400</span>, <span class="co"># e.g., 10 days in minutes</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                           step_snapshot_max<span class="op">=</span><span class="dv">50</span>,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                           debug_mode<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    patient_dfs <span class="op">=</span> [] <span class="co"># To store snapshots for each minute</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Pivot helps find arrival/departure easily (simplified view)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    pivoted_log <span class="op">=</span> event_log.pivot_table(values<span class="op">=</span><span class="st">"time"</span>, index<span class="op">=</span><span class="st">"patient"</span>,</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                                        columns<span class="op">=</span><span class="st">"event"</span>,</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                                        aggfunc<span class="op">=</span><span class="st">'first'</span>) <span class="co"># Simplified pivot</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Iterate Through Time</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> minute <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, limit_duration, every_x_time_units):</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 3. Identify Active Entities</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        active_patients_mask <span class="op">=</span> (pivoted_log[<span class="st">'arrival'</span>] <span class="op">&lt;=</span> minute) <span class="op">&amp;</span> <span class="op">\</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>                               ((pivoted_log[<span class="st">'depart'</span>] <span class="op">&gt;=</span> minute) <span class="op">|</span> pd.isnull(pivoted_log[<span class="st">'depart'</span>]))</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        current_patients_in_moment <span class="op">=</span> pivoted_log[active_patients_mask].index</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> current_patients_in_moment.empty:</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 4. Find Latest State for active patients up to this minute</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>            patient_minute_df <span class="op">=</span> event_log[</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>                (event_log[<span class="st">'patient'</span>].isin(current_patients_in_moment)) <span class="op">&amp;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>                (event_log[<span class="st">'time'</span>] <span class="op">&lt;=</span> minute)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>            ].copy() <span class="co"># Filter original log</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Sort by time, then use groupby().tail(1) to get the latest event per patient</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            patient_minute_df <span class="op">=</span> patient_minute_df.sort_values([<span class="st">'time'</span>, <span class="st">'index'</span>]) <span class="co"># Assuming 'index' preserves original order</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>            most_recent_events <span class="op">=</span> patient_minute_df.groupby(<span class="st">'patient'</span>).tail(<span class="dv">1</span>)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 5. Rank Entities within each event group</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>            most_recent_events[<span class="st">'rank'</span>] <span class="op">=</span> most_recent_events.groupby(<span class="st">'event'</span>)[<span class="st">'time'</span>] <span class="op">\</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>                                        .rank(method<span class="op">=</span><span class="st">'first'</span>, ascending<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 6. Limit Snapshot Size (simplified)</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>            most_recent_events <span class="op">=</span> most_recent_events.groupby(<span class="st">'event'</span>).head(step_snapshot_max)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 7. Store Snapshot (adding the current minute)</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>            patient_dfs.append(most_recent_events.assign(minute<span class="op">=</span>minute))</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 8. Concatenate all snapshots</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    full_patient_df <span class="op">=</span> pd.concat(patient_dfs, ignore_index<span class="op">=</span><span class="va">True</span>) <span class="cf">if</span> patient_dfs <span class="cf">else</span> pd.DataFrame()</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 9. Add Exit State (simplified logic)</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> full_patient_df.empty:</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        final_step <span class="op">=</span> full_patient_df.loc[full_patient_df.groupby(<span class="st">'patient'</span>)[<span class="st">'minute'</span>].idxmax()]</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        final_step <span class="op">=</span> final_step.copy()</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>        final_step[<span class="st">'minute'</span>] <span class="op">=</span> final_step[<span class="st">'minute'</span>] <span class="op">+</span> every_x_time_units</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>        final_step[<span class="st">'event'</span>] <span class="op">=</span> <span class="st">"exit"</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>        final_step[<span class="st">'event_type'</span>] <span class="op">=</span> <span class="st">"arrival_departure"</span> <span class="co"># Consistent type needed</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        full_patient_df <span class="op">=</span> pd.concat([full_patient_df, final_step], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> full_patient_df.sort_values([<span class="st">"minute"</span>, <span class="st">"event"</span>]).reset_index(drop<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This function takes the raw event stream and effectively samples the state of the system at regular intervals, preparing the ground for spatial layout.</p>
</section>
<section id="calculating-positions-with-generate_animation_df" class="level2">
<h2 class="anchored" data-anchor-id="calculating-positions-with-generate_animation_df">Calculating Positions with <code>generate_animation_df</code></h2>
<p>Now that we know <em>who</em> is doing <em>what</em> at each time slice (<code>minute</code>), <code>generate_animation_df</code> figures out <em>exactly where</em> they should be drawn.</p>
<p><strong>Purpose:</strong> To calculate the final X and Y coordinates (<code>x_final</code>, <code>y_final</code>) for each entity in each snapshot, based on their state, rank/resource ID, and the defined layout.</p>
<p><strong>Inputs:</strong> * <code>full_patient_df</code>: The DataFrame output by <code>reshape_for_animations</code>. * <code>event_position_df</code>: The layout DataFrame from <a href="../autodoc_v2/03_layout_configuration_event_position_df_.html">Chapter 3: Layout Configuration</a>. * Layout parameters: <code>wrap_queues_at</code>, <code>wrap_resources_at</code>, <code>gap_between_entities</code>, <code>gap_between_resources</code>, <code>gap_between_rows</code>. * <code>custom_entity_icon_list</code>: Optional list of emojis/icons to use for entities.</p>
<p><strong>Process (Conceptual):</strong></p>
<ol type="1">
<li><strong>Merge Layout:</strong> Join <code>full_patient_df</code> with <code>event_position_df</code> on the <code>event</code> column. This brings the base <code>x</code> and <code>y</code> coordinates for each entity’s current state into the main DataFrame.</li>
<li><strong>Split by Event Type:</strong> Conceptually (or literally in the code), separate the rows based on <code>event_type</code> because positioning logic differs:
<ul>
<li><strong>Queues (<code>event_type == 'queue'</code>):</strong>
<ul>
<li>Start with the base <code>x</code>, <code>y</code> from the layout.</li>
<li>Calculate <code>x_final</code>: Typically subtract <code>rank * gap_between_entities</code> from the base <code>x</code> (queues usually extend leftwards).</li>
<li>Calculate <code>y_final</code>: Initially the base <code>y</code>.</li>
<li>Handle Wrapping: If <code>wrap_queues_at</code> is set, use the <code>rank</code> and <code>wrap_queues_at</code> to determine the row number (<code>row = floor((rank - 1) / wrap_queues_at)</code>). Adjust <code>x_final</code> (resetting based on position within the row) and <code>y_final</code> (adding <code>row * gap_between_rows</code>).</li>
</ul></li>
<li><strong>Resource Use (<code>event_type == 'resource_use'</code>):</strong>
<ul>
<li>Start with the base <code>x</code>, <code>y</code>.</li>
<li>Requires the <code>resource_id</code> column populated as per <a href="../autodoc_v2/04_simpy_resource_enhancement_customresource_store_populate_store_.html">Chapter 4</a>.</li>
<li>Calculate <code>x_final</code>: Typically subtract <code>resource_id * gap_between_resources</code> from the base <code>x</code>.</li>
<li>Calculate <code>y_final</code>: Initially the base <code>y</code>.</li>
<li>Handle Wrapping: Similar to queues, but using <code>resource_id</code> and <code>wrap_resources_at</code>. Adjust <code>x_final</code> and <code>y_final</code> based on the resource row.</li>
</ul></li>
<li><strong>Other Events (e.g., <code>arrival</code>, <code>exit</code>, custom non-queue/resource steps):</strong>
<ul>
<li>Usually, <code>x_final</code> and <code>y_final</code> are simply set to the base <code>x</code> and <code>y</code> from the layout.</li>
</ul></li>
</ul></li>
<li><strong>Combine Back:</strong> Concatenate the processed subsets back into a single DataFrame.</li>
<li><strong>Assign Icons:</strong> Generate a mapping from unique <code>patient</code> identifiers to icons (e.g., emojis from the default list or <code>custom_entity_icon_list</code>). Add an <code>icon</code> column to the DataFrame.</li>
<li><strong>Handle Snapshot Limit Visuals:</strong> If <code>step_snapshot_max</code> was applied in <code>reshape_for_animations</code>, this function might modify the icon/text for the last displayed entity in a truncated queue/resource group to indicate that more entities exist but aren’t shown (e.g., displaying “+ 5 more”).</li>
</ol>
<p><strong>Output (<code>full_patient_df_plus_pos</code>):</strong> The final DataFrame ready for plotting. Contains <code>patient</code>, <code>minute</code>, <code>event</code>, <code>icon</code>, and the crucial <code>x_final</code>, <code>y_final</code> coordinates, along with other potentially useful columns.</p>
<p><strong>Code Glimpse:</strong></p>
<p>Here’s a simplified look at the positioning logic within <code>vidigi.prep.generate_animation_df</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># From: vidigi/prep.py (Simplified)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_animation_df(</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        full_patient_df,</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        event_position_df,</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        wrap_queues_at<span class="op">=</span><span class="dv">20</span>,</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        wrap_resources_at<span class="op">=</span><span class="dv">20</span>,</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        gap_between_entities<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        gap_between_resources<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        gap_between_rows<span class="op">=</span><span class="dv">30</span>,</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... other params ...</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        custom_entity_icon_list<span class="op">=</span><span class="va">None</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Merge Layout info (base x, y)</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Assumes 'rank' column already exists from reshape_for_animations</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    df_plus_pos <span class="op">=</span> full_patient_df.merge(event_position_df[[<span class="st">'event'</span>, <span class="st">'x'</span>, <span class="st">'y'</span>]],</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>                                        on<span class="op">=</span><span class="st">"event"</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- 2. Split and Calculate Positions ---</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle Queues</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    queues <span class="op">=</span> df_plus_pos[df_plus_pos[<span class="st">'event_type'</span>] <span class="op">==</span> <span class="st">'queue'</span>].copy()</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> queues.empty:</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        queues[<span class="st">'x_final'</span>] <span class="op">=</span> queues[<span class="st">'x'</span>] <span class="op">-</span> queues[<span class="st">'rank'</span>] <span class="op">*</span> gap_between_entities</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        queues[<span class="st">'y_final'</span>] <span class="op">=</span> queues[<span class="st">'y'</span>]</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> wrap_queues_at <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>            queues[<span class="st">'row'</span>] <span class="op">=</span> np.floor((queues[<span class="st">'rank'</span>] <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> wrap_queues_at)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Adjust x based on position in the row</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>            queues[<span class="st">'x_final'</span>] <span class="op">+=</span> (wrap_queues_at <span class="op">*</span> queues[<span class="st">'row'</span>] <span class="op">*</span> gap_between_entities) <span class="op">+</span> gap_between_entities</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Adjust y based on the row</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>            queues[<span class="st">'y_final'</span>] <span class="op">+=</span> queues[<span class="st">'row'</span>] <span class="op">*</span> gap_between_rows</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle Resource Use</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    resources <span class="op">=</span> df_plus_pos[df_plus_pos[<span class="st">'event_type'</span>] <span class="op">==</span> <span class="st">'resource_use'</span>].copy()</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> resources.empty:</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Assumes 'resource_id' column exists and is numeric (1-based)</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        resources[<span class="st">'x_final'</span>] <span class="op">=</span> resources[<span class="st">'x'</span>] <span class="op">-</span> resources[<span class="st">'resource_id'</span>] <span class="op">*</span> gap_between_resources</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        resources[<span class="st">'y_final'</span>] <span class="op">=</span> resources[<span class="st">'y'</span>]</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> wrap_resources_at <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>            resources[<span class="st">'row'</span>] <span class="op">=</span> np.floor((resources[<span class="st">'resource_id'</span>] <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> wrap_resources_at)</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Adjust x based on position in the row</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>            resources[<span class="st">'x_final'</span>] <span class="op">+=</span> (wrap_resources_at <span class="op">*</span> resources[<span class="st">'row'</span>] <span class="op">*</span> gap_between_resources) <span class="op">+</span> gap_between_resources</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Adjust y based on the row</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>            resources[<span class="st">'y_final'</span>] <span class="op">+=</span> resources[<span class="st">'row'</span>] <span class="op">*</span> gap_between_rows</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle Other events (simplified - assume they just use base x, y)</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    others <span class="op">=</span> df_plus_pos[<span class="op">~</span>df_plus_pos[<span class="st">'event_type'</span>].isin([<span class="st">'queue'</span>, <span class="st">'resource_use'</span>])].copy()</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> others.empty:</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>        others[<span class="st">'x_final'</span>] <span class="op">=</span> others[<span class="st">'x'</span>]</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>        others[<span class="st">'y_final'</span>] <span class="op">=</span> others[<span class="st">'y'</span>]</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Combine Back</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>    final_df_parts <span class="op">=</span> [part <span class="cf">for</span> part <span class="kw">in</span> [queues, resources, others] <span class="cf">if</span> <span class="kw">not</span> part.empty]</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    final_df <span class="op">=</span> pd.concat(final_df_parts, ignore_index<span class="op">=</span><span class="va">True</span>) <span class="cf">if</span> final_df_parts <span class="cf">else</span> pd.DataFrame()</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. Assign Icons (simplified)</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> final_df.empty:</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>        unique_patients <span class="op">=</span> final_df[<span class="st">'patient'</span>].unique()</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Default icon list or custom list</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>        icon_list <span class="op">=</span> custom_entity_icon_list <span class="kw">or</span> get_default_icon_list()</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>        icon_map <span class="op">=</span> {patient: icon_list[i <span class="op">%</span> <span class="bu">len</span>(icon_list)] <span class="cf">for</span> i, patient <span class="kw">in</span> <span class="bu">enumerate</span>(unique_patients)}</span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>        final_df[<span class="st">'icon'</span>] <span class="op">=</span> final_df[<span class="st">'patient'</span>].<span class="bu">map</span>(icon_map)</span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 5. Handle Snapshot Limit Visuals (logic omitted for brevity)</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... code to potentially modify 'icon' for truncated groups ...</span></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> final_df.sort_values([<span class="st">'minute'</span>, <span class="st">'patient'</span>]) <span class="co"># Return sorted</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a><span class="co"># Helper function (conceptual)</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_default_icon_list():</span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [<span class="st">'🧔🏼'</span>, <span class="st">'👨🏿‍🦯'</span>, <span class="st">'👨🏻‍🦰'</span>, <span class="st">'🧑🏻'</span>, <span class="st">'👩🏿‍🦱'</span>, <span class="st">'🤰'</span>, <span class="st">'👳🏽'</span>, <span class="st">'👩🏼‍🦳'</span>, <span class="st">'👨🏿‍🦳'</span>, <span class="st">'👩🏼‍🦱'</span>, ...] <span class="co"># A long list of emojis</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This function takes the time-sliced data and applies the spatial rules defined by the layout, producing the exact coordinates needed frame-by-frame.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The snapshot preparation stage, comprising <code>reshape_for_animations</code> and <code>generate_animation_df</code>, is the crucial data transformation engine within <code>vidigi</code>. It bridges the gap between the raw, event-based simulation output (<code>event_log</code>) and the frame-by-frame requirements of an animation.</p>
<p><code>reshape_for_animations</code> processes the event log to determine <em>who</em> is doing <em>what</em> at regular time intervals, creating time slices. <code>generate_animation_df</code> then takes these time slices and the layout configuration (<code>event_position_df</code>) to calculate the precise X/Y coordinates for each entity in each slice, handling queue formation and resource allocation visually.</p>
<p>The result is a comprehensive DataFrame (<code>full_patient_df_plus_pos</code>) containing everything needed to draw each frame: the entity identifier, the time snapshot, the assigned icon, and the final <code>x_final</code>, <code>y_final</code> position.</p>
<p>With this meticulously prepared data, we are finally ready to generate the animation itself using Plotly.</p>
<p>Next: <a href="../autodoc_v2/06_animation_generation_generate_animation_.html">Chapter 6: Animation Generation (<code>generate_animation</code>)</a></p>
<hr>
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>